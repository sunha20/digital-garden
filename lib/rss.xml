<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://sunha20.github.io/digital-garden/</link><image><url>https://sunha20.github.io/digital-garden/lib/media/favicon.png</url><title>Obsidian</title><link>https://sunha20.github.io/digital-garden/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 29 Oct 2024 08:17:33 GMT</lastBuildDate><atom:link href="https://sunha20.github.io/digital-garden/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 29 Oct 2024 08:17:32 GMT</pubDate><copyright><![CDATA[seonha20]]></copyright><ttl>60</ttl><dc:creator>seonha20</dc:creator><item><title><![CDATA[Coding Test]]></title><description><![CDATA[ 
 <br><br><br><a data-tooltip-position="top" aria-label="1. Study/Coding Test/new file.md" data-href="1. Study/Coding Test/new file.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/new file" class="internal-link" target="_self" rel="noopener nofollow">new file</a>   |   <a data-tooltip-position="top" aria-label="1. Study/Coding Test/new folder/new folder.md" data-href="1. Study/Coding Test/new folder/new folder.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/new folder/new folder" class="internal-link" target="_self" rel="noopener nofollow">new folder</a><br><br><br><br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/coding-test.html</link><guid isPermaLink="false">1. Study/Coding Test/Coding Test.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 29 Oct 2024 08:12:37 GMT</pubDate></item><item><title><![CDATA[계산 오차]]></title><description><![CDATA[ 
 <br><a data-href="1072. 게임" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1072.-게임.html" class="internal-link" target="_self" rel="noopener nofollow">1072. 게임</a><br>참고: <a data-tooltip-position="top" aria-label="https://youtu.be/-GsrYvZoAdA?si=zYEwjxJs2aowVkE5" rel="noopener nofollow" class="external-link" href="https://youtu.be/-GsrYvZoAdA?si=zYEwjxJs2aowVkE5" target="_blank">위 수식이 틀린 이유는? (개발자 면접 타임) - YouTube</a><br>“컴퓨터는 무한한 숫자를 저장하지 못한다.”는 쉽게 동의할 수 있는 명제이다.<br>그러나 이 의미를 정확히 숙지하지 않고 코드를 짜다간 단순히 큰 수를 표현하지 못하는 것으로부터, 계산 결과를 전혀 다르게 만드는 들 불안정한 코드가 완성되게 된다.<br><br>각각의 자료형은 고유한 메모리 크기를 가지고, 그 크기에 기반하여 해당 자료형이 표현할 수 있는 범위가 정해진다. 숫자를 표현하는 자료형은 경우 정수 자료형과 실수 자료형으로 나뉘고, 각각은 또 여러 개의 자료형으로 나뉜다.<br><br>자바에서 정수를 표현하기 위한 자료형은 byte, short, int, long이 있다. 자주 사용하는 것은 int, long 정도 이다.<br><br>각 자료형 별로 표현범위를 벗어나는 값을 저장하는 경우, 전혀 다른 값이 저장되게 된다.<br>
예를 들어 ]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/etc/계산-오차.html</link><guid isPermaLink="false">1. Study/Coding Test/etc/계산 오차.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 29 Oct 2024 06:25:37 GMT</pubDate></item><item><title><![CDATA[etc]]></title><description><![CDATA[ 
 <br><br><br><a data-tooltip-position="top" aria-label="1. Study/Coding Test/etc/new file.md" data-href="1. Study/Coding Test/etc/new file.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/etc/new file" class="internal-link" target="_self" rel="noopener nofollow">new file</a>   |   <a data-tooltip-position="top" aria-label="1. Study/Coding Test/etc/new folder/new folder.md" data-href="1. Study/Coding Test/etc/new folder/new folder.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/etc/new folder/new folder" class="internal-link" target="_self" rel="noopener nofollow">new folder</a><br><br><br><br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/etc/etc.html</link><guid isPermaLink="false">1. Study/Coding Test/etc/etc.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 29 Oct 2024 08:12:37 GMT</pubDate></item><item><title><![CDATA[Algorithm]]></title><description><![CDATA[ 
 <br><br><br><a data-tooltip-position="top" aria-label="1. Study/Coding Test/Algorithm/new file.md" data-href="1. Study/Coding Test/Algorithm/new file.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/Algorithm/new file" class="internal-link" target="_self" rel="noopener nofollow">new file</a>   |   <a data-tooltip-position="top" aria-label="1. Study/Coding Test/Algorithm/new folder/new folder.md" data-href="1. Study/Coding Test/Algorithm/new folder/new folder.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/Algorithm/new folder/new folder" class="internal-link" target="_self" rel="noopener nofollow">new folder</a><br><br><br><br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/algorithm.html</link><guid isPermaLink="false">1. Study/Coding Test/Algorithm/Algorithm.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 29 Oct 2024 05:15:05 GMT</pubDate></item><item><title><![CDATA[PS]]></title><description><![CDATA[ 
 <br><br><br><a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/new file.md" data-href="1. Study/Coding Test/PS/new file.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/PS/new file" class="internal-link" target="_self" rel="noopener nofollow">new file</a>   |   <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/new folder/new folder.md" data-href="1. Study/Coding Test/PS/new folder/new folder.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/PS/new folder/new folder" class="internal-link" target="_self" rel="noopener nofollow">new folder</a><br><br><br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/PS.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 29 Oct 2024 06:43:26 GMT</pubDate></item><item><title><![CDATA[1072. 게임]]></title><description><![CDATA[ 
 <br><br><br>김형택은 지금 몰래 Spider Solitaire(스파이더 카드놀이)를 하고 있다. 형택이는 이 게임을 이길 때도 있었지만, 질 때도 있었다. 누군가의 시선이 느껴진 형택이는 게임을 중단하고 코딩을 하기 시작했다. 의심을 피했다고 생각한 형택이는 다시 게임을 켰다. 그 때 형택이는 잠시 코딩을 하는 사이에 자신의 게임 실력이 눈에 띄게 향상된 것을 알았다.<br>
이제 형택이는 앞으로의 모든 게임에서 지지 않는다. 하지만, 형택이는 게임 기록을 삭제 할 수 없기 때문에, 자신의 못하던 예전 기록이 현재 자신의 엄청난 실력을 증명하지 못한다고 생각했다.<br>
게임 기록은 다음과 같이 생겼다.<br>
<br>게임 횟수 : X
<br>이긴 게임 : Y (Z%)
<br>Z는 형택이의 승률이고, 소수점은 버린다. 예를 들어, X=53, Y=47이라면, Z=88이다.<br>
X와 Y가 주어졌을 때, 형택이가 게임을 최소 몇 번 더 해야 Z가 변하는지 구하는 프로그램을 작성하시오.
<br><br>각 줄에 정수 X와 Y가 주어진다.<br><br>첫째 줄에 형택이가 게임을 최소 몇 판 더 해야하는지 출력한다. 만약 Z가 절대 변하지 않는다면 -1을 출력한다.<br><br>
<br>1 ≤ X ≤ 1,000,000,000
<br>0 ≤ Y ≤ X
<br><br><br><br>승률이 변하는 지점을 ‘찾는’ 문제 → 배열 탐색 중 <a data-href="이분탐색" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/이분탐색.html" class="internal-link" target="_self" rel="noopener nofollow">이분탐색</a> 사용<br>기본 문제처럼 굳이 실제 배열을 만들어서 인덱스로 접근하는 등의 방법을 사용하진 않아도 된다.<br>
hi lo mid 값을 추가 실행 횟수로 설정하여 승률 계산에 사용하는 방법으로 해결함.<br>비교적 큰수를 다루는 문제이면서 나눗셈이 들어가는 문제이다 보니, 컴퓨터 시스템적 제약으로 인한 오류들이 많이 발생했음(overflow나 정밀도 손상과 같은 문제들)<br>
<br>부동소수점 문제

<br>나눈 값이 소수점 아래로 긴 값이라 저장 가능 범위를 넘어선다면, 소수점 데이터에 오차가 발생
<br>거기에 100을 곱한다면 오차가 더 커지게 됨.
<br>→ 100을 먼저 곱하고 나누어서 오차를 줄이는 방법을 사용


<br>정수 오버플로우

<br>위의 문제 해결을 위해 100을 먼저 곱하게 되면, int 형이 수용할 수 없는 값이 생성 될 수 있음.
<br>int 형이 저장할 수 있는 최댓값이 2,147,483,647인데, y 최댓값 1,000,000,000에 100을 곱하면 overflow가 발생
<br>→ 자료형을 long으로 변경: 메모리 많이 사용.
<br>→ double로 계산하고 int로 type casting


<br>// 수정 전
int x = 100;
int y = 80;
// ...
int now = (double) (y+i) / (x+i) * 100; // double로 계산하지 않으면 소숫점 아래는 다 잘려서 잘못된 값이 나옴

// 곱하기 연산을 먼저하는 것으로 수정
int x = 100;
int y = 80;
// ...
int now = (y+i) * 100 / (x+i) ; // 100을 먼저 곱하면 필요한 부분 만큼(0~100)은 제대로 계산되기 때문에 double로 계산하지 않아도 된다고 생각.

// double 형으로 계산
int x = 100;
int y = 80;
// ...
int now = (int) ((double) (y+i)/(x+i) *100);

// 곱하기 연산을 먼저하는 것으로 수정
double x = 100.0;
double y = 80.0;
// ...
int now =(int) ((y+i) * 100/(x+i));

복사<br>해당 주제에 대한 자세한 내용은 다음 링크 참고<br>+)<br>
<br>승률이 Z보다 작은 경우는 고려하지 않아도됨.
<br><br>import java.io.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        String[] temp = br.readLine().split(" ");  
        int X = Integer.parseInt(temp[0]);  
        int Y = Integer.parseInt(temp[1]);  
        int Z = (int) ((double) Y * 100 / X);  
        if (Z == 100) {  
            System.out.println(-1);  
            return;  
        }  
  
        int lo = 0;  
        int hi = 1000000000;  
        int mid, now;  
  
        while (lo&lt;hi) {  
            mid = (lo+hi)/2;  
            now = getWinRate(X, Y, mid);  
  
            if (now == Z) {  
                lo = mid + 1;  
                continue;  
            }  
  
            if (now &gt; Z) {  
                hi = mid;  
            }  
        }  
  
        if (getWinRate(X, Y, hi) == Z) System.out.println(-1);  
        else System.out.println(hi);  
    }  
  
    private static int getWinRate(int x, int y, int i) {  
        return (int) ((double) (y+i) * 100/(x+i));  
    }  
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1072.-게임.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1072. 게임.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 29 Oct 2024 06:41:21 GMT</pubDate></item><item><title><![CDATA[99클럽 코테 스터디 1일차 TIL 이분탐색]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:99클럽" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#99클럽</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트준비" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트준비</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:개발자취업" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#개발자취업</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:항해99" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#항해99</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:TIL" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#TIL</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:99클럽" class="tag" target="_blank" rel="noopener nofollow">#99클럽</a> <a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트준비" class="tag" target="_blank" rel="noopener nofollow">#코딩테스트준비</a> <a href="https://sunha20.github.io/digital-garden?query=tag:개발자취업" class="tag" target="_blank" rel="noopener nofollow">#개발자취업</a> <a href="https://sunha20.github.io/digital-garden?query=tag:항해99" class="tag" target="_blank" rel="noopener nofollow">#항해99</a> <a href="https://sunha20.github.io/digital-garden?query=tag:TIL" class="tag" target="_blank" rel="noopener nofollow">#TIL</a><br><br><br>김형택은 지금 몰래 Spider Solitaire(스파이더 카드놀이)를 하고 있다. 형택이는 이 게임을 이길 때도 있었지만, 질 때도 있었다. 누군가의 시선이 느껴진 형택이는 게임을 중단하고 코딩을 하기 시작했다. 의심을 피했다고 생각한 형택이는 다시 게임을 켰다. 그 때 형택이는 잠시 코딩을 하는 사이에 자신의 게임 실력이 눈에 띄게 향상된 것을 알았다.<br>
이제 형택이는 앞으로의 모든 게임에서 지지 않는다. 하지만, 형택이는 게임 기록을 삭제 할 수 없기 때문에, 자신의 못하던 예전 기록이 현재 자신의 엄청난 실력을 증명하지 못한다고 생각했다.<br>
게임 기록은 다음과 같이 생겼다.<br>
<br>게임 횟수 : X
<br>이긴 게임 : Y (Z%)
<br>Z는 형택이의 승률이고, 소수점은 버린다. 예를 들어, X=53, Y=47이라면, Z=88이다.<br>
X와 Y가 주어졌을 때, 형택이가 게임을 최소 몇 번 더 해야 Z가 변하는지 구하는 프로그램을 작성하시오.
<br><br>각 줄에 정수 X와 Y가 주어진다.<br><br>첫째 줄에 형택이가 게임을 최소 몇 판 더 해야하는지 출력한다. 만약 Z가 절대 변하지 않는다면 -1을 출력한다.<br><br>
<br>1 ≤ X ≤ 1,000,000,000
<br>0 ≤ Y ≤ X
<br><br><br><br>승률이 변하는 지점을 ‘찾는’ 문제 → 배열 탐색 중 <a data-href="이분탐색" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/이분탐색.html" class="internal-link" target="_self" rel="noopener nofollow">이분탐색</a> 사용<br>기본 문제처럼 굳이 실제 배열을 만들어서 인덱스로 접근하는 등의 방법을 사용하진 않아도 된다.<br>
hi lo mid 값을 추가 실행 횟수로 설정하여 승률 계산에 사용하는 방법으로 해결함.<br>비교적 큰수를 다루는 문제이면서 나눗셈이 들어가는 문제이다 보니, 컴퓨터 시스템적 제약으로 인한 오류들이 많이 발생했음(overflow나 정밀도 손상과 같은 문제들)<br>
<br>부동소수점 문제

<br>나눈 값이 소수점 아래로 긴 값이라 저장 가능 범위를 넘어선다면, 소수점 데이터에 오차가 발생
<br>거기에 100을 곱한다면 오차가 더 커지게 됨.
<br>→ 100을 먼저 곱하고 나누어서 오차를 줄이는 방법을 사용


<br>정수 오버플로우

<br>위의 문제 해결을 위해 100을 먼저 곱하게 되면, int 형이 수용할 수 없는 값이 생성 될 수 있음.
<br>int 형이 저장할 수 있는 최댓값이 2,147,483,647인데, y 최댓값 1,000,000,000에 100을 곱하면 overflow가 발생
<br>→ 자료형을 long으로 변경: 메모리 많이 사용.
<br>→ double로 계산하고 int로 type casting


<br>// 수정 전
int x = 100;
int y = 80;
// ...
int now = (double) (y+i) / (x+i) * 100; // double로 계산하지 않으면 소숫점 아래는 다 잘려서 잘못된 값이 나옴

// 곱하기 연산을 먼저하는 것으로 수정
int x = 100;
int y = 80;
// ...
int now = (y+i) * 100 / (x+i) ; // 100을 먼저 곱하면 필요한 부분 만큼(0~100)은 제대로 계산되기 때문에 double로 계산하지 않아도 된다고 생각.

// double 형으로 계산
int x = 100;
int y = 80;
// ...
int now = (int) ((double) (y+i)/(x+i) *100);

// 곱하기 연산을 먼저하는 것으로 수정
double x = 100.0;
double y = 80.0;
// ...
int now =(int) ((y+i) * 100/(x+i));

복사<br>해당 주제에 대한 자세한 내용은 <a data-tooltip-position="top" aria-label="계산 오차" data-href="계산 오차" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/이모저모/계산-오차.html" class="internal-link" target="_self" rel="noopener nofollow">다음 링크</a> 참고<br>+)<br>
<br>승률이 Z보다 작은 경우는 고려하지 않아도됨.
<br><br>import java.io.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        String[] temp = br.readLine().split(" ");  
        int X = Integer.parseInt(temp[0]);  
        int Y = Integer.parseInt(temp[1]);  
        int Z = (int) ((double) Y * 100 / X);  
        if (Z == 100) {  
            System.out.println(-1);  
            return;  
        }  
  
        int lo = 0;  
        int hi = 1000000000;  
        int mid, now;  
  
        while (lo&lt;hi) {  
            mid = (lo+hi)/2;  
            now = getWinRate(X, Y, mid);  
  
            if (now == Z) {  
                lo = mid + 1;  
                continue;  
            }  
  
            if (now &gt; Z) {  
                hi = mid;  
            }  
        }  
  
        if (getWinRate(X, Y, hi) == Z) System.out.println(-1);  
        else System.out.println(hi);  
    }  
  
    private static int getWinRate(int x, int y, int i) {  
        return (int) ((double) (y+i) * 100/(x+i));  
    }  
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/99클럽-코테-스터디-1일차-til-이분탐색.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/99클럽 코테 스터디 1일차 TIL 이분탐색.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 29 Oct 2024 06:44:18 GMT</pubDate></item><item><title><![CDATA[한수]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener nofollow">#코딩테스트</a><br><br>ID: 1065<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1065" target="_blank">https://www.acmicpc.net/problem/1065</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 브루트포스 알고리즘<br>
생성 일시: 2023년 5월 2일 오전 10:24<br><br>
💡 다른 풀이 이해하기<br><br><br><br><br>어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에 1,000보다 작거나 같은 자연수 N이 주어진다.<br><br>첫째 줄에 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력한다.<br><br>110

복사<br><br>99

복사<br><br>1

복사<br><br>1

복사<br><br>210

복사<br><br>105

복사<br><br>1000

복사<br><br>144

복사<br><br>500

복사<br><br>119

복사<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/bdh3313" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/bdh3313" target="_blank">bdh3313</a>
<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>
<br>입력 자릿수가 2보다 같거나 작으면 그대로 출력하면됨
<br>2보다 크면, 두가지 선택지가 있는데

<br>하나는 다 구해서, 속하는 것까지 잘라내기
<br>나머지 하나는 규칙성을 가지고 구하기. → 어려우니까 일단 위에걸로.


<br><br>import sys

def solution():
    x = int(sys.stdin.readline().rstrip())
    # x = int(x_str)

    if x &lt;= 99:
        return(x)
    
    n = 100
    result = 99

    while n &lt;= x:
        a_0 = n % 10
        a_1 = (n//10) % 10
        d = a_1 - a_0

        result += 1
        n_len = len(str(n))

        for i in range(2,n_len):
            a_0 = a_1
            a_1 = (n//(10**i)) % 10

            if d != a_1 - a_0:
                result -= 1 
                break
        n += 1

    return result  

if __name__ == "__main__":
    print(solution())
복사<br><br>
<br>훨씬 빠른 풀이가 있었음
<br>이해해보기
<br>def func(a):
    if(a&lt;100):
        return a
    else:
        x = 99
        for i in range(100,a+1):
            
            if(int(i/100)+i%10==2*(int(i/10)%10)):
                x = x+1
        return x

x = int(input())
print(func(x))
복사<br><br>
<br>보다 규칙성과 확장성을 가진 코드로 만들어 보기로함
<br>import sys

def solution():
    x = int(sys.stdin.readline().rstrip())

    # x: 두자리 이하의 양의정수
    if x &lt;= 99:
        return(x)
    
    # x가 abc(d)일 때 a(b-1)9(9)까지 탐색
    n = 10
    result = 99
    i = 1
    
    while n &lt; x//(10**i):
        d = ((n%10) - (n//10))*i
        a_1 = n%10
        
        if a_1+d &gt;= 0 and a_1+d&lt;=9:
            result+=1
        
        n += 1
        # 자릿수 변화
        if n == 100:
            n = 10
            i += 1

    # ab--일때 탐색
    a_1 = n%10
    d = ((n%10) - (n//10))*i
    if a_1+d &gt;= 0 and a_1+d&lt;=9:
        x_ = n
        for j in range(1,i+1):
            d = ((n%10) - (n//10))*j        
            x_ = x_*(10*j) + (d+a_1)

        if x_ &lt;= x:
            result += 1
    return result  

if __name__ == "__main__":
    print(solution())
복사<br>
<br>원래는 자릿수 변환이 i =2 였는데, 더 많은 자릿수에서 작동할 수 있도록 i+=로 변경
<br>확실히 위 아래 코드를 비교했을 때, 후자가 빠름

<br>input = 1000000

<br>전자: 5.945936679840088
<br>후자: 3.5561044216156006


<br>input = 10000000

<br>전자: 23.153870820999146
<br>후자: 2.911761999130249




<br>시간복잡도

<br>전자: x*x의 자릿수-3
<br>후자: (while) (n)99*x의자릿수-2 + 자릿수.
<br>x의 자릿수를 x에 대한 식으로 표현가능하다고 본다면,
<br>전자는 O(x^2) / 후자는 O(x)


<br><br>
<br>python 시간 복잡도를 측정하는 방법
import time
start = time.time()

...

print("time :", time.time() - start)
복사

]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/한수.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/한수.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:06:03 GMT</pubDate></item><item><title><![CDATA[통계학]]></title><description><![CDATA[ 
 <br><br>ID: 2108<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2108" target="_blank">https://www.acmicpc.net/problem/2108</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
생성 일시: 2023년 7월 26일 오후 11:48<br><br><br><br><br>수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자.<br>
<br>산술평균 : N개의 수들의 합을 N으로 나눈 값
<br>중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값
<br>최빈값 : N개의 수들 중 가장 많이 나타나는 값
<br>범위 : N개의 수들 중 최댓값과 최솟값의 차이
<br>N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 단, N은 홀수이다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다.<br><br>첫째 줄에는 산술평균을 출력한다. 소수점 이하 첫째 자리에서 반올림한 값을 출력한다.<br>둘째 줄에는 중앙값을 출력한다.<br>셋째 줄에는 최빈값을 출력한다. 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.<br>넷째 줄에는 범위를 출력한다.<br><br>5
1
3
8
-2
2

복사<br><br>2
2
1
10

복사<br><br>1
4000

복사<br><br>4000
4000
4000
0

복사<br><br>5
-1
-2
-3
-1
-2

복사<br><br>-2
-2
-1
2

복사<br><br>3
0
0
-1

복사<br><br>0
0
0
1

복사<br>(0 + 0 + (-1)) / 3 =&nbsp;-0.333333... 이고 이를 첫째 자리에서 반올림하면 0이다. -0으로 출력하면 안된다.<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/bjh3502" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/bjh3502" target="_blank">bjh3502</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/bsyun0571" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/bsyun0571" target="_blank">bsyun0571</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jungyh1509" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jungyh1509" target="_blank">jungyh1509</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/kongum" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/kongum" target="_blank">kongum</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/palilo" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/palilo" target="_blank">palilo</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/YunGoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/YunGoon" target="_blank">YunGoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/skynet" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/skynet" target="_blank">skynet</a>
<br><br>
<br>아 음수 받는 걸 생각못함.. idxf로 최빈값 찾기불가
<br>복사<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/통계학.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/통계학.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[프린터 큐]]></title><description><![CDATA[ 
 <br><br>ID: 1966<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1966" target="_blank">https://www.acmicpc.net/problem/1966</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
분류: 구현, 시뮬레이션, 자료구조, 큐<br>
생성 일시: 2023년 9월 14일 오후 12:04<br><br><br><br><br>여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.<br>
<br>현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.
<br>나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.
<br>예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.<br>여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.<br><br>첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.<br>테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M &lt; N)이 주어진다. 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.<br><br>각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.<br><br>3
1 0
5
4 2
1 2 3 4
6 0
1 1 9 1 1 1

복사<br><br>1
2
5

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/1" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/1" target="_blank">ICPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/7" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/7" target="_blank">Regionals</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/10" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/10" target="_blank">Europe</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/15" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/15" target="_blank">Northwestern European Regional Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/55" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/55" target="_blank">NWERC 2006</a>&nbsp;F번<br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/doju" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/doju" target="_blank">doju</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/iiwwnnaa" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/iiwwnnaa" target="_blank">iiwwnnaa</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br>원래 진짜 문제에 나온대로 pop하고 append하는 식으로 했는데 너무 과해,,,,
<br>그냥 화살표를 옮기는 방식으로 하자.
<br><br>import sys

def printque():
    N = int(sys.stdin.readline().rstrip())

    for i in range(N):
        num, idx = map(int, sys.stdin.readline().split())
        que = list(map(int, sys.stdin.readline().split()))
        result(que, idx)

def result(que, target):
    cnt = 0
    flag = 0
    M = max(que)

    while True:
        if que[flag] == M and que[flag] != -1:
            cnt += 1
            if target == flag:
                print(cnt)
                break
            que[flag] = -1
            M = max(que)

        flag = (flag+1)% len(que)

    return

if __name__ == "__main__":
    printque()
복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/프린터-큐.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/프린터 큐.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[트리]]></title><description><![CDATA[ 
 <br><br>ID: 0<br>
Site: 알고리즘<br>
다시풀기: No<br>
분류: 너비 우선 탐색, 트리<br>
생성 일시: 2023년 8월 19일 오후 4:51<br><br><br>
<br>Tree: set of node → node have a parent-child relationship

<br>In order for a tree to form, It needs root.


<br>Root

<br>node is the essential component.
<br>has no parent


<br>Understanding to use the tree when we write recursive code

<br>tree can be of only one node(root) with empyt subtree
<br>or even empty


<br>Use to store the information that have inherent relationships.
<br>ordered tree means hierarchical and linear relationships among the children of each node
<br><br>
<br>nodes(vertax), edges
<br>root
<br>child, parent, sibiling(same level)
<br>descendant, ancestor → 판단 기준: reachable
<br>exteranal nodes(leave), internal nodes → 판단 기준: have child
<br>sub tree
<br>degree of a node: number of its children
<br>path:

<br>set of edges that connect two node
<br>tyer exists a unique path between any pair of nodes


<br>level: length of unique path from the root to node
<br>height of a tree: maximum level of a node
<br><br>
<br>ordered tree
<br>every node has at most two children (left child, right child)
<br>type

<br>proper: all nodes have exactly zero of two children ←→ improper


<br>example

<br>dicision tree
<br>arithmetic expression


<br><br>
<br>n = # of nodes
<br>n_e = # of external nodes
<br>n_i = # of intermal nodes
<br>h = height of tree
<br>
<br>
<br>
<br>
<br><br>
<br>general tree → linked structure

<br>node haves

<br>element
<br>parent
<br>sequence of children




<br><br><br>
<br>node haves

<br>element
<br>parent
<br>left child
<br>right child


<br>time complexity

<br>add, delete (except find): O(1)
<br>height: O(n) → check all node to find maximum depth.


<br><br>
<br>position

<br>assign an index to each node based on level: level numbering
<br>index(root) = 0
<br>index(left child) = 2(index(parant node)) + 1
<br>index(right child) = 2(index(parant node)) + 2


<br>advantage

<br>position p can be expressed by single integer
<br>parent,left, and right of p can all be arithmetically computed


<br>disadvantage

<br>size of array depend on max f(p) → can have a lot of empty node (ex) right-child-only tree)
<br>Updating(add, delete) a node is cannot be done efficiently.

<br>O(n) → 중간에 빼거나 넣는 경우 자리를 다 옮겨줘야함.




<br><br><br>
<br>depth-first
<br>visit node before its descendants. → 조상부터 방문
<br>(recusive) visit → move to next node(child, sibiling)

<br>visit → child chcek → visit → child child check → x → child sibiling


<br>order: root → left → right
<br><br>
<br>depth-first
<br>visit node before its ancestor. → 후손부터 방문
<br>(recusive) move to next node(child, sibiling) → visit

<br>child chcek → child child check → x → child visit → child sibiling child check → x → visit → child sibiling sibiling x → parent visit.


<br>order : left → right → root
<br><br>
<br>non-recursive
<br>visit all the nodes in each level before checking the nodes at the next level
<br>implement to use queue → when the node is popped, the children of the node is appended.
<br>노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택<br>
<a rel="noopener nofollow" class="external-link" href="https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html" target="_blank">https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html</a>
<br><br>
<br>left chect → visit → root → right
<br>if left → if left → if left → visit → root visit → right visit → left visit → rot visit
<br>order: left → root → right
<br>def inorder(v)
	if left(v) != null:
		print("(")
		inorder(left(v))
	print(v.element)
	if right(v) != null:
		inorder(right(v))

복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/트리.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/트리.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[터렛]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:실버/3" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실버/3</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener nofollow">#코딩테스트</a><br>
<a href="https://sunha20.github.io/digital-garden?query=tag:실버/3" class="tag" target="_blank" rel="noopener nofollow">#실버/3</a><br><br><br>조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승환의 사진이다.<br><img src="https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg" referrerpolicy="no-referrer"><br>이석원은 조규현과 백승환에게 상대편 마린(류재명)의 위치를 계산하라는 명령을 내렸다. 조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.<br>조규현의 좌표&nbsp;(�1,�1)와 백승환의 좌표&nbsp;(�2,�2)가 주어지고, 조규현이 계산한 류재명과의 거리&nbsp;�1과 백승환이 계산한 류재명과의 거리&nbsp;�2가 주어졌을 때, 류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에 테스트 케이스의 개수&nbsp;�가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.<br>한 줄에 공백으로 구분 된 여섯 정수&nbsp;�1,&nbsp;�1,&nbsp;�1,&nbsp;�2,&nbsp;�2,&nbsp;�2가 주어진다.<br><br>각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는&nbsp;−1&nbsp;출력한다.<br><br>
<br> −10000≤�1,�1,�2,�2≤10000 
<br> 1≤�1,�2≤10000 
<br><br>3<br>
0 0 13 40 0 37<br>
0 0 3 0 7 4<br>
1 1 1 1 1 5<br><br>2<br>
1<br>
0<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baemin0103" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baemin0103" target="_blank">baemin0103</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/koyh1200" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/koyh1200" target="_blank">koyh1200</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/dksdks3737" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/dksdks3737" target="_blank">dksdks3737</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/doju" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/doju" target="_blank">doju</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/100" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/100" target="_blank">기하학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/137" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/137" target="_blank">많은 조건 분기</a>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/터렛.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/터렛.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 02 Mar 2024 02:40:50 GMT</pubDate><enclosure url="https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[큐]]></title><description><![CDATA[ 
 <br><br>ID: 10845<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/10845" target="_blank">https://www.acmicpc.net/problem/10845</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 자료구조, 큐<br>
생성 일시: 2023년 4월 27일 오전 9:22<br><br><br><br><br>정수를 저장하는 큐를&nbsp;구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.<br>명령은 총 여섯 가지이다.<br>
<br>push X: 정수 X를 큐에 넣는 연산이다.
<br>pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
<br>size: 큐에 들어있는 정수의 개수를 출력한다.
<br>empty: 큐가&nbsp;비어있으면 1, 아니면 0을 출력한다.
<br>front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
<br>back:&nbsp;큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
<br><br>첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.<br><br>출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.<br><br>15
push 1
push 2
front
back
size
empty
pop
pop
pop
size
empty
pop
push 3
empty
front

복사<br><br>1
2
2
0
1
2
-1
0
1
-1
0
3

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/compro0317" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/compro0317" target="_blank">compro0317</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/deunlee" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/deunlee" target="_blank">deunlee</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/72" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/72" target="_blank">큐</a>
<br><br>
<br>collection.deque 사용해보기
<br><br>import sys
from collections import deque
    
def solution():
    N = int(sys.stdin.readline().rstrip())
    que = deque([])

    while N&gt;0:
        N-=1
        temp = sys.stdin.readline().rstrip()

        if temp[:4] == "push":
            x = int(temp[5:])
            temp = "push"    
        
        try:
            match temp:
                case "push":
                    que.append(x)
                case "pop":
                        print(que.popleft())
                case "size":
                    print(len(que))
                case "empty":
                    if len(que) == 0:
                        print(1)
                    else:
                        print(0)
                case "front":
                    print(que[0])
                case "back":
                    print(que[-1])
        except IndexError:
            print(-1)

if __name__ == "__main__":
    solution()
복사<br>
<br>ㅇ
<br>
<br><br>
<br>collemctions.deque

<br>생성

<br>a = collections.deque([])


<br>이터레이션, 피클링,&nbsp;len(d),&nbsp;reversed(d),&nbsp;copy.copy(d)&nbsp;,copy.deepcopy(d),&nbsp;[in](https://docs.python.org/ko/3/reference/expressions.html#in)&nbsp;연산자를 사용한 멤버십 검사 및 첫 번째 요소를 액세스하는&nbsp;d[0]과 같은 서브 스크립트 참조를 지원합니다. 인덱스를 사용하는 액세스는 양쪽 끝에서는 O(1) 이지만 중간에서는 O(n) 으로 느려집니다. 빠른 무작위 액세스를 위해서는 대신 리스트를 사용하십시오.

  <a data-tooltip-position="top" aria-label="https://docs.python.org/ko/3/library/collections.html#collections.deque" rel="noopener nofollow" class="external-link" href="https://docs.python.org/ko/3/library/collections.html#collections.deque" target="_blank">collections — 컨테이너 데이터형</a><br>

<br>python에 switch-case문이 없는 이유
  <a data-tooltip-position="top" aria-label="https://okeybox.tistory.com/395" rel="noopener nofollow" class="external-link" href="https://okeybox.tistory.com/395" target="_blank">[Python] 파이썬에 switch-case 문이 없는 이유. 그리고 with Python 3.10 match-case</a><br>

<br>lambda
  → 매개변수 : 표현식
  다음은 두 수를 더하는 함수입니다.
&gt;&gt;&gt;defhap(x, y):
...return x + y
...
&gt;&gt;&gt; hap(10, 20)
30

복사
  이것을 람다 형식으로는 어떻게 표현할까요?
&gt;&gt;&gt; (lambda x,y: x + y)(10, 20)
30
복사
  <a data-tooltip-position="top" aria-label="https://wikidocs.net/64" rel="noopener nofollow" class="external-link" href="https://wikidocs.net/64" target="_blank">3.5 람다(lambda)</a>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/큐.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/큐.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[코테 질문 모음]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener nofollow">#코딩테스트</a><br>
<br><br><br>
<br>
종류를 무한으로 쓸 수 있는 건 쉬운데, 종류별로 갯수가 정해져있는 건 까다로움…

<br>
일전에 실패했던 배낭문제(<a data-href="12865. 평범한 배낭" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/12865.-평범한-배낭.html" class="internal-link" target="_self" rel="noopener nofollow">12865. 평범한 배낭</a>)와 이문제 (<a data-href="11047. 동전 0" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/11047.-동전-0.html" class="internal-link" target="_self" rel="noopener nofollow">11047. 동전 0</a>) 그리고 동전이 배수가 아닌 경우의 차이가 뭘까.

<br>
내생각

<br>


<br>
<br>동전문제 싹 풀어보자…
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/코테-질문-모음.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/코테 질문 모음.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:29:06 GMT</pubDate></item><item><title><![CDATA[체스판 다시 칠하기]]></title><description><![CDATA[ 
 <br><br>ID: 1018<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1018" target="_blank">https://www.acmicpc.net/problem/1018</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 브루트포스 알고리즘<br>
생성 일시: 2023년 4월 14일 오후 9:25<br><br>다시 풀 때  참고: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/source/54384536" target="_blank">https://www.acmicpc.net/source/54384536</a> (시간 줄이기)<br><br><br><br>지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.<br>체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.<br>보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.<br><br>첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.<br><br>8 8
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBBBWBW
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBWBWBW

복사<br><br>1

복사<br><br>10 13
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
WWWWWWWWWWBWB
WWWWWWWWWWBWB

복사<br><br>12

복사<br><br>8 8
BWBWBWBW
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBWBWBW
WBWBWBWB

복사<br><br>0

복사<br><br>9 23
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBW

복사<br><br>31

복사<br><br>10 10
BBBBBBBBBB
BBWBWBWBWB
BWBWBWBWBB
BBWBWBWBWB
BWBWBWBWBB
BBWBWBWBWB
BWBWBWBWBB
BBWBWBWBWB
BWBWBWBWBB
BBBBBBBBBB

복사<br><br>0

복사<br><br>8 8
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBBBWBW
WBWBWBWB
BWBWBWBW
WBWBWWWB
BWBWBWBW

복사<br><br>2

복사<br><br>11 12
BWWBWWBWWBWW
BWWBWBBWWBWW
WBWWBWBBWWBW
BWWBWBBWWBWW
WBWWBWBBWWBW
BWWBWBBWWBWW
WBWWBWBBWWBW
BWWBWBWWWBWW
WBWWBWBBWWBW
BWWBWBBWWBWW
WBWWBWBBWWBW

복사<br><br>15

복사<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br>문제를 다시 작성한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>
<br>
짝수줄 홀수줄 나눠서 생각 가능…

<br>
같은 수가 작은 홀수번 나오는 게 좋음…?

<br>
2,2,4,4인 경우도 있잖아…

<br>
홀수번 검사 짝수번 검사…

<br>
검사 반복 횟수는, m-8, n-8 2번 b시작 w시작

<br>
새 행렬 2개 하나만 들어서, 여기서 무슨 색으로 시작했을때, 얼마 칠해야하는 지 저장.

<br>
<br>input받아서 list 생성
<br>N-7, M-7 의 2중 반복문 생성
<br>0(M-7) 반복문에서, 0~7(N-7)까지
<br>1(M-7) 반복문에서 0~7(N-7)까지…?
<br>앞부분 도움: <a rel="noopener nofollow" class="external-link" href="https://ittrue.tistory.com/60" target="_blank">https://ittrue.tistory.com/60</a><br>
<br>row index + col index를 합친값을 %2 하면, 번갈아가면서 나오는 체스판 식의 값을 얻을 수 있음…
<br>W로 시작과 B로 시작은 저로 정반대이기 때문에, 하나만 검색하고, 칠해야할 min, max값만 저장해두고, 64-max 해서 둘 중에 min값을 구하면 됨.
<br>import sys

def solution():
    N,M = map(int, sys.stdin.readline().rstrip().split(" "))
    lst = []
    minimum = 64
    maximum = 0

    for i in range(N):
        row = sys.stdin.readline().rstrip()
        lst.append(row)

    for row in range(N-7):
        for col in range(M-7):
            now = 0

            for i in range(row,row+8):               
                for j in range(col,col+8):
                    if (i+j)%2:
                        label = "W"
                    else:
                        label = "B"
                    
                    if lst[i][j] != label:
                         now += 1
            
            if now &lt; minimum:
                minimum = now
            if now &gt; maximum:
                maximum = now
    
    print(min(minimum, (64-maximum)))

if __name__ == "__main__":
    solution()
복사<br><br>
<br>정 안 되면, for문은 4개씩이나 겹쳐도 됨….
<br>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/체스판-다시-칠하기.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/체스판 다시 칠하기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[카드2]]></title><description><![CDATA[ 
 <br><br>ID: 2164<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2164" target="_blank">https://www.acmicpc.net/problem/2164</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 자료구조, 큐<br>
생성 일시: 2023년 4월 20일 오후 4:58<br><br>n,m = int(input()), 1
while m&lt;n: # O(logn)
    m *= 2
print(2*n-m)
복사<br>내가 못하다 만 거 같은데, 제대로 이해해보기.<br><br><br><br>N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.<br>이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.<br>예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.<br>N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.<br><br>첫째 줄에 남게 되는 카드의 번호를 출력한다.<br><br>6

복사<br><br>4

복사<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/72" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/72" target="_blank">큐</a>
<br><br>
<br>그냥 queue 써서 문제에 나온대로 쭉 쓰면 쉽게 풀려서 왜이렇게 쉽지? 했는데…
<br><br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())
    queue = [i+1 for i in range(N)]
    while len(queue) &gt; 1:
        queue.pop(0)
        card = queue.pop(0)
        queue.append(card)
        N -= 1
    print(queue[0])

if __name__ == "__main__":
    solution()
복사<br>
<br>
pop이 많이 걸리나?

<br>
연산을 합칠 방법을 찾아봐야겠다…

<br>
첫 턴에 홀수만 빠지고

<br>
마지막이 짝수였으면 또다시 이전 start 바로 다음 수,

<br>
마지막이 홀수였으면 또다시 이전 start 다음다음다음 수...?

<br>
그러면 돌때마다 1/2씩 줄어드니까. logn

<br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())

    end = N
    start = 1
    spare = 0

    # 첫 turn 끝난 카드 list
    queue = [2*i for i in range(N//2)]

    while len(queue) &gt; 0:

        if end % 2 == 0:
            start += 
        else:
            spare = start+1
            start += 2
        end = start + len(queue) - 1

        queue = [for i in range(start, end+1)]

if __name__ == "__main__":
    solution()ㅇ
복사<br>
<br>
어려워서 pass

<br>
pop 시간복잡도가 많이 걸린다고 해서. pop을 쓰지 않기로 함.

<br>
메모리는 많이 쓰겠지만, 그냥 계솔 추가하고 pointer를 옮겨가는 방식으로

<br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())
    queue = [i+1 for i in range(N)]
    point = 0
    while N &gt; 1:
        queue[point] = 0
        card = queue[point + 1]
        queue.append(card)
        N -= 1
        point += 2
    print(queue[point])

if __name__ == "__main__":
    solution()
복사<br>
<br>근데 생각해보면 첫턴에 홀수 빼고 시작하는 것 정도는 추가할 수 있을 것같아서. 시도.
<br>어려웠던건, N이 짝수냐 홀수냐에 따라서 시작 숫자가 달라지는데 그거 생각하는 게 어려웠음. 5랑 4로 예시들어가면서 했다ㅋㅋㅋ
<br>N 값 조정해주는 걸 생각했어야했는데, 잊고 있어서 시행착오 몇번
<br><br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())
    queue = [2*(i+1) for i in range(N//2)]
    point = 0
    
    if N%2 == 1:
        card = queue[point]
        queue.append(card)
        point = 1

    N //= 2 
    while N &gt; 1:
        card = queue[point + 1]
        queue.append(card)
        N -= 1
        point += 2
    print(queue[point])

if __name__ == "__main__":
    solution
복사<br>
<br>ㅇ
<br>인덱스 에러가, if N%2부분에서 나더라
<br>생각해보니 N이 1이면, N//2는 0이되는데 그러면 []가 만들어지고,  queue[0(=point)]의 값은 없음…
<br>그래서 이부분만 뗴어내서 print(1)해주는 걸로 처리함.
<br><br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())
    queue = [2*(i+1) for i in range(N//2)]
    point = 0
    
    if N == 1:
        return 1

    if N%2 == 1:
        card = queue[point]
        queue.append(card)
        point = 1

    N //= 2 
    while N &gt; 1:
        card = queue[point + 1]
        queue.append(card)
        N -= 1
        point += 2
    return queue[point]

if __name__ == "__main__":
    print(solution())
복사<br><br>
<br>pop은 변수를 빼고 한칸씩 옮기기 때문에 O(n)의 시간복잡도가 걸림. → 대신 collections 모듈의 deque을 사용하여 popleft()메소드를 사용하는 걸 추천함
<br>앞으로는 증명법 이용해서 풀어보는 것도 좋을것 같다… 이산구조 열심히 해야지.
<br>입력으로 1 이상 1,000,000 이하의 정수 N이 주어진다면 N=1, N=2 등의 최소 케이스가 잘 나오는지 확인하는 것이 좋습니다.
<br>N=1,000,000 같은 최대 케이스를 넣었을 때 주어진 시간 제한 안에 답이 나오는지도 확인해 볼 수 있습니다.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/카드2.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/카드2.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[집합]]></title><description><![CDATA[ 
 <br><br>ID: 11723<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/11723" target="_blank">https://www.acmicpc.net/problem/11723</a><br>
난이도: 실버 5<br>
다시풀기: Yes<br>
분류: 구현, 비트마스킹<br>
생성 일시: 2023년 4월 20일 오전 11:06<br><br>비트마스킹으로 다시 풀어보기.<br><br><br><br>비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.<br>
<br>add x: S에 x를 추가한다. (1&nbsp;≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.
<br>remove&nbsp;x: S에서 x를 제거한다. (1&nbsp;≤ x ≤ 20)&nbsp;S에 x가 없는 경우에는 연산을 무시한다.
<br>check x: S에 x가 있으면 1을, 없으면 0을 출력한다.&nbsp;(1 ≤ x ≤ 20)
<br>toggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1&nbsp;≤ x ≤ 20)
<br>all: S를 {1, 2, ..., 20} 으로 바꾼다.
<br>empty: S를 공집합으로 바꾼다.
<br><br>첫째 줄에 수행해야 하는 연산의 수 M (1 ≤ M ≤ 3,000,000)이 주어진다.<br>둘째 줄부터 M개의 줄에 수행해야 하는 연산이 한 줄에 하나씩 주어진다.<br><br>check&nbsp;연산이 주어질때마다, 결과를 출력한다.<br><br>26
add 1
add 2
check 1
check 2
check 3
remove 2
check 1
check 2
toggle 3
check 1
check 2
check 3
check 4
all
check 10
check 20
toggle 10
remove 20
check 10
check 20
empty
check 1
toggle 1
check 1
toggle 1
check 1

복사<br><br>1
1
0
1
0
1
0
1
0
1
1
0
0
0
1
0

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/houma757" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/houma757" target="_blank">houma757</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/pichulia" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/pichulia" target="_blank">pichulia</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/14" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/14" target="_blank">비트마스킹</a>
<br><br>
<br>Java 8: 448 MB
<br>Java 8 (OpenJDK): 448 MB
<br>Java 11: 448 MB
<br>Kotlin (JVM): 448 MB
<br>C#: 64 MB
<br>Java 15: 448 MB
<br>F#: 64 MB
<br>Visual Basic: 64 MB
<br><br>복사<br><br>
<br>비트마스킹
  <a data-tooltip-position="top" aria-label="https://travelbeeee.tistory.com/451" rel="noopener nofollow" class="external-link" href="https://travelbeeee.tistory.com/451" target="_blank">[알고리즘] 비트마스킹(bitmasking) 이란</a>

<br>not 0, not 1하면 true false나


<br>파이썬은 왜 느릴까.
  <a data-tooltip-position="top" aria-label="https://y-joo.tistory.com/12" rel="noopener nofollow" class="external-link" href="https://y-joo.tistory.com/12" target="_blank">파이썬은 왜 느릴까? ( + 시간초과를 해결할 수 있는 몇몇 기술들)</a>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/집합.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/집합.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[좌표 정렬]]></title><description><![CDATA[ 
 <br><br>ID: 11650<br>
Site: 백준<br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 정렬<br>
생성 일시: 2023년 4월 12일 오후 8:34<br><br><br><br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    
    lst = []

    while N&gt;0:
        N-=1
        x, y = map(int, sys.stdin.readline().split())
        lst.append((x,y))
    
    lst.sort()
    for i in range(len(lst)):
        lst[i] = str(lst[i][0])+" "+str(lst[i][1])
    
    print("\n".join(lst))

if __name__ == "__main__":
    solution()
복사<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/좌표-정렬.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/좌표 정렬.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[제목 없음]]></title><description><![CDATA[ 
 <br><br>다시풀기: No<br>
생성 일시: 2023년 3월 10일 오후 4:36<br>### 실패
def converting(cap, list):
    sum = 0
    flag = 0
    flaglist = []
    
    for i in range(len(list)-1, -1, -1):
        sum += list[i]
        
        if sum &gt; flag:
            flag += cap
            flaglist.append(i+1)
            
            
    return flaglist
        

def compare(list1, list2, len):
    result_list = []
    for i in range(len):
        result_list.append(max(list1[i], list2[i]))
    return result_list
    

def solution(cap, n, deliveries, pickups):
    
    d_flag = converting(cap, deliveries)
    p_flag = converting(cap, pickups)
    flag = []
    
    print(d_flag, p_flag)
    
    d_len = len(d_flag)
    p_len = len(p_flag)
    
    if d_len == p_len:
        flag = compare(d_flag, p_flag, d_len)
    elif d_len &gt; p_len:
        alone = d_len - p_len
        d_alone = d_flag[:-alone]
        flag = compare(d_alone, p_flag, p_len) + d_flag[:alone]
    else:
        alone = p_len - d_len
        p_alone = -p_flag[:-alone]
        flag = compare(p_alone, d_flag, d_len) + p_flag[:alone]
        
        
        
    
    answer = sum(flag)*2
    return answer
복사<br>
<br>flag를 2번 이상 씩 뛰어넘는 경우가 있으니까…
<br>### 성
def truck(lst, cap, home):
    result = []
    box_sum = 0
    pin = 0
    turn = 0
    
    while home &gt; 0:
        if box_sum &lt; pin + 1 &lt;= box_sum + lst[home-1]:
            result.append(home)
            pin += cap
            # print('pin', pin)
        else:
            box_sum += lst[home-1]
            home -= 1
            turn += 1
            # print('home', home)
    
    return result

def compare(max_list, min_list):
    result = 0
    max_len = len(max_list)
    min_len = len(min_list)
    
    for i in range(max_len):
        if i == min_len -1:
            result += sum(max_list[min_len-1:])
            break
        result += max(max_list[i], min_list[i])
    
    return result
 
    
def solution(cap, n, deliveries, pickups):
    d_list = truck(deliveries, cap, n)
    p_list = truck(pickups, cap, n)
    

    if len(d_list) &gt;= len(p_list):
        answer = compare(d_list, p_list)
    else:
        answer = compare(p_list, d_list)

    return answer*2
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/제목-없음.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/제목 없음.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[요세푸스 문제]]></title><description><![CDATA[ 
 <br><br>ID: 1158<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1158" target="_blank">https://www.acmicpc.net/problem/1158</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 구현, 자료구조, 큐<br>
생성 일시: 2023년 5월 2일 오후 9:26<br><br><br><br><br>요세푸스 문제는 다음과 같다.<br>1번부터 N번까지 N명의 사람이 원을 이루면서&nbsp;앉아있고, 양의 정수 K(≤ N)가&nbsp;주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &lt;3, 6, 2, 7, 5, 1, 4&gt;이다.<br>N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)<br><br>예제와 같이 요세푸스 순열을 출력한다.<br><br>7 3

복사<br><br>&lt;3, 6, 2, 7, 5, 1, 4&gt;

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author5" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/author5" target="_blank">author5</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/72" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/72" target="_blank">큐</a>
<br><br>
<br>비슷한 문제 푼 기억이 있는데,,,
<br>deque를 쓸지 그냥 list로 구현할지…
<br>둘다 한번 해보자
<br>
<br>list로 구현
<br>
<br>엥. 잠시만 list를 쓸 필요도 없는데?
<br><br>import sys, collections

def solution():
    N, K = map(int, sys.stdin.readline().rstrip().split())

    i = K
    que = collections.deque([x for x in range(1, N+1)])
    result_que = collections.deque([])
    while len(que) &gt; 0:
        que.append(que.popleft())
        que.append(que.popleft())
        result_que.append(str(que.popleft()))
    
    print("&lt;" + ", ".join(result_que) + "&gt;")

if __name__ == "__main__":
    solution()
복사<br>
<br>예제만 적용가능하게 만들어 놨음. K입력값에 따라 변하게 만들어야함.
<br><br>import sys, collections

def solution():
    N, K = map(int, sys.stdin.readline().rstrip().split())

    que = collections.deque([x for x in range(1, N+1)])
    result_que = collections.deque([])
    while len(que) &gt; 0:
        for _ in range(K-1):
            que.append(que.popleft())
        result_que.append(str(que.popleft()))
    
    print("&lt;" + ", ".join(result_que) + "&gt;")

if __name__ == "__main__":
    solution()
복사<br>
<br>
만약 N=K면, 시간 복잡도는 O(N^2)

<br>
marge sort를 가져다 써볼까?

<br>나누고 합치고 나누고 합치고의 반복
<br>7 3일 경우

<br>12(3) 45(6) 7로 나누고
<br>71245이됨



import sys

def marge_pop(lst, i, cnt, r):
    
    result = []
    for _ in range(cnt):
        result += lst[:i-1]
        r.append(str(lst[i-1]))
        lst = lst[i:]
        
    if len(lst)&gt;0:
        result = lst + result
    
    return result,r

def solution():
    N, K = map(int, sys.stdin.readline().rstrip().split())

    lst = [x for x in range(1,N+1)]
    result = []

    while len(lst) &gt; 0:
        cnt =  len(lst) // K
        lst, result = marge_pop(lst, K, cnt, result)
    
    print("&lt;"+", ".join(result)+"&gt;")

if __name__ == "__main__":
    solution()
복사

<br>마지막에 남겨지는 애들을 print할 방도가 없

import sys

def marge_pop(lst, i, cnt, r):
    
    result = []
    
    if cnt == 0:
        i = i%len(lst)
        cnt = 1
    
    for _ in range(cnt):
        result += lst[:i-1]
        r.append(str(lst[i-1]))
        lst = lst[i:]
        
    if len(lst)&gt;0:
        result = lst + result
    
    return result,r

def solution():
    N, K = map(int, sys.stdin.readline().rstrip().split())

    lst = [x for x in range(1,N+1)]
    result = []

    while len(lst) &gt; 0:
        cnt =  len(lst) // K
        lst, result = marge_pop(lst, K, cnt, result)
    
    print("&lt;"+", ".join(result)+"&gt;")

if __name__ == "__main__":
    solution()
복사

<br>해보긴 했는데 2개 남았을때 까지는 어케 됐는데, 이제는 안됨.
<br>예제 몇개  더 생성
10 9
&lt;9, 8, 10, 2, 5, 3, 4, 1, 6, 7&gt;

10 1
&lt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;

15 7
&lt;7, 14, 6, 15, 9, 3, 13, 11, 10, 12, 2, 8, 1, 4, 5&gt;

15 4
&lt;4, 8, 12, 1, 6, 11, 2, 9, 15, 10, 5, 3, 7, 14, 13&gt;

15 3
&lt;3, 6, 9, 12, 15, 4, 8, 13, 2, 10, 1, 11, 7, 14, 5&gt;
복사



<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/요세푸스-문제.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/요세푸스 문제.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[영화감독 숌]]></title><description><![CDATA[ 
 <br><br>ID: 1436<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1436" target="_blank">https://www.acmicpc.net/problem/1436</a><br>
난이도: 실버 5<br>
다시풀기: Yes<br>
분류: 브루트포스 알고리즘<br>
생성 일시: 2023년 4월 11일 오후 2:21<br><br>“brute-force말고 최적화 해서 풀어보기”<br><br><br>666은 종말을 나타내는 수라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다. 하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.<br>종말의 수란 어떤 수에 6이 적어도 3개 이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 수는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 이다. 따라서, 숌은 첫 번째 영화의 제목은 "세상의 종말 666", 두 번째 영화의 제목은 "세상의 종말 1666"와 같이 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 수) 와 같다.<br>숌이 만든 N번째 영화의 제목에 들어간 수를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.<br><br>첫째 줄에 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.<br><br>첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.<br><br>2
복사<br><br>1666
복사<br><br>3
복사<br><br>2666
복사<br><br>6

복사<br><br>5666

복사<br><br>187

복사<br><br>66666

복사<br><br>500

복사<br><br>166699

복사<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/mwy3055" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/mwy3055" target="_blank">mwy3055</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>
<br>666을 숫자 6으로 치환해서,,,?
<br>그러면 진짜 그냥 6인데 그것도 666으로 변환시킬 우려가 생김.
<br>써보자

<br>0,1,2,3,4,5 (+) 666
<br>666 (+) 0,1,2,3,4,5
<br>6666
<br>7,8,9 (+) 666


<br>special 6
<br>
<br>6` == 666
<br>16` == 1000 +666 = 666+(n-1)*1000
<br>26` == 2000 + 666 = 666+(n-1)*1000
<br>36` == 3000 + 666 = 666+(n-1)*1000
<br>46` == 4000 + 666 = 666+(n-1)*1000
<br>56`== 5000 + 666 = 666+(n-1)*1000

<br>0≤(n-7)≤9


<br>6`0 == 66610 = 66610 + n-7
<br>6`1  == 66610 +1 = 66610 + n-7
<br>6`2  == 66610 +2 = 66610 + n-7
<br>6`3 == 66610+3 = 66610 + n-7
<br>6`4 == 66610+4 = 66610 + n-7
<br>6`5 == 66610+5 = 66610 + n-7
<br>6`6  == 66610+6 = 66610 + n-7
<br>6`7 == 66610+7 = 66610 + n-7
<br>6`8 == 66610+8 = 66610 + n-7
<br>6`9 == 66610+9 = 66610 + n-7
<br>106` == 10000 + 666
<br>116` == 11000 + 666
<br>126` == 12000 + 666
<br>136` == 13000 + 666
<br>146` == 14000 + 666
<br>156` == 15000 + 666
<br>16`0 == 666*10 + 10000
<br>16`1 == 666*10 + 10001
<br>16`2 == 666*10 + 10002
<br>16`3 == 666*10 + 10003
<br>
<br>6을 하나만 6으로 부풀리는 식으로 해보자.
<br>
<br>6` == 6
<br>16` == 10+6
<br>26` == 10
<br>36` == 3000 + 666 = 666+(n-1)*1000
<br>46` == 4000 + 666 = 666+(n-1)*1000
<br>56`== 5000 + 666 = 666+(n-1)*1000

<br>0≤(n-7)≤9


<br>6`0 == 66610 = 66610 + n-7
<br>6`1  == 66610 +1 = 66610 + n-7
<br>6`2  == 66610 +2 = 66610 + n-7
<br>6`3 == 66610+3 = 66610 + n-7
<br>6`4 == 66610+4 = 66610 + n-7
<br>6`5 == 66610+5 = 66610 + n-7
<br>6`6  == 66610+6 = 66610 + n-7
<br>6`7 == 66610+7 = 66610 + n-7
<br>6`8 == 66610+8 = 66610 + n-7
<br>6`9 == 66610+9 = 66610 + n-7
<br>106` == 10000 + 666
<br>116` == 11000 + 666
<br>126` == 12000 + 666
<br>136` == 13000 + 666
<br>146` == 14000 + 666
<br>156` == 15000 + 666
<br>16`0 == 666*10 + 10000
<br>16`1 == 666*10 + 10001
<br>16`2 == 666*10 + 10002
<br>16`3 == 666*10 + 10003
<br>
<br>6빼고 생각해보자
<br>
<br>

<br>

<br>666




<br>1- + 666
<br>2- + 666
<br>3- + 666
<br>4- + 666
<br>5- + 666
<br>

<br>

<br>666*10




<br>-1 + 666*10
<br>-2 + 666*10
<br>-3 + 666*10
<br>-4 + 666*10
<br>-5 + 666*10
<br>-6 + 666*10
<br>-7 + 666*10
<br>-8 + 666*10
<br>-9 + 666*10
<br>7-
<br>8-
<br>9-

<br>


<br>10-
<br>11-
<br>12-
<br>13-
<br>14-
<br>15-
<br>1-0
<br>1-1
<br>1-2
<br>1-3
<br>1-4
<br>1-5
<br>1-6
<br>1-7
<br>1-8
<br>1-9
<br>17-
<br>18-
<br>19-
<br>20-
<br>→ 16 진수 식으로<br>
<br>아님 재귀함수… 앞의 값 뒤의값?
<br>6을만나면 퍼진다…?

<br>01,2,3,4,5,(6→ 0123456789, 7,8,9
<br>10,11,12,13,14,15,1(6→0,1,2,3,4,5,6,7,8,9) 7,8,9
<br>20
<br>30
<br>40
<br>50
<br>60,61,62,63,64,65,(→00, 01,02,03,04,05,06,07,08,09)


<br><br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    num = 0
    cnt = 0

    while True:
        num += 1
        if '666' in str(num):
           cnt += 1
        if cnt == N:
            break

    print(num)

if __name__ == "__main__":
    solution()
복사<br>
<br>결국 brute-force로 품…
<br>근데 최적화를 해야한다면?
<br>공식을 찾고 싶었는데 그러지 못해서 질문계시판의 도움을 받기로 했다.
<br>1. 1이상 10^18미만의 정수 중에 문자열에 12가 포함된 수의 개수를 구하시오.

2. 1이상 10^18미만의 정수 중에 '종말의 수'의 개수를 구하시오.

--------------------------------------

먼저 위 두 문제를 풀어보시기 바랍니다.

***

앞에 6이 추가되기 전에는 종말의 수가 아니었는데 추가돼서 새롭게 종말의 수가 된 종말의 수를 생각해보죠.
복사<br>
<br>(1≤N&lt;10**18)
<br>
<br>
k자리수에서 12포함

<br>1 자리수일때 0개
<br>2의 자리수일때 1개
<br>3의 자리수일때 9+10개
<br>4의 자리수일때 910(# __12)+910(# 12) + 10*10(# 12__)개
<br>5의 자리수일때 91010 + 91010 + 91010

⇒ 12의 자리를 구하는 경우의 수 → k_C_2
⇒ 나머지 빈 자리를 채우는 경우의 수 → 9*10(k-3) or 10(k-2)

<br><br>
<br>
<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/영화감독-숌.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/영화감독 숌.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[숫자 카드 2]]></title><description><![CDATA[ 
 <br><br>ID: 10816<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/10816" target="_blank">https://www.acmicpc.net/problem/10816</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 이분탐색, 자료구조, 정렬, 해시를 사용한 집합과 맵<br>
생성 일시: 2023년 4월 20일 오후 9:23<br><br><br><br><br>숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이&nbsp;주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.<br>셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.<br><br>첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.<br><br>10
6 3 2 10 10 10 -10 -10 7 3
8
10 9 -5 2 3 4 5 -10

복사<br><br>3 0 0 1 2 0 0 2

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cko301" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/cko301" target="_blank">cko301</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/mwy3055" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/mwy3055" target="_blank">mwy3055</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/wkd48632" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/wkd48632" target="_blank">wkd48632</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/emppu" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/emppu" target="_blank">emppu</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/12" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/12" target="_blank">이분 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/136" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/136" target="_blank">해시를 사용한 집합과 맵</a>
<br><br>
<br>max 값을 찾아서, 나머지를 index로 하면, list 크기 줄일 수 있어서 좋은데,,,
<br>이게, 음수가 있어서 헷갈리네.
<br>그러면 나머지 구하고 양수에는 +max 한 index에 저장하기로 하자.
<br>그런데 결과 담긴 list를 한바퀴 돌리는게 아니라, 그냥 접근하는 거니까. 굳이 크기를 줄일 필요 없지 않나?
<br>
<br>import sys

def solution():
    lst = [0]*20000000
    N = int(sys.stdin.readline().rstrip())
    N_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    M = int(sys.stdin.readline().rstrip())
    M_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    i,j = 0,0
    result = []
    
    while i &lt; N:
        num = N_lst[i]
        lst[num+10000000-1] += 1
        i+=1
    

    while j &lt; M:
        num = M_lst[j]
        result.append(str(lst[num+10000000-1]))
        j+=1

    print(" ".join(result))

if __name__ == "__main__":
    solution()
복사<br>
<br>시간 너무 많이 걸리는듯 합니다…
<br>한번에 받겠다, max min 찾아서 하지 뭐.
<br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    N_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    M = int(sys.stdin.readline().rstrip())
    M_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    i,j = 0,0
    result = []
    maximum = max(N_lst)
    minimum = min(N_lst)
    length = maximum - minimum
    lst = [0]*length
    plus = length//2

    while i &lt; N:
        num = N_lst[i]
        lst[num+plus-1] += 1
        i+=1
    

    while j &lt; M:
        num = M_lst[j]
        result.append(str(lst[num+plus-1]))
        j+=1

    print(" ".join(result))

if __name__ == "__main__":
    solution()
복사<br>ㅇ<br>
<br>신기하게 이러니까 양끝 값이 이상해졌어…! 짱신기… 왜지?
<br>생각해보니까, 반으로 하면, index가 음수인 경우가 생겨서 이상해지겠다…
<br>rㅡ리고 length는 항상 +1 해주기
<br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    N_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    M = int(sys.stdin.readline().rstrip())
    M_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    i,j = 0,0
    result = []
    maximum = max(N_lst)**2
    minimum = min(N_lst)**2
    half = int(max(maximum,minimum)**1/2)
    length = half * 2 + 1
    lst = [0]*length

    while i &lt; N:
        num = N_lst[i]
        lst[num+half-1] += 1
        i+=1
    

    while j &lt; M:
        num = M_lst[j]
        result.append(str(lst[num+half-1]))
        j+=1

    print(" ".join(result))

if __name__ == "__main__":
    solution()뮤ㅇ

복사<br>
<br>ㅇ
<br>abs로 안하려고 제곱했더니, 메모리 초과ㅋㅋㅋㅋㅋ
<br><br>
<br>join 할거면 str으로 저장해줘야된다고!!!!!!
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/숫자-카드-2.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/숫자 카드 2.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[요세푸스 문제 0]]></title><description><![CDATA[ 
 <br><br>ID: 11866<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/11866" target="_blank">https://www.acmicpc.net/problem/11866</a><br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 구현, 자료구조, 큐<br>
생성 일시: 2023년 4월 13일 오후 4:24<br><br><br><br><br>요세푸스 문제는 다음과 같다.<br>1번부터 N번까지 N명의 사람이 원을 이루면서&nbsp;앉아있고, 양의 정수 K(≤ N)가&nbsp;주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &lt;3, 6, 2, 7, 5, 1, 4&gt;이다.<br>N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N과 K가&nbsp;빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 1,000)<br><br>예제와 같이 요세푸스 순열을 출력한다.<br><br>
## 예제 출력 1

복사<br>&lt;3, 6, 2, 7, 5, 1, 4&gt;<br>
## 출처

- 문제를 만든 사람:&nbsp;[baekjoon](https://www.acmicpc.net/user/baekjoon)

## 알고리즘 분류

- [구현](https://www.acmicpc.net/problem/tag/102)
- [자료 구조](https://www.acmicpc.net/problem/tag/175)
- [큐](https://www.acmicpc.net/problem/tag/72)

## Before: 생각

- 이게 대체 왜 큐인가… 하는 생각에 linked list에 더 집중해버림…
    - linking을 interval간격으로 하려니 너무 복잡하더라…
    - 뺐다 넣고를 반복하면(print하는 건 삭제한채로 계속 새로 집어넣음.) 그러며는 따로 index 계산할 필요 없이 그냥 interval만큼 더해주면 됨.

```python
import sys

def solution():
    N, flag = map(int, sys.stdin.readline().rstrip().split())

    lst = [x for x in range(1, N+1)]
    length = N
    cnt = 0
    result ="&lt;"

    while length &gt;0:
        if cnt == flag-1:
            result += str(lst.pop(0)) + ", "
            cnt = 0
            length -= 1
        else:
            x = lst.pop(0)
            lst.append(x)
            cnt += 1

    print(result[:-2] +"&gt;")

if __name__ == "__main__":
    solution()
복사<br>
<br>나는 120초인데,,,, 32초까지 줄일 수 있음…

<br>여기는 계속 추가하는 방식이 아님.
<br>index는 interval - 1만큼씩 커짐. 왜냐면 pop으로 항상 지워주니까
<br>index가 길이보다 클 때, 현재 길이로 나눈 나머지로 바꿔줌


<br>import sys

def solution():
    N, gap = map(int, sys.stdin.readline().rstrip().split())

    lst = [x for x in range(1, N+1)]
    idx = gap-1
    result ="&lt;"

    while lst:
        if idx &gt;= len(lst):
            idx %= len(lst)
        result += str(lst.pop(idx))+", "
        idx += gap-1

    print(result[:-2] +"&gt;")

if __name__ == "__main__":
    solution()
복사<br><br>
<br>
que

<br>FIFO
<br>stack과 반
<br>환형 큐[<a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/w/index.php?title=%ED%81%90_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)&amp;action=edit&amp;section=4" rel="noopener nofollow" class="external-link" href="https://ko.wikipedia.org/w/index.php?title=%ED%81%90_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)&amp;action=edit&amp;section=4" target="_blank">편집</a>]
  선형 큐의 문제점(배열로 큐를 선언할시 큐의 삭제와 생성이 계속 일어났을때, 마지막 배열에 도달후 실제로는 데이터공간이 남아있지만 오버플로우가 발생)을 보완한 것이 환형 큐이다. front가 큐의 끝에 닿으면 큐의 맨 앞으로 자료를 보내어 원형으로 연결 하는 방식이다.원형 큐라고도 한다.<br>



<br>
while [list] → list가 다 빌 때 까지 loop 돌림.

<br>
pop이나 remove 잊지말기. 왜 값을 0으로 만드는 것밖에 생각을 못했을까?

<br>
print(a,b,c, sep = ”;”) → abc를 공백으로 나누는 대신, ;로 나눠줌.

]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/요세푸스-문제-0.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/요세푸스 문제 0.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 13:15:14 GMT</pubDate></item><item><title><![CDATA[수들의 합2]]></title><description><![CDATA[ 
 <br><br>ID: 2003<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2003" target="_blank">https://www.acmicpc.net/problem/2003</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 누적 합, 두 포인터, 브루트포스 알고리즘<br>
생성 일시: 2023년 8월 5일 오전 3:09<br><br><br><br><br>N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i] + A[i+1] + … + A[j-1] + A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N(1 ≤ N ≤ 10,000), M(1 ≤ M ≤ 300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.<br><br>첫째 줄에 경우의 수를 출력한다.<br><br>4 2
1 1 1 1

복사<br><br>3

복사<br><br>10 5
1 2 3 4 2 5 3 1 1 2

복사<br><br>3

복사<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/isku" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/isku" target="_blank">isku</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/vvipconcert" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/vvipconcert" target="_blank">vvipconcert</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/139" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/139" target="_blank">누적 합</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/80" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/80" target="_blank">두 포인터</a>
<br><br>
<br>test_cast list를 두고 adding case를 다 저장하면서 진행
<br>새 숫자가 나오면 그 숫자가 i가 되는 case를 list에 추가(현재 합 0)
<br>존재하는 case에 새 숫자를 다 더함.
<br>M과의 비교를 통해 test case list 처리
<br>import sys

def sum_of_num():
    N, M = map(int, sys.stdin.readline().split())
    sequence = sys.stdin.readline().rstrip().split()
    test_case = []
    result_case = 0

    for num in sequence:
        num = int(num)
        if num &gt; M:
            test_case.clear()
            continue

        test_case.append(0)

        cut = 0
        for idx in reversed(range(len(test_case))):
            test_case[idx] += num
            if test_case[idx] == M:
                result_case += 1
                cut = idx + 1
            elif test_case[idx] &gt; M:
                cut = idx + 1

        test_case = test_case[cut:]

    print(result_case)

if __name__ == "__main__":
    sum_of_num()
복사<br>
<br>
근데 시간 초과…

<br>
그려면 한 숫자에 고정하고서(그러니까 start point를 고정하고서) 찾고, 다음 start point로 넘어가는 식으로..

<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/수들의-합2.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/수들의 합2.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[스위치 켜고 끄기]]></title><description><![CDATA[ 
 <br><br>ID: 1244<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1244" target="_blank">https://www.acmicpc.net/problem/1244</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
생성 일시: 2023년 5월 3일 오전 9:16<br><br><br><br><br>1부터 연속적으로 번호가 붙어있는 스위치들이 있다. 스위치는 켜져 있거나 꺼져있는 상태이다. &lt;그림 1&gt;에 스위치 8개의 상태가 표시되어 있다. ‘1’은 스위치가 켜져 있음을, ‘0’은 꺼져 있음을 나타낸다. 그리고 학생 몇 명을 뽑아서, 학생들에게 1 이상이고 스위치 개수 이하인 자연수를 하나씩 나누어주었다. 학생들은 자신의 성별과 받은 수에 따라 아래와 같은 방식으로 스위치를 조작하게 된다.<br>남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다. &lt;그림 1&gt;과 같은 상태에서 남학생이 3을 받았다면, 이 학생은 &lt;그림 2&gt;와 같이 3번, 6번 스위치의 상태를 바꾼다.<br>여학생은 자기가 받은 수와 같은 번호가 붙은 스위치를 중심으로 좌우가 대칭이면서 가장 많은 스위치를 포함하는 구간을 찾아서, 그 구간에 속한 스위치의 상태를 모두 바꾼다. 이때 구간에 속한 스위치 개수는 항상 홀수가 된다.<br><br>&lt;그림 1&gt;<br>예를 들어 &lt;그림 2&gt;에서 여학생이 3을 받았다면, 3번 스위치를 중심으로 2번, 4번 스위치의 상태가 같고 1번, 5번 스위치의 상태가 같으므로, &lt;그림 3&gt;과 같이 1번부터 5번까지 스위치의 상태를 모두 바꾼다. 만약 &lt;그림 2&gt;에서 여학생이 4를 받았다면, 3번, 5번 스위치의 상태가 서로 다르므로 4번 스위치의 상태만 바꾼다.<br><br>&lt;그림 2&gt;<br><br>&lt;그림 3&gt;<br>입력으로 스위치들의 처음 상태가 주어지고, 각 학생의 성별과 받은 수가 주어진다. 학생들은 입력되는 순서대로 자기의 성별과 받은 수에 따라 스위치의 상태를 바꾸었을 때, 스위치들의 마지막 상태를 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에는 스위치 개수가 주어진다. 스위치 개수는 100 이하인 양의 정수이다. 둘째 줄에는 각 스위치의 상태가 주어진다. 켜져 있으면 1, 꺼져있으면 0이라고 표시하고 사이에 빈칸이 하나씩 있다. 셋째 줄에는 학생수가 주어진다. 학생수는 100 이하인 양의 정수이다. 넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수가 주어진다. 남학생은 1로, 여학생은 2로 표시하고, 학생이 받은 수는 스위치 개수 이하인 양의 정수이다. 학생의 성별과 받은 수 사이에 빈칸이 하나씩 있다.<br><br>스위치의 상태를 1번 스위치에서 시작하여 마지막 스위치까지 한 줄에 20개씩 출력한다. 예를 들어 21번 스위치가 있다면 이 스위치의 상태는 둘째 줄 맨 앞에 출력한다. 켜진 스위치는 1, 꺼진 스위치는 0으로 표시하고, 스위치 상태 사이에 빈칸을 하나씩 둔다.<br><br>8
0 1 0 1 0 0 0 1
2
1 3
2 3

복사<br><br>1 0 0 0 1 1 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/55" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/55" target="_blank">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/78" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/78" target="_blank">KOI 2000</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/391" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/391" target="_blank">초등부</a>&nbsp;2번<br><br>
<br>출력 형식 때문에 6번째에 맞췄다…
<br>import sys

def solution():
    # 입력
    N = int(sys.stdin.readline().rstrip())
    switches = [*map(int, sys.stdin.readline().rstrip().split())]
    people = int(sys.stdin.readline().rstrip())
    cnt = 0

    #연산
    while cnt &lt; people:
        sex, num = map(int, sys.stdin.readline().rstrip().split())
        # 남
        if sex == 1:
            idx = num-1
            while idx &lt; len(switches):
                switches[idx] = switches[idx]*(-1) + 1
                idx += num
        # 여
        elif sex == 2:
            full_length = min(num, N-(num-1))
            idx = num-1
            switches[idx] = switches[idx]*(-1) + 1
            for i in range(1, full_length):
                if switches[idx+i] != switches[idx-i]:
                    break
                switches[idx+i] = switches[idx+i]*(-1) + 1
                switches[idx-i] = switches[idx-i]*(-1) + 1
        cnt +=1
    
    # 출력
    for j in range(0, N, 20):
        print(*switches[j:j+20*(j+1)])
    

if __name__ == "__main__":
    solution()
복사<br><br>
<br>
2) 한 줄의 여러 정수 입력받기 - 리스트로
li = [*map(int,input().split())]
복사

<br>input().split()은 사용자로부터 받은 입력을 공백을 구분자로 나누어 리스트로 바꾸는 기능입니다. 여기에 map함수를 통해, 각 원소를 int형으로 바꿔주게 됩니다. 즉, input().split()이 반환하는 건 리스트이고,&nbsp;map(int, 리스트)를 통해 리스트의 각 원소를 정수로 바꿔주는 것입니다. 앞에&nbsp;*(에스터리크)는&nbsp;unpacking기능으로,&nbsp;[*map객체]를 하면 map객체가 unpacking 되고, []에 의해 리스트화 됩니다. 즉, map에 의해 각 원소가 정수로 바뀐 것을 다시 리스트로 바꿔주는 것입니다
<br>출처: <a rel="noopener nofollow" class="external-link" href="https://bio-info.tistory.com/157" target="_blank">https://bio-info.tistory.com/157</a>


<br>
bitwise 연산
# 비트 연산자(Bitwise Operators)
a = 0b10101010
b = 0b01110011

print('a = ',  a, ":", bin(a))
print('b = ',  b, ":", bin(b))
print('a &amp; b = ',  a &amp; b, ":", bin(a &amp; b))
print('a | b = ',  a | b, ":", bin(a | b))
print('a ^ b = ',  a ^ b, ":", bin(a ^ b))
print('~a = ',  ~a, ":", bin(~a))

a = 0b1
print('a = ', a)
a = a &lt;&lt; 1    # * 2
print('a = ', a)
a = a &lt;&lt; 1    # * 2
print('a = ', a)
a = a &lt;&lt; 3    # * 2**3
print('a = ', a)

a = a &gt;&gt; 1    # / 2
print('a = ', a)
a = a &gt;&gt; 1    # / 2
print('a = ', a)
a = a &gt;&gt; 2    # / 2**2
print('a = ', a)

복사

<br>실행 결과
a =  170 : 0b10101010
b =  115 : 0b1110011
a &amp; b =  34 : 0b100010
a | b =  251 : 0b11111011
a ^ b =  217 : 0b11011001
~a =  -171 : -0b10101011

a =  1
a =  2
a =  4
a =  32

a =  16
a =  8
a = 2
복사



<br>
int()는 버림 연산

<br>
biswise 안 쓰고, 0,1 변환
lst[i]*(-1) + 1
복사

<br>
input으로 int list만들때,
switches = list(map(int, sys.stdin.readline().rstrip().split()))
switches = [*map(int, sys.stdin.readline().rstrip().split())]
복사

<br>둘 중 후자가 더 빠름


<br>
깔끔하게 출력하기

<br>문자열 만들어서 띄어쓰기 넣고 하는 것보다, 그냥 띄어쓰기면 이게 훨씬 깔끔.
<br>특정구간마다 줄바꿈이 필요하면 range step으로 설정해주기.

for j in range(0, len(switches), 20):
        print(*switches[j:j+20*(j+1)])
복사

]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/스위치-켜고-끄기.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/스위치 켜고 끄기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[수 찾기]]></title><description><![CDATA[ 
 <br><br>ID: 1920<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1920" target="_blank">https://www.acmicpc.net/problem/1920</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 이분탐색, 자료구조, 정렬<br>
생성 일시: 2023년 4월 17일 오후 7:36<br><br>binary search 제대로 구현해보<br><br><br><br>N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.<br><br>첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231&nbsp;보다 크거나 같고 231보다 작다.<br><br>M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.<br><br>5
4 1 5 2 3
5
1 3 7 9 5

복사<br><br>1
1
0
0
1

복사<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/BaaaaaaaaaaarkingDog" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/BaaaaaaaaaaarkingDog" target="_blank">BaaaaaaaaaaarkingDog</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/bupjae" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/bupjae" target="_blank">bupjae</a>
<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/tncks0121" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/tncks0121" target="_blank">tncks0121</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/12" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/12" target="_blank">이분 탐색</a>
<br><br>
<br>입력받으면서 정렬.

<br>정수의 범위(-2^31≤ n &lt;2^31)가 정수의 개수(100000)보다 많이 크기때문에, indexing방식으로 list에 삽입 하는 것은 비효율 적이다.
<br>다 받아서 병합정렬하자.


<br>M도 입력 받으면서 정렬
<br>다음 탐색에서는 현재 M보다 큰 N에서부터 탐색시작하면 됨.
<br><br>import sys

def merge_sort(lst):

    if len(lst) == 1:
        return lst
    else:
        mid = (len(lst) // 2)
        a_lst = merge_sort(lst[:mid])
        b_lst = merge_sort(lst[mid:])
        merge_lst = []

        while True:
            if len(a_lst) == 0:
                merge_lst += b_lst
                break
            elif len(b_lst) ==0:
                merge_lst += a_lst
                break
            
            else:
                if a_lst[0] &lt; b_lst[0]:
                    merge_lst.append(a_lst.pop(0))
                else:
                    merge_lst.append(b_lst.pop(0))
        
        return merge_lst

def searching(base, check, M):
    i = 0
    while i != M:
        for j in range(len(base)):
            if check[i] == base[j]:
                base = base[j+1:]
                print(1)
                break
            elif check[i] &lt; base[j]:
                base = base[j-1:]
                print(0)
                break
        if len(base) == 0:
            for i in range(M-i-1):
                print(0)
            break
        i+=1
        

def solution():
    N = int(sys.stdin.readline().rstrip())
    N_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split())))
    M = int(sys.stdin.readline().rstrip())
    M_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split())))

    searching(N_lst, M_lst, M)

if __name__ == "__main__":
    solution()
복사<br>
<br>바보다… 출력하는 순서가… 이게 아니잖아…ㅠ
<br>출력 순서를 정렬해 버림. 그럼 후자를 정렬안하고 하는 방법을 찾아야하는데, 그런 바이너리 서치가 최선이네.
<br><br>import sys

def merge_sort(lst):

    if len(lst) == 1:
        return lst
    else:
        mid = (len(lst) // 2)
        a_lst = merge_sort(lst[:mid])
        b_lst = merge_sort(lst[mid:])
        merge_lst = []

        while True:
            if len(a_lst) == 0:
                merge_lst += b_lst
                break
            elif len(b_lst) ==0:
                merge_lst += a_lst
                break
            
            else:
                if a_lst[0] &lt; b_lst[0]:
                    merge_lst.append(a_lst.pop(0))
                else:
                    merge_lst.append(b_lst.pop(0))
        
        return merge_lst

def searching(base, check):
    start = 0
    end = len(base)-1
    while True:
        mid = start + (end-start)//2

        if end &lt; start:
            print(0)
            break

        if check == base[mid]:
            print(1)
            break        
        elif check &lt; base[mid]:
            end = mid
        else:
            start = mid+1
        

            
def solution():
    N = int(sys.stdin.readline().rstrip())
    N_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split())))
    M = int(sys.stdin.readline().rstrip())
    M_lst = list(map(int, sys.stdin.readline().rstrip().split()))

    for i in M_lst:
        searching(N_lst, i)

if __name__ == "__main__":
    solution()
복사<br>
<br>break point가 잘못된듯 합니다…
<br><br>import sys

def merge_sort(lst):

    if len(lst) == 1:
        return lst
    else:
        mid = (len(lst) // 2)
        a_lst = merge_sort(lst[:mid])
        b_lst = merge_sort(lst[mid:])
        merge_lst = []

        while True:
            if len(a_lst) == 0:
                merge_lst += b_lst
                break
            elif len(b_lst) ==0:
                merge_lst += a_lst
                break
            
            else:
                if a_lst[0] &lt; b_lst[0]:
                    merge_lst.append(a_lst.pop(0))
                else:
                    merge_lst.append(b_lst.pop(0))
        
        return merge_lst

def searching(base, check):
    start = 0
    end = len(base)-1
    while True:
        mid = start + (end-start)//2

        if check == base[mid]:
            print(1)
            break    

        if end &lt;= start:
            print(0)
            break

        if check &lt; base[mid]:
            end = mid
        else:
            start = mid+1
        
            
def solution():
    N = int(sys.stdin.readline().rstrip())
    N_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split())))
    M = int(sys.stdin.readline().rstrip())
    M_lst = list(map(int, sys.stdin.readline().rstrip().split()))

    for i in M_lst:
        searching(N_lst, i)

if __name__ == "__main__":
    solution()
복사<br><br>input()
a = set(input().split())
input()
answer = '\n'.join('1' if x in a else '0' for x in input().split())
print(answer, end='')
복사<br>
<br>그냥 in 써도 돼는거 실화냐?
<br>하….
<br>앞으로는

<br>다 구현
<br>파이썬 기능이용해서 간단하게 구현 

  둘 다 해보자.<br>

<br><br>
<br>입력받는 string list를 바로 int list로 바꾸는 방법
<br>N_lst = list(map(int, sys.stdin.readline().rstrip().split()))
복사<br>
<br>
// : 몫 → 내림

<br>
binary search 할 때

<br>base list를 바꾸는 게 아니라, start, end index로 다뤄줘야해.
<br>end index는 그 끝까지 도달할 경우를 고려해서 len(list)“-1”로 해야함
<br>mid 값은 그냥 나누면 끝이 아니라 그값은 start에 더해줘야해.


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/수-찾기.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/수 찾기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[소수 구하기]]></title><description><![CDATA[ 
 <br><br>ID: 1929<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1929" target="_blank">https://www.acmicpc.net/problem/1929</a><br>
난이도: 실버 3<br>
다시풀기: Yes<br>
분류: 소수 판정, 수학, 에라토스테네스의 체, 정수론<br>
생성 일시: 2023년 4월 27일 오후 12:31<br><br>
<br>홀수리스트는 문제가 생김. → 왜 생기는가.
<br>시간을 줄이는 방법. 지금 입력에 따라 리스트 최대 길이 제한을 두는 것까지함
<br><br><br><br>M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000)&nbsp;M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.<br><br>한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.<br><br>3 16

복사<br><br>3
5
7
11
13

복사<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jinjean0123" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jinjean0123" target="_blank">jinjean0123</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/yongjun042" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/yongjun042" target="_blank">yongjun042</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/95" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/95" target="_blank">정수론</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/9" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/9" target="_blank">소수 판정</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/67" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/67" target="_blank">에라토스테네스의 체</a>
<br><br>
<br>이 문제의 채점 우선 순위는 2이다.
<br><br>
<br>
그냥 소수 다 구해 놓고 범위에 맞는 것만 출력…

<br>
다 구하기에는 좀 많음… 줄일 수 있을 듯..

<br>
범위의 수가, 10이면, 2,3,4,5의 배수는 무조건 있을 듯.(범위의 반까지.)

<br>
큰수의 절반이 제일 큰, 소수 후보겠지.

<br><br>import sys

def solution():
    M, N = map(int,sys.stdin.readline().rstrip().split())
    lst = [True] * (1000000 + 1)
    lst[0] = 0
    lst[1] = 0
    
    for i in range(2, int(1000000**(0.5)) +1):
        if lst[i]:
            for j in range(i*2,len(lst),i):
                lst[j] = False
    
    for n in range(M,N+1):
        if lst[n]:
            print(n)
        
if __name__ == "__main__":
    solution()
복사<br>
<br>
앞에는 1이 true라 소수 취급 되어서 틀림.

<br>
홀수만 포함된 list를 만들 수는 없나?

<br>
2의 배수는 미리 빠지는 list로 만들기

<br><br>import sys

def solution():
    M, N = map(int,sys.stdin.readline().rstrip().split())
    lst = ([False]+[True]) * (((N+1)//2)+1)
    lst[1] = False

    for i in range(3, int(N**(0.5)) +1):
        if lst[i]:
            for j in range(i*3,N+1,i*2):
                lst[j] = False
    
    for n in range(M,N+1):
        if lst[n]:
            print(n)

if __name__ == "__main__":
    solution()ㅇ
복사<br>
<br>ㅇ
<br>으악 2를 false로 처리해버렸네….
<br><br>
<br>에라토스테네스의 체
  <a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4" rel="noopener nofollow" class="external-link" href="https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4" target="_blank">에라토스테네스의 체</a><br>

<br>0,1 보다 True False가 빠르네?
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/소수-구하기.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/소수 구하기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[설탕 배달]]></title><description><![CDATA[ 
 <br><br>ID: 2839<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2839" target="_blank">https://www.acmicpc.net/problem/2839</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 그리디 알고리즘, 다이나믹 프로그래밍, 수학<br>
생성 일시: 2023년 4월 16일 오후 11:12<br><br><br><br><br>상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.<br>상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.<br>상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)<br><br>상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.<br><br>18

복사<br><br>4

복사<br><br>4

복사<br><br>-1

복사<br><br>6

복사<br><br>2

복사<br><br>9

복사<br><br>3

복사<br><br>11

복사<br><br>3

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/45" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/45" target="_blank">Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/17" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/17" target="_blank">Croatian Open Competition in Informatics</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/20" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/20" target="_blank">COCI 2010/2011</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/81" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/81" target="_blank">Contest #7</a>&nbsp;1번<br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/hyunynim" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/hyunynim" target="_blank">hyunynim</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><br>
<br>N = 3a+5b
<br><br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    
    result = 0
    flag = 0
    
    while True:
        if N % 3 == 0:
            flag = N
        
        if N &gt;= 5:
            N -= 5
            result += 1
        else:
            if flag == 0:
                result = -1
            else:
                result -= (flag - N)//5
                result += flag//3
            break
            
    print(result)    

if __name__ == "__main__":
    solution()
복사<br>
<br>
5로만 계속 빼면서

<br>
그 순간 순간 마다 3으로 나눠 떨어지는 시점을 flag에 저장해 놓음(제일 작은 수로)

<br>
만약에 5로 계속 빼다가 딱 맞게 떨어지지 않으면,

<br>
flag로 돌아가서 (result에서 그만큼 뺌)

<br>
3kg짜리 배달하는 만큼 더해서 print.

<br>
틀림: 5로만 구성된 경우에 문제가 생김…

<br>import sys

def solution():
    # 첫줄 input값 받기
    N = int(sys.stdin.readline().rstrip())
    
    result = 0
    flag = 0
    
    while True:
        if N % 3 == 0:
            flag = N
        
        if N &gt;= 5:
            N -= 5
            result += 1
        elif N == 0:
            break
        else:
            if flag == 0:
                result = -1
            else:
                result -= (flag - N)//5
                result += flag//3
            break
            
    print(result)    

if __name__ == "__main__":
    solution()
복사<br><br>
<br>아, 5로 나누어떨어질 때까지 3씩 빼주면, flag를 세울 필요가 없구나.
<br>훨씬 간단하네.
<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/설탕-배달.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/설탕 배달.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[비밀번호 만들기]]></title><description><![CDATA[ 
 <br><br>ID: 17218<br>
난이도: 골드2<br>
다시풀기: Yes<br>
생성 일시: 2023년 8월 12일 오후 7:08<br><br>
💡 Lcs 알고리즘<br><br><br><br><br>최근 들어 개인정보 유출에 대한 뉴스를 많이 본&nbsp;수형이는 한 사이트의 비밀번호가 유출&nbsp;되더라도 다른 사이트에서 똑같은 비밀번호로&nbsp;접속할 수 없도록&nbsp;사이트마다 비밀번호를 다르게 설정하기로 다짐했다. 많이 고민한 결과 수형이는 눈을 감고 키보드를 막 쳐서 나온 두 문자열에서 공통으로 존재하는 가장 긴 부분 문자열을 비밀번호로 하기로 하였다. 수형이가 눈을 감고 만든 두 문자열이 주어졌을 때 비밀번호를 만드는 프로그램을 만들어보자.<br><br>첫째 줄과 둘째 줄에 수형이가 눈을 감고 만든 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 길이는 최대&nbsp;40자이다. 빈 문자열은 주어지지 않는다.&nbsp;가장 긴 부분 문자열은 반드시 하나만 존재한다.<br><br>첫 번째 줄에 입력으로 주어진 두 문자열로 만든&nbsp;비밀번호를 출력한다.<br><br>AUTABBEHNSA
BCUAMEFKAJNA
복사<br><br>UAENA

복사<br>AUTABBEHNSA<br>BCUAMEFKAJNA<br><br>SETAPPLE
EATMANY

복사<br><br>ETA

복사<br>SETAPPLE<br>EATMANY<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/5" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/5" target="_blank">University</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/418" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/418" target="_blank">한양대학교 ERICA 캠퍼스</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/791" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/791" target="_blank">2019 HEPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/2032" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/2032" target="_blank">MAVEN League</a>&nbsp;E번<br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/TheKinGoD" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/TheKinGoD" target="_blank">TheKinGoD</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><br>
<br>
f(x, start(, end)) ⇒ start~end 사이에 가장 앞에 있는 x의 위치

<br>
result =

<br>
변수 재사용.

<br>flag → start나 end


<br>
그리고 flag로 한번 사용되었던 애로부터 시작하는 건 안써도 됨.

<br>
뒤에서부터 한다고 생각해볼까.

<br>
result = “”

<br>
word1의 첫 알파벳을 word2[0:]에서 찾음

<br>여러개일 수 있으니까, 찾을 때마다 옆으로 넘김


<br>
word1의 두번째 알파벳을 word2[flag:]에서 찾음

<br>
반복

<br>
뒤에서 부터 해보면

<br>
f(word[-1], 0) = word1의 마지막 알파벳을 word2 (뒤에서부터)찾음

<br>
word1의 -2 위치 알파벳을 word2[:flag]찾음

<br>f(word[-2]) =


<br>복사<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/비밀번호-만들기.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/비밀번호 만들기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[색종이]]></title><description><![CDATA[ 
 <br><br>ID: 2563<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2563" target="_blank">https://www.acmicpc.net/problem/2563</a><br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 구현<br>
생성 일시: 2023년 4월 20일 오전 10:38<br><br><br><br><br>가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.<br><a rel="noopener nofollow" class="external-link" href="https://upload.acmicpc.net/6000c956-1b07-4913-83c3-72eda18fa1d1/-/preview/" target="_blank">https://upload.acmicpc.net/6000c956-1b07-4913-83c3-72eda18fa1d1/-/preview/</a><br>예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다.<br><br>첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다<br><br>첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다.<br><br>3
3 7
15 7
5 2

복사<br><br>260
복사<br><br>
<br>
그냥 2d list만들어서 색칠하면 안되나ㅋㅋㅋㅋ

<br>
아니면, N*100 - (겹치는 부분.)

<br>복사<br><br>
<br>list 곱하기

<br>곱하기 연산은 리스트를 곱한 숫자만큼 반복시켜서 새로운 리스트를 생성합니다.
<br>곱하기 연산자는 특정 값으로 전체를 채우고 싶을 때 사용할 수 있습니다.


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/색종이.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/색종이.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[본]]></title><description><![CDATA[ 
 <br><br>ID: 1676<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1676" target="_blank">https://www.acmicpc.net/problem/1676</a><br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 수학<br>
생성 일시: 2023년 7월 21일 오후 8:44<br><br><br><br><br>N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500)<br><br>첫째 줄에 구한 0의 개수를 출력한다.<br><br>10

복사<br><br>2

복사<br><br>3

복사<br><br>0

복사<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/111111111111" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/111111111111" target="_blank">111111111111</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/his130" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/his130" target="_blank">his130</a>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author6" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/author6" target="_blank">author6</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><br>
<br>
팩토리얼..

<br>
0이 나오려면, 2와5

<br>
2는 항상 5전에 몇번 나올것같음 2의 배수가 훨씬 많으니까, 5의 배수의 개수로 판단.

<br>
앗,,! 5의 제곱,,,,

<br>5, 25,125


<br><br>
<br>0은 0임…
<br>import sys

num = int(sys.stdin.readline())

if num == 0:
    result = 1
else:
    result = 0
    while num &gt; 0:
        num = num // 5
        result += num

if __name__ == "__main__":
    print(result)
복사<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/본.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/본.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[보물]]></title><description><![CDATA[ 
 <br><br>ID: 1026<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1026" target="_blank">https://www.acmicpc.net/problem/1026</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 그리디 알고리즘, 수학, 정렬<br>
생성 일시: 2023년 4월 20일 오전 11:53<br><br><br><br><br>옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.<br>길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.<br>S = A[0] × B[0] + ... + A[N-1] × B[N-1]<br>S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.<br>S의 최솟값을 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에 N이 주어진다. 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.<br><br>첫째 줄에 S의 최솟값을 출력한다.<br><br>5
1 1 1 6 0
2 7 8 3 1

복사<br><br>18

복사<br><br>3
1 1 3
10 30 20

복사<br><br>80

복사<br><br>9
5 15 100 31 39 0 0 3 26
11 12 13 2 3 4 5 9 1

복사<br><br>528

복사<br><br>예제 1의 경우 A를 {1, 1, 0, 1, 6}과 같이 재배열하면 된다.<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><br>
<br>
B를 {val: [index]}해서 내림차순 정렬.

<br>
오름차순 정렬된 a와 매칭

<br>
A[0]가지고 B한바퀴 돌려서, 제일 큰수 index에 넣고.

<br>
그 다음으로 큰수 넣고

<br>
다시다시

<br>
받아서, a값 정렬해서 a값 하나 잡고, 가장 큰 수장 곱해서 더하고, 다음 a값과 그다음 큰 수를 곱해서 더하고 반복.

<br><br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())
    
    A = list(map(int, sys.stdin.readline().rstrip().split(" ")))
    B = list(map(int, sys.stdin.readline().rstrip().split(" ")))
    A.sort()

    result = 0

    for i in A:
        max = 0
        idx = -1
        for j in range(len(B)):
            if B[j] &gt; 100:
                continue
            if B[j] &gt;= max:
                max = B[j]
                idx = j
        result += (max*i)
        B[idx] = 101
    print(result)

if __name__ == "__main__":
   solution()
복사<br>
<br>예제는 다 되는데,,, 반례를 찾아야함.
<br>참조값이 없거나 부적적한 값…일때.
<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/보물.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/보물.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[바이러스]]></title><description><![CDATA[ 
 <br><br>ID: 2606<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2606" target="_blank">https://www.acmicpc.net/problem/2606</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
분류: 그래프 이론, 그래프 탐색, 깊이 우선 탐색, 너비 우선 탐색<br>
생성 일시: 2023년 8월 19일 오후 7:24<br><br><br><br><br>신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.<br>예를 들어 7대의 컴퓨터가 &lt;그림 1&gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.<br><img alt="https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png" src="https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png" referrerpolicy="no-referrer"><br>어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하인 양의 정수이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.<br><br>1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.<br><br>7
6
1 2
2 3
1 5
5 2
5 6
4 7

복사<br><br>4

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/55" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/55" target="_blank">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/57" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/57" target="_blank">한국정보올림피아드시․도지역본선</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/74" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/74" target="_blank">지역본선 2004</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/379" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/379" target="_blank">초등부</a>&nbsp;3번<br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/chansol" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/chansol" target="_blank">chansol</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/znxkqkfpdyalgnfl" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/znxkqkfpdyalgnfl" target="_blank">znxkqkfpdyalgnfl</a>
<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jsa3824" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jsa3824" target="_blank">jsa3824</a>
<br><br>
<br>우왕 그래프다…
<br>그래프 공부….
<br>복사<br><br>import sys

def get_input(num):
    matrix = [[0] * num for _ in range(num)]
    N = int(sys.stdin.readline().rstrip())
    for _ in range(N):
        i,j = map(int, sys.stdin.readline().split())
        matrix[i-1][j-1] = 1
        matrix[j-1][i-1] = 1
    return matrix

def check_virus(G, num):
    for i in range(len(G[num])):
        if G[num][i] == 1:
            if computer[i] != 1:
                computer[i] = 1
                check_virus(G, i)
    return None

num = int(sys.stdin.readline().rstrip())
computer = [0]*num
computer[0] = 1
check_virus(get_input(num),0)
print(sum(computer)-1)
복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/바이러스.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/바이러스.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate><enclosure url="https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[듣보잡]]></title><description><![CDATA[ 
 <br><br>ID: 1764<br>
Site: 백준<br>
URL: acmicpc.net/problem/1764<br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 문자열, 자료구조, 정렬, 해시를 사용한 집합과 맵<br>
생성 일시: 2023년 8월 3일 오후 11:51<br><br><br><br><br>김진영이 듣도 못한 사람의 명단과, 보도 못한 사람의 명단이 주어질 때, 듣도 보도 못한 사람의 명단을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 듣도 못한 사람의 수 N, 보도 못한 사람의 수 M이 주어진다. 이어서 둘째 줄부터 N개의 줄에 걸쳐 듣도 못한 사람의 이름과, N+2째 줄부터 보도 못한 사람의 이름이 순서대로 주어진다. 이름은 띄어쓰기 없이 알파벳 소문자로만 이루어지며, 그 길이는 20 이하이다. N, M은 500,000 이하의 자연수이다.<br>듣도 못한 사람의 명단에는 중복되는 이름이 없으며, 보도 못한 사람의 명단도 마찬가지이다.<br><br>듣보잡의 수와 그 명단을 사전순으로 출력한다.<br><br>3 4
ohhenrie
charlie
baesangwook
obama
baesangwook
ohhenrie
clinton

복사<br><br>2
baesangwook
ohhenrie

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author5" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/author5" target="_blank">author5</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/136" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/136" target="_blank">해시를 사용한 집합과 맵</a>
<br><br>
<br>앞에 피카츄 문제랑 비슷
<br><br>import sys

def solution():
    N, M = map(int,sys.stdin.readline().rstrip().split())
    see_dict = {}
    result_list = []

    for _ in range(N):
        name = sys.stdin.readline().rstrip()
        see_dict[name] = 1

    for _ in range(M):
        qes = sys.stdin.readline().rstrip()
        if see_dict.get(qes) == 1:
            result_list.append(qes)

    result_list.sort()
    print(len(result_list))
    print("\n".join(result_list))

if __name__ == "__main__":
    solution()
복사<br><br>import sys
n, m = map(int, input().split())
nameList = sys.stdin.read().splitlines()
hearset = set(nameList[:n])
seeset = set(nameList[n:])
ret = list(hearset &amp; seeset)
ret.sort()
print(len(ret))
for i in ret:
    print(i)
복사<br>
<br>교집합 기호 그냥 사용하는 방법도 있네.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/듣보잡.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/듣보잡.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[마인크래프트]]></title><description><![CDATA[ 
 <br><br>ID: 18111<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/18111" target="_blank">https://www.acmicpc.net/problem/18111</a><br>
난이도: 실버 2<br>
다시풀기: Yes<br>
분류: 구현, 브루트포스 알고리즘<br>
생성 일시: 2023년 7월 24일 오후 3:18<br><br><br><br><br>팀 레드시프트는&nbsp;대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 ×&nbsp;1 ×&nbsp;1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.<br>목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’&nbsp;작업을 해야 한다.<br>lvalue는 세로&nbsp;N, 가로&nbsp;M&nbsp;크기의 집터를 골랐다. 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 우리는 다음과 같은 두 종류의 작업을 할 수 있다.<br>
<br>좌표 (i,&nbsp;j)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.
<br>인벤토리에서 블록 하나를 꺼내어 좌표 (i,&nbsp;j)의 가장 위에 있는 블록 위에 놓는다.
<br>1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다. ‘땅 고르기’&nbsp;작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.<br>단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다. 또한, 작업을 시작할 때 인벤토리에는&nbsp;B개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.<br><br>첫째 줄에&nbsp;N, M,&nbsp;B가 주어진다. (1&nbsp;≤&nbsp;M,&nbsp;N&nbsp;≤ 500, 0 ≤&nbsp;B&nbsp;≤&nbsp;6.4 × 107)<br>둘째 줄부터&nbsp;N개의 줄에 각각&nbsp;M개의 정수로 땅의 높이가 주어진다. (i&nbsp;+ 2)번째 줄의&nbsp;(j&nbsp;+ 1)번째 수는 좌표 (i,&nbsp;j)에서의 땅의 높이를 나타낸다. 땅의 높이는 256보다 작거나 같은 자연수 또는 0이다.<br><br>첫째 줄에 땅을 고르는 데 걸리는 시간과 땅의 높이를 출력하시오. 답이 여러 개 있다면 그중에서 땅의 높이가 가장 높은 것을 출력하시오.<br><br>3 4 99
0 0 0 0
0 0 0 0
0 0 0 1

복사<br><br>2 0

복사<br>맨 오른쪽 아래의 블록을 제거하면 모두 높이가 0으로 고른 상태가 된다. 따라서 블럭을 한 번 제거하는 시간 2초가 소요된다.<br><br>3 4 1
64 64 64 64
64 64 64 64
64 64 64 63

복사<br><br>1 64

복사<br><a rel="noopener nofollow" class="external-link" href="https://upload.acmicpc.net/50e6d9c5-2294-4bb5-826b-bb0fd3bc67f7/-/preview/" target="_blank">https://upload.acmicpc.net/50e6d9c5-2294-4bb5-826b-bb0fd3bc67f7/-/preview/</a><br>인벤토리에 블록이 하나 있기 때문에, 맨 오른쪽 아래에 블록을 하나 채우면 된다.<br><br>3 4 0
64 64 64 64
64 64 64 64
64 64 64 63

복사<br><br>22 63

복사<br>인벤토리가 비어 있기 때문에, 맨 오른쪽 아래를 제외한 모든 좌표에서 블록을 하나씩 제거해야 한다.<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/5" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/5" target="_blank">University</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/83" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/83" target="_blank">서강대학교</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/693" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/693" target="_blank">2019 Sogang Programming Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/2128" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/2128" target="_blank">Champion</a>&nbsp;B번<br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/hp3265" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/hp3265" target="_blank">hp3265</a>
<br>문제를 검수한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/shiftpsh" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/shiftpsh" target="_blank">shiftpsh</a>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/lvalue" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/lvalue" target="_blank">lvalue</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>복사<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/마인크래프트.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/마인크래프트.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[로프]]></title><description><![CDATA[ 
 <br><br>ID: 2217<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2217" target="_blank">https://www.acmicpc.net/problem/2217</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 그리디 알고리즘, 수학, 정렬<br>
생성 일시: 2023년 8월 7일 오후 11:25<br><br>
💡 2217-1 파일 계속 틀려서… 딴 코드 참고한건데.<br><br><br><br><br>N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.<br>하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.<br>각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.<br><br>첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.<br><br>첫째 줄에 답을 출력한다.<br><br>2
10
15

복사<br><br>20

복사<br><br>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/bububu111" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/bububu111" target="_blank">bububu111</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/kdk8361" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/kdk8361" target="_blank">kdk8361</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/roy752" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/roy752" target="_blank">roy752</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><br>
<br>받아서
<br>sort해서
<br>자기보다 큰 rope 다 사용하는 걸로 해서 값 계산해서
<br>max값 찾아서
<br>근데 시간이 좀 김…
<br>복사<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/로프.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/로프.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[덩치]]></title><description><![CDATA[ 
 <br><br>ID: 7568<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/7568" target="_blank">https://www.acmicpc.net/problem/7568</a><br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 구현, 브루트포스 알고리즘<br>
생성 일시: 2023년 4월 12일 오전 11:10<br><br><br><br><br>우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다. 두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x &gt; p 그리고 y &gt; q 이라면 우리는 A의 덩치가 B의 덩치보다 "더 크다"고 말한다. 예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다. 예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, "덩치"로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.<br>N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 "큰 덩치"의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다. 이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.<br><br>위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다. 그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.<br><br>첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.<br><br>여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.<br><br>
<br>2 ≤ N ≤ 50
<br>10 ≤ x, y ≤ 200
<br><br>5
55 185
58 183
88 186
60 175
46 155

복사<br><br>2 2 1 2 5

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/55" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/55" target="_blank">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/57" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/57" target="_blank">한국정보올림피아드시․도지역본선</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/214" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/214" target="_blank">지역본선 2013</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/912" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/912" target="_blank">초등부</a>&nbsp;2번<br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/apjw6112" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/apjw6112" target="_blank">apjw6112</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/eric00513" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/eric00513" target="_blank">eric00513</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/genius0412" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/genius0412" target="_blank">genius0412</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jung2381187" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jung2381187" target="_blank">jung2381187</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/seecimi" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/seecimi" target="_blank">seecimi</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/rea9lizer" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/rea9lizer" target="_blank">rea9lizer</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/thebjko" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/thebjko" target="_blank">thebjko</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>
<br>그냥 brute-force로 해보지 뭐.
<br>튜플을 사용해도 되겠구나!
<br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    cnt = N
    result = []
    lst = []

    # input 받아서 키, 몸무게 list 생성
    while cnt &gt;0:
        cnt-=1
        x, y = map(int,sys.stdin.readline().rstrip().split(" "))
        lst.append((x,y))
    
    # 등수 구하기

    for i in lst:
        rank = 1
        for j in lst:
            if i[0] &lt; j[0] and i[1] &lt; j[1]:
                rank += 1
        result.append(str(rank))
        cnt += 1
    print(" ".join(result))

if __name__ == "__main__":
    solution()
복사<br><br>
<br>join은 list의 요소가 str이어야함.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/덩치.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/덩치.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[단어정렬]]></title><description><![CDATA[ 
 <br><br>ID: 1181<br>
Site: 백준<br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 문자열, 정렬<br>
생성 일시: 2023년 4월 11일 오후 1:52<br><br><br>
<br>중복 제거 → set(순서 없음, 중복없음.)을 사용하려 했으나, 순서 없음이 헷갈릴 것 같아서 다른 방법 생각.
<br>사전식 배열 → 그냥 글자끼리 compare해도 가능 ⇒ 그런데 이방법은 길이와 관계가 없음.
<br>그러면 입력 받으면서 길이로 나누고(2d array? dict?)
<br>그 안에서 비교를 하자.
<br><br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    lst = [[] for _ in range(50)]

    while N &gt; 0:
        N-=1
        word = sys.stdin.readline().rstrip()        
        lst[len(word)-1].append(word)
        
    for i in lst:
        i.sort()
        for j in i:
            print(j)

if __name__ == "__main__":
    solution()
복사<br>
<br>중복제거를 하지 않았어…
<br>다 compare하는 방식으로 돌리기에는 코드가 복잡하고
<br>넣을때마다 있는지 없는지 확인하기에는 음…
<br>오! set을 쓰면 되겠다.
<br><br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    lst = [set() for _ in range(50)]

    while N &gt; 0:
        N-=1
        word = sys.stdin.readline().rstrip()        
        lst[len(word)-1].add(word)
        
    for i in lst:
        k = list(i)
        k.sort()
        for j in k:
            print(j)

if __name__ == "__main__":
    solution()
복사<br>
<br>더 줄일 수 있는데,,, 50,60대로…
<br>아…! set도 sort가능이네? 순서 없음인데?

<br>대신 set.sort()는 안됨


<br>똑같은디….
<br>아…! print를 반복하는 것도 실행시간에 영향을 줄 수 있음..
<br><br>
<br>set(순서없음, 중복 없음)은 append가 아니라, add를 쓴다.
<br>set도 sort 할 수 있다.

<br>대신 i.sort()는 list 전용이다. → 원본값을 수정함으로 빠름
<br>sorted()는 다 사용 가능


<br>+) set은 mutable, tuple은 수정이 어려움. → 그냥 ()는 tuple이다.
<br>여러번의 print()보다 join을 사용한 한번의 print() 더 빠르다.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/단어정렬.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/단어정렬.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[다이나믹프로그래밍(DP)]]></title><description><![CDATA[ 
 <br><br>ID: 0<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://hongjw1938.tistory.com/47" target="_blank">https://hongjw1938.tistory.com/47</a><br>
다시풀기: No<br>
분류: 다이나믹 프로그래밍<br>
생성 일시: 2023년 8월 18일 오후 3:59<br>
참고: BFS<br><br><br>
<br>하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것
<br>큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용 = 기억하며 풀기
<br>일반적인 재귀(Naive Recursion) 방식 또한 DP와 매우 유사
<br><br><br>
<br>동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능
<br>이진 탐색(<a data-tooltip-position="top" aria-label="https://hongjw1938.tistory.com/40?category=884192" rel="noopener nofollow" class="external-link" href="https://hongjw1938.tistory.com/40?category=884192" target="_blank">참고</a>)와&nbsp;피보나치 수열의 경우를 비교해 보자.

<br>이진 탐색은 특정 데이터를 정렬된 배열 내에서 그 위치를 찾기 때문에 그 위치를 찾은 후 바로 반환할 뿐 그것을 재사용하는 과정을 거치지 않는다. 반면, 피보나치 수열은 f(n) = f(n-1) + f(n-2) 인데, 아래와 같은 트리 구조로 함수가 호출되게 된다.
<br>f(3), f(2), f(1)과 같이 동일한 부분 문제가 중복


<br><br>
<br>부분 문제에서 구한 최적 결과가 전체 문제에서도 동일하게 적용되어 결과가 변하지 않을 때 DP를 사용할 수 있게 된다.
<br><br><br>이름에서 보이듯이,&nbsp;아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식이다.<br>메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고 dp[n]을 목표 상태라고 하자. Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.<br><br>이는 dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해&nbsp;위에서 부터 바로 호출을 시작하여 dp[0]의 상태까지 내려간 다음 해당&nbsp;결과 값을 재귀를 통해 전이시켜 재활용하는 방식이다.<br>피보나치의 예시처럼, f(n) = f(n-2) + f(n-1)의 과정에서 함수 호출 트리의 과정에서 보이듯, n=5일 때, f(3), f(2)의 동일한 계산이 반복적으로 나오게 된다.<br>이 때, 이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 그래서 가장 최근의 상태 값을 메모해 두었다고 하여&nbsp;Memoization&nbsp;이라고 부른다.<br>"Untitled"이(가) 생성되지 않았습니다. 클릭하여 생성합니다.%20d88c8563b44f47958703582cec841bfb/Untitled.png)<br><br>Q. Divide and Conquer(분할 정복)와 차이점은?<br>분할 정복과&nbsp;동적 프로그래밍은&nbsp;주어진 문제를 작게 쪼개서 하위 문제로 해결하고 연계적으로 큰 문제를 해결한다는 점은 같다.<br>차이점은, 분할 정복은 분할된 하위 문제가 동일하게 중복이 일어나지 않는 경우에 쓰며, 동일한 중복이 일어나면 동적 프로그래밍을 쓴다는 것이다.<br><br>
<br>피보나치 구현에 재귀를 활용했다면 시간복잡도는&nbsp;O(2^n)이지만, 동적 계획법을 활용하면 O(N)으로 해결할 수 있다.
<br>## Bottom-up
def dp_fibonacci(x):
    dp = [0,1] + ([0]*(x-1))

    for i in range(2, len(dp)):
        dp[i] = dp[i-1] + dp[i-2]

    print(dp[x])
    print(dp)

dp_fibonacci(100)
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/다이나믹프로그래밍(dp).html</link><guid isPermaLink="false">1. Study/Coding Test/PS/다이나믹프로그래밍(DP).md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:26:53 GMT</pubDate></item><item><title><![CDATA[기본]]></title><description><![CDATA[ 
 <br><br>다시풀기: No<br>
생성 일시: 2023년 4월 11일 오후 1:50<br><br><br><br>복사<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/기본.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/기본.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[나이순 정렬]]></title><description><![CDATA[ 
 <br><br>ID: 10814<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/10814" target="_blank">https://www.acmicpc.net/problem/10814</a><br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 정렬<br>
생성 일시: 2023년 4월 12일 오후 1:05<br><br><br><br><br>온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.<br><br>첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000)<br>둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.<br><br>첫째 줄부터 총 N개의 줄에 걸쳐 온라인 저지 회원을 나이 순, 나이가 같으면 가입한 순으로 한 줄에 한 명씩 나이와 이름을 공백으로 구분해 출력한다.<br><br>3
21 Junkyu
21 Dohyun
20 Sunyoung

복사<br><br>20 Sunyoung
21 Junkyu
21 Dohyun

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><br>
<br>
<br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    result = ""
    
    lst = []

    while N&gt;0:
        N-=1
        age, name = sys.stdin.readline().split()
        lst.append([age, " "+name+"\n"])
    
    lst.sort(key=lambda x:x[0])
    for i in lst:
        result += "".join(i)

    print(result[:-1])
if __name__ == "__main__":
    solution()
복사<br><br>
<br>data_list.sort(key=lambda x : len(x))

<br>x의 길이를 기준으로 오름차순으로 정렬해주세요.


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/나이순-정렬.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/나이순 정렬.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[나는야 포켓몬 마스터 이다솜]]></title><description><![CDATA[ 
 <br><br>ID: 1620<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1620" target="_blank">https://www.acmicpc.net/problem/1620</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 자료구조, 해시를 사용한 집합과 맵<br>
생성 일시: 2023년 7월 29일 오전 12:40<br><br><br><br><br><img alt="https://www.acmicpc.net/upload/201004/p1.PNG" src="https://www.acmicpc.net/upload/201004/p1.PNG" referrerpolicy="no-referrer"><br>안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으로 가야겠어.<br>(뚜벅 뚜벅)<br>얏! 꼬렛이다. 꼬렛? 귀여운데, 나의 첫 포켓몬으로 딱 어울린데? 내가 잡고 말겠어. 가라! 몬스터볼~<br>(펑!) 헐랭... 왜 안 잡히지?ㅜㅜ 몬스터 볼만 던지면 되는 게 아닌가...ㅜㅠ<br>(터벅터벅)<br>어? 누구지?<br><img alt="https://www.acmicpc.net/upload/201004/p2.PNG" src="https://www.acmicpc.net/upload/201004/p2.PNG" referrerpolicy="no-referrer"><br>오박사 : 나는 태초마을의 포켓몬 박사 오민식 박사라네. 다솜아, 포켓몬을 잡을 때는, 일단 상대 포켓몬의 체력을 적당히 바닥으로 만들어놓고 몬스터 볼을 던져야 한단다. 자, 내 포켓몬 이상해꽃으로 한번 잡아보렴. 포켓몬의 기술을 쓰는 것을 보고 포켓몬을 줄지 안줄지 결정을 하겠네. 자 한번 해보아라. 다솜아.<br>이다솜 : 이상해꽃이라...음.. 꽃이니깐 왠지 햇빛을 받아서 공격을 할 것 같은데... 음... 이상해꽃! 햇빛공격!!!<br>(꼬렛이 이상해꽃에게 공격을 받아 체력이 25 감소했다.) &nbsp;&nbsp; 가라! 몬스터 볼!!! &nbsp;&nbsp; (꼬렛을 잡았습니다.) &nbsp;&nbsp; 야호! 신난다. 꼬렛을 잡았다.<br>오박사 : 오우!! 방금 쓴 공격은 솔라빔이라고 하네.. 어떻게 공격을 한 건가? 솔라빔이란 공격에 대해서 공부를 한 건가?<br>이다솜 : 꽃이니깐 왠지 햇빛을 제대로 받으면 광합성을 해서 음.. 그냥 그럴 것 같아서요 ☞☜<br>오박사 : 다른 아이들은 넝쿨채찍이나, 나뭇잎 공격을 하는데, 다솜이는 역시 뭔가 다르구나. 그럼 나와 함께 연구소로 가자꾸나. 내가 포켓몬을 한 마리 줄 테니, 너의 꿈을 펼쳐보아라. 꿈은 이루어진단다.<br>이다솜 : 네! 오박사님, 고마워요.ㅜㅜ<br>오박사 : 가자. 나의 연구소는 너의 옆집의 아랫집이란다. 같이 가도록하자. 지금 포켓몬을 주마.<br>이다솜 : 네. 야호!!<br>'<br><img alt="https://www.acmicpc.net/upload/201004/p3.PNG" src="https://www.acmicpc.net/upload/201004/p3.PNG" referrerpolicy="no-referrer"><br>오영식 : 어? 오박사님 얘는 누구인가요?<br><img alt="https://www.acmicpc.net/upload/201004/p4.PNG" src="https://www.acmicpc.net/upload/201004/p4.PNG" referrerpolicy="no-referrer"><br>오박사 : 얘는 너의 라이벌이 될 친구 이다솜이라고 하네. 자, 포켓몬을 한 마리 골라보도록 해봐라 다솜아. 레이디퍼스트 네가 먼저 골라봐라.<br>이다솜 : 저는 생각해둔 포켓몬이 있어요. 피카츄 골라도 될까요?<br>오박사 : 그래 여기 피카츄가 한 마리 있단다. 피카츄를 가져가거라.<br>오영식 : 그럼 저는 이브이를 가져가겠어요. 그럼 나중에 보자 이다솜.<br>이다솜 : 그럼 꼬렛을 다시 잡으러 가야겠다. 영식아, 그리고 민식박사님 빠잉!<br><img alt="https://www.acmicpc.net/upload/201004/p5.PNG" src="https://www.acmicpc.net/upload/201004/p5.PNG" referrerpolicy="no-referrer"><br>이다솜 : 피카츄 공격!<br><img alt="https://www.acmicpc.net/upload/201004/p6.PNG" src="https://www.acmicpc.net/upload/201004/p6.PNG" referrerpolicy="no-referrer"><br>가라 몬스터 볼!<br><img alt="https://www.acmicpc.net/upload/201004/p7.PNG" src="https://www.acmicpc.net/upload/201004/p7.PNG" referrerpolicy="no-referrer"><br>이다솜 : 야호! 신난다. 꼬렛을 잡았다!!!!!<br>이다솜 : 그럼! 일단 사천왕을 이기고 오겠어!<br><img alt="https://www.acmicpc.net/upload/201004/p8.PNG" src="https://www.acmicpc.net/upload/201004/p8.PNG" referrerpolicy="no-referrer"><br>이다솜 : 여기가 사천왕과 대결하려면 가야하는 곳인가..<br><img alt="https://www.acmicpc.net/upload/201004/p9.PNG" src="https://www.acmicpc.net/upload/201004/p9.PNG" referrerpolicy="no-referrer"><br>경비원 : 사천왕과 대결을 하려면, 마을의 체육관 리더를 이겨서 배지를 8개를 모아야 한다네... 배지를 모아서 오도록 하게<br>이다솜 : 잉ㅠㅜ... 그럼 배지부터 모아야 하는구나ㅠㅜㅠㅜ 나쁘당 그냥 좀 봐주지..<br>&lt;1 년 후&gt;<br>그동안의 줄거리 : 이다솜은 일단 상록 숲의 체육관 리더에게 도전을 했다. 하지만 상록숲 체육관의 리더는 실종된 상태. 따라서 회색마을부터 도전하기로 했다. 체육관의 리더를 이기면서, 로켓단을 해체시키기도 하고, 여러 가지 사건도 있었다. 결국 전설의 포켓몬도 잡고, 이제 사천왕을 이기려고 도전하기로 했다. 사천왕은 모두 가볍게 이기고, 이제 마지막 라이벌 오!영!식! 이다.<br><img alt="https://www.acmicpc.net/upload/201004/pa.PNG" src="https://www.acmicpc.net/upload/201004/pa.PNG" referrerpolicy="no-referrer"><br>오영식 : 훗. 1년 전의 그 이다솜이 사천왕을 이기고 현재 포켓몬 마스터인 나에게 덤벼? 어디 한번 덤벼보시지.<br>이다솜 : 헐랭... 나를 우습게보네.... 한번 두고 보시지! 그럼 대결이닷!<br><img alt="https://www.acmicpc.net/upload/201004/pb.PNG" src="https://www.acmicpc.net/upload/201004/pb.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pc.PNG" src="https://www.acmicpc.net/upload/201004/pc.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pd.PNG" src="https://www.acmicpc.net/upload/201004/pd.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pe.PNG" src="https://www.acmicpc.net/upload/201004/pe.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pf.PNG" src="https://www.acmicpc.net/upload/201004/pf.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pg.PNG" src="https://www.acmicpc.net/upload/201004/pg.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/ph.PNG" src="https://www.acmicpc.net/upload/201004/ph.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pi.PNG" src="https://www.acmicpc.net/upload/201004/pi.PNG" referrerpolicy="no-referrer"><br>이다솜 : 휴... 이겼다.<br>오영식 : 내가 지다니 분하다. ㅜㅜ<br>오박사 : 그럼 다솜아 이제 진정한 포켓몬 마스터가 되기 위해 도감을 완성시키도록 하여라. 일단 네가 현재 가지고 있는 포켓몬 도감에서 포켓몬의 이름을 보면 포켓몬의 번호를 말하거나, 포켓몬의 번호를 보면 포켓몬의 이름을 말하는 연습을 하도록 하여라. 나의 시험을 통과하면, 내가 새로 만든 도감을 주도록 하겠네.<br><br>첫째 줄에는 도감에 수록되어 있는 포켓몬의 개수 N이랑 내가 맞춰야 하는 문제의 개수 M이 주어져. N과 M은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수인데, 자연수가 뭔지는 알지? 모르면 물어봐도 괜찮아. 나는 언제든지 질문에 답해줄 준비가 되어있어.<br>둘째 줄부터 N개의 줄에 포켓몬의 번호가 1번인 포켓몬부터 N번에 해당하는 포켓몬까지 한 줄에 하나씩 입력으로 들어와. 포켓몬의 이름은 모두 영어로만 이루어져있고, 또, 음... 첫 글자만 대문자이고, 나머지 문자는 소문자로만 이루어져 있어. 아참! 일부 포켓몬은 마지막 문자만 대문자일 수도 있어. 포켓몬 이름의 최대 길이는 20, 최소 길이는 2야. 그 다음 줄부터 총 M개의 줄에 내가 맞춰야하는 문제가 입력으로 들어와. 문제가 알파벳으로만 들어오면 포켓몬 번호를 말해야 하고, 숫자로만 들어오면, 포켓몬 번호에 해당하는 문자를 출력해야해. 입력으로 들어오는 숫자는 반드시 1보다 크거나 같고, N보다 작거나 같고, 입력으로 들어오는 문자는 반드시 도감에 있는 포켓몬의 이름만 주어져. 그럼 화이팅!!!<br><br>첫째 줄부터 차례대로 M개의 줄에 각각의 문제에 대한 답을 말해줬으면 좋겠어!!!. 입력으로 숫자가 들어왔다면 그 숫자에 해당하는 포켓몬의 이름을, 문자가 들어왔으면 그 포켓몬의 이름에 해당하는 번호를 출력하면 돼. 그럼 땡큐~<br><img alt="https://www.acmicpc.net/upload/201004/pn.PNG" src="https://www.acmicpc.net/upload/201004/pn.PNG" referrerpolicy="no-referrer"><br>이게 오박사님이 나에게 새로 주시려고 하는 도감이야. 너무 가지고 싶다ㅠㅜ. 꼭 만점을 받아줬으면 좋겠어!! 파이팅!!!<br><br>26 5
Bulbasaur
Ivysaur
Venusaur
Charmander
Charmeleon
Charizard
Squirtle
Wartortle
Blastoise
Caterpie
Metapod
Butterfree
Weedle
Kakuna
Beedrill
Pidgey
Pidgeotto
Pidgeot
Rattata
Raticate
Spearow
Fearow
Ekans
Arbok
Pikachu
Raichu
25
Raichu
3
Pidgey
Kakuna

복사<br><br>Pikachu
26
Venusaur
16
14

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/frogyou2330" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/frogyou2330" target="_blank">frogyou2330</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/136" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/136" target="_blank">해시를 사용한 집합과 맵</a>
<br><br>
<br>단어랑 숫자를 전부 생각해야해
<br>tag를 보면, dictionary를 사용해야하는 듯

<br>key를 알파벳 첫자로 하는 경우.


<br>근데 내가 생각한대로면 그냥, 데이터를 2군데에 저장하는 건데.
<br>
<br>list → index가 숫자 그대로 / dictionary → 첫글자를 key로 ⇒ 최대 2만개.
<br>100으로 나눴을 때, 나머지를 index로 하는 list에 dictionary값 저장

<br>이거를 N을 기준으로 해보자.
<br>N의 절반을 기준으로 나누기.


<br>첫글자 ascii code를 index로 하는 list에, key가 숫자인 dictionary값 (혹은 index가 숫자인 list)저장

<br>이건 worst로, 다 같은 알파벳으로 시작하면,,, key(숫자)로 접근할때는 O(n)이지만, value를 기준으로 하면 다 돌아야함.. 숫자로 시작할 때보다(mode 쓰면 분포가 고름)더 에바.


<br>
<br>그러니까. 숫자로 들어왔을 때, 문자를 출력해야하고
<br>문자로 들어왔을 때, 숫자를 출력해야한다고.
<br>첫번째는 간단해, 그냥 숫자를 index로 해서 list를 만들면 되니까.
<br>두번째는 ascii를 index로 하는 list에 문자:숫자형태의 dictionary만들기. 아니지 굳이 그럴 필요 없이 그냥 dictionary만 쓰면 됨.
<br><br>import sys

def solution():
    N, M = map(int, sys.stdin.readline().rstrip().split())
    mod_num = N//2
    eng_list = {}
    num_list = [0]*(N+1)

    for num in range(N):
        name = sys.stdin.readline().rstrip()
        idx = num + 1
        num_list[idx] = name
        eng_list[name] = idx

    for _ in range(M):
        question = sys.stdin.readline().rstrip()
        if ord('A') &lt;= ord(question[0]) &lt;= ord('Z'):
            print(eng_list[question])
        else:
            print(num_list[int(question)])

if __name__ == "__main__":
    solution()
복사<br><br>import sys

def solution():
  lines = sys.stdin.read().splitlines()

  N, M = map(int, lines[0].split())

  encyclopedia = {
    name: str(index + 1)
    for index, name in enumerate(lines[1:N + 1])
  }

  print("\n".join(encyclopedia[exam] if exam.isalpha() else lines[int(exam)]
                  for exam in lines[N + 1:]))

solution()
복사<br>아 이게 바로 splitlines()로 input 다 받아서 바로 num_list로 만들어버렸네]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/나는야-포켓몬-마스터-이다솜.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/나는야 포켓몬 마스터 이다솜.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate><enclosure url="https://www.acmicpc.net/upload/201004/p1.PNG" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.acmicpc.net/upload/201004/p1.PNG"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[계단 오르기]]></title><description><![CDATA[ 
 <br><br>ID: 2579<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2579" target="_blank">https://www.acmicpc.net/problem/2579</a><br>
난이도: 실버 3<br>
다시풀기: Yes<br>
메모: 끝나는거 기준으로 dp 다시 만들어 보기<br>
생성 일시: 2023년 8월 27일 오후 9:01<br><br><br><br><br>계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. &lt;그림 1&gt;과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.<br><a rel="noopener nofollow" class="external-link" href="https://upload.acmicpc.net/7177ea45-aa8d-4724-b256-7b84832c9b97/-/preview/" target="_blank">https://upload.acmicpc.net/7177ea45-aa8d-4724-b256-7b84832c9b97/-/preview/</a><br>&lt;그림 1&gt;<br>예를 들어 &lt;그림 2&gt;와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.<br><a rel="noopener nofollow" class="external-link" href="https://upload.acmicpc.net/f00b6121-1c25-492e-9bc0-d96377c586b0/-/preview/" target="_blank">https://upload.acmicpc.net/f00b6121-1c25-492e-9bc0-d96377c586b0/-/preview/</a><br>&lt;그림 2&gt;<br>계단 오르는 데는 다음과 같은 규칙이 있다.<br>
<br>계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
<br>연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
<br>마지막 도착 계단은 반드시 밟아야 한다.
<br>따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.<br>각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.<br><br>입력의 첫째 줄에 계단의 개수가 주어진다.<br>둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.<br><br>첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.<br><br>6
10
20
15
25
10
20

복사<br><br>75

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/55" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/55" target="_blank">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/57" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/57" target="_blank">한국정보올림피아드시․도지역본선</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/70" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/70" target="_blank">지역본선 2006</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/367" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/367" target="_blank">초등부</a>&nbsp;4번<br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cjswodmlskfk" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/cjswodmlskfk" target="_blank">cjswodmlskfk</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/eric00513" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/eric00513" target="_blank">eric00513</a>
<br><br>
<br>그냥 다 찾아서 최대값
<br>트리를 만들까? 이진 트리 만들 수 있을 것같은데.

<br>트리 만들고 탐색을 할때,


<br>import sys

class Node:
    def __init__(self, parent, id, val):
        self.parent = parent
        self.id = id
        self.element = val
        self.left = None
        self.right = None

class Tree:
    def __init__(self, id):
        self.root = Node(None, id, num_list[id])
        build_tree(self.root, 0)

def build_tree(node, num):
    id = node.id
    sum = node.element + num

    if id == N:
        val_list.append(sum)
    elif id == N-1:
        if node.parent == None or node.id == node.parent.id + 2:
            node.left = Node(node, id + 1, num_list[id + 1])
            build_tree(node.left, sum)
    else:
        if node.parent == None or node.id == node.parent.id + 2:
            node.left = Node(node, id + 1, num_list[id + 1])
            node.right = Node(node, id + 2, num_list[id + 2])
            build_tree(node.left, sum)
            build_tree(node.right, sum)

        else:
            node.right = Node(node, id + 2, num_list[id + 2])
            build_tree(node.right, sum)

N = int(sys.stdin.readline().rstrip())
num_list = [0]
val_list = []

for i in range(N):
    num_list.append(int(sys.stdin.readline().rstrip()))

if N &gt;= 2:
    stair_route_one = build_tree(Tree(1).root, 0)
    stair_route_two = build_tree(Tree(2).root, 0)
else:
    stair_route_one = build_tree(Tree(1).root, 0)

print(max(val_list))
복사<br>
<br>
재귀로 짰는데, 메모리 초과… dp 문제라네…

<br>
dp 어떻게 해야할까.

<br>2로끝

<br>1,2


<br>3 끝

<br>1,3
<br>2,3


<br>4끝

<br>2,4 → 1,2
<br>3,4 → 1,3


<br>5Rmx

<br>3,5 → 1,3|2,3
<br>4,5 → 2,4




<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/계단-오르기.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/계단 오르기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[괄호]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:실버/4" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실버/4</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener nofollow">#코딩테스트</a><br>
<a href="https://sunha20.github.io/digital-garden?query=tag:실버/4" class="tag" target="_blank" rel="noopener nofollow">#실버/4</a><br><br><br>괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다.&nbsp;<br>여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.&nbsp;<br><br>입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다.&nbsp;<br><br>출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.&nbsp;<br><br>6<br>
(())())<br>
(((()())()<br>
(()())((()))<br>
((()()(()))(((())))()<br>
()()()()(()()())()<br>
(()((())()(<br><br>NO<br>
NO<br>
YES<br>
NO<br>
YES<br>
NO<br><br>3<br>
((<br>
))<br>
())(()<br><br>NO<br>
NO<br>
NO<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/1" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/1" target="_blank">ICPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/7" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/7" target="_blank">Regionals</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/42" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/42" target="_blank">Asia Pacific</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/211" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/211" target="_blank">Korea</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/256" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/256" target="_blank">Nationwide Internet Competition</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/1081" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/1081" target="_blank">Daejeon Nationalwide Internet Competition 2012</a>&nbsp;G번<br>
<br>데이터를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/marona" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/marona" target="_blank">marona</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/71" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/71" target="_blank">스택</a>
<br><br>Python에서 strip()을 이용하면 문자열에서 특정 문자를 제거할 수 있습니다. Java 등의 다른 언어들도 strip()을 제공하며, 기능은 모두 비슷합니다.<br>Python의 String은 다음 함수를 제공합니다.<br>strip([chars]) : 인자로 전달된 문자를 String의 왼쪽과 오른쪽에서 제거합니다. lstrip([chars]) : 인자로 전달된 문자를 String의 왼쪽에서 제거합니다. rstrip([chars]) : 인자로 전달된 문자를 String의 오른쪽에서 제거합니다. 인자를 전달하지 않을 수도 있으며, 인자를 전달하지 않으면 String에서 공백을 제거합니다.<br><br>()를 공백으로 대체하는 걸 반복하다가 없으면 no 출력하는방식이. 더 빠르네. n + (n-2) + (n-4) + ... + 0 -&gt; n*(1/2)n인데....<br><br>내가 결과적으로 한 방식은, 조금 더 생각해서 합칠 수 있는 걸 합쳐야 했어. 더하고 빼다가, -1이 나오면 멈추는 방식으로.<br><br>while이 for 보다 빠른가봐... (40 vs 44) 꼭 for일 필요 없는거.(그러니까, 리스트 item들 한바퀴돌리면서 사용해야하는 경우 말고, 그냥 숫자만큼 반복은 while이 빠르네...)]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/괄호.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/괄호.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 02 Mar 2024 02:41:54 GMT</pubDate></item><item><title><![CDATA[개인정보 수집 유효기간]]></title><description><![CDATA[ 
 <br><br>Site: 프로그래머스<br>
난이도: Lv 1<br>
다시풀기: No<br>
분류: 2023, Blind Recruitment, kakao<br>
생성 일시: 2023년 3월 10일 오후 4:36<br><br>def solution(today, terms, privacies):
    answer = []

    # terms to Dict
    terms_dict = {}

    for i in terms:
        cate = i.split()[0]
        term = int(i.split()[1])
        terms_dict[cate] = term

    # privacies date processing
    num = 0
    for i in privacies:
        num += 1
        date, cate = map(str, i.split())
        py, pm, pd = map(int, date.split('.'))
        ty, tm, td = map(int, today.split('.'))

        due_month = (pm + terms_dict[cate]) % 12        
        due_year = py + ((pm + terms_dict[cate]) // 12)
        if due_month == 0:
            due_month = 12
            due_year -= 1

        # print((pm + terms_dict[cate]) // 12)
        print(due_month, due_year)

        if due_year &lt; ty:
            answer.append(num)
        elif due_year &gt; ty:
            None           
        else:           
            if due_month &lt; tm:
                answer.append(num)
            elif due_month &gt; tm:
                None           
            else:  
                if pd &lt;= td:
                    answer.append(num)

    return answer
복사<br><br>: 이걸 쓸 수도 있지 않았을까?<br>
<br>datetime.timedelta(days=0,&nbsp;seconds=0,&nbsp;microseconds=0,&nbsp;milliseconds=0,&nbsp;minutes=0,&nbsp;hours=0,&nbsp;weeks=0)

<br>시간계산
<br>years가 없네…
<br>주의: overflow


<br>datetime.fromisoformat(string)

<br>string 객체를 datetime 형식으로 변환


<br><br>def to_days(date):
    year, month, day = map(int, date.split("."))
    return year * 28 * 12 + month * 28 + day

def solution(today, terms, privacies):
    months = {v[0]: int(v[2:]) * 28 for v in terms}
    today = to_days(today)
    expire = [
        i + 1 for i, privacy in enumerate(privacies)
        if to_days(privacy[:-2]) + months[privacy[-1]] &lt;= today
    ]
    return expire
복사<br><br>
<br>자주 쓰는 코드 따로 function으로 빼줘서 간다하게하기
<br>간단하게 사용하는 for문 기억해두기 (꼭?)
# 예시
[i for i in list()]
{j:j for j in list()}
복사

<br>def solution(today, terms, privacies):
    answer = []
    termdict = {}

    for term in terms:
        t = term.split(' ')
        termdict[t[0]] = int(t[1]) * 28

    t = today.split('.')
    d = 28 * 12 * int(t[0]) + 28 * int(t[1]) + int(t[2])

    for p in range(len(privacies)):
        pret = privacies[p].split(' ')
        t = pret[0].split('.')
        nd = 28 * 12 * int(t[0]) + 28 * int(t[1]) + int(t[2])

        if termdict[pret[1]] + nd &lt;= d:
            answer.append(p + 1)

    return answer
복사<br><br>
<br>day가 딱 28일로 통일되어 있으니, ‘년월일’이 아니라 숫자 하나로 통합해서 비교를 한번만 하면되겠네.
<br>위의 코드도 그 방법인데 이게 더 직관적이었음..
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/개인정보-수집-유효기간.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/개인정보 수집 유효기간.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[BufferedReader]]></title><description><![CDATA[ 
 <br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a><br><a data-tooltip-position="top" aria-label="https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90" rel="noopener nofollow" class="external-link" href="https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90" target="_blank">BufferedReader를 알고 쓰자</a><br>
<a data-tooltip-position="top" aria-label="https://nullnull.tistory.com/23" rel="noopener nofollow" class="external-link" href="https://nullnull.tistory.com/23" target="_blank">JAVA 노드 스트림 &amp; 보조 스트림</a><br>+)<br>
Java에서 데이터를 읽고 쓰는 방법에는 여러 가지가 있습니다. 그 중에서도&nbsp;Buffer,&nbsp;노드 스트림(Node Stream), 그리고&nbsp;보조 스트림(Auxiliary Stream)에 대해 설명하겠습니다.<br>
<br><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank"><strong></strong>: Buffer는 데이터가 전송될 때 일시적으로 저장되는 메모리 영역입니다</a>Buffer<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.&nbsp;<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">Buffer는 속도가 빠른 장치에서 들어오는 모든 데이터를 잠시 저장해놓고 버퍼가 꽉 차거나, 특정 커맨드를 입력받았을 때 일괄적으로 내보내고, 버퍼를 초기화시킵니다</a><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.&nbsp;<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">이렇게 하면 속도가 느린 장치에서 일을 여러번 하지 않도록 속도가 빠른 장치에서 미리미리 처리해두고 "버퍼"라는 임시 공간에 보관해두었다가 한번에 넘겨주는 것입니다</a><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.
<br><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank"><strong></strong>: 노드 스트림은 스트림의 주축을 이루는 요소입니다</a>노드 스트림(Node Stream)<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.&nbsp;<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">노드 스트림은 데이터 타입 (Char 또는 Byte), 방향 (Input 또는 Output), 노드 타입 (File 또는 키보드 등등)에 따라 결정됩니다</a><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.
<br><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank"><strong></strong>: 보조 스트림은 노드 스트림을 통해 들어오거나, 나가는 데이터를 처리하는 것을 도와주는 일종의 플러그인입니다</a>보조 스트림(Auxiliary Stream)<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.&nbsp;<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">보조 스트림은 노드 스트림에 연결되어 기능을 추가하거나 향상시킵니다</a><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.&nbsp;<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">예를 들어,&nbsp;<code></code>와&nbsp;<code></code>은 보조 스트림의 예로, 이들은 노드 스트림에 버퍼링 기능을 추가하여 입출력 효율을 높입니다</a>BufferedReaderBufferedInputStream<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener nofollow" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a><a data-tooltip-position="top" aria-label="https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90" rel="noopener nofollow" class="external-link" href="https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90" target="_blank">2</a>.
<br>이 세 가지 개념은 Java의 입출력 시스템을 이해하는 데 중요한 역할을 합니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊<br>Scanner&nbsp;클래스는 Java에서 제공하는&nbsp;보조 스트림(Auxiliary Stream)&nbsp;중 하나입니다.&nbsp;Scanner는 기본적으로 입력 스트림을 받아서 다양한 타입의 데이터를 읽을 수 있는 메소드를 제공합니다. 이는&nbsp;InputStream,&nbsp;File,&nbsp;String&nbsp;등 다양한 소스로부터 데이터를 읽을 수 있게 해주는 기능을 추가하는 역할을 하므로, 보조 스트림에 속합니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊<br>InputStreamReader는 Java에서 제공하는&nbsp;노드 스트림(Node Stream)&nbsp;중 하나입니다.&nbsp;InputStreamReader는 바이트 스트림을 문자 스트림으로 변환하는 데 사용됩니다. 이 클래스는&nbsp;System.in과 같은&nbsp;InputStream을&nbsp;Reader로 변환하여, 문자 단위로 읽을 수 있게 해줍니다. 따라서,&nbsp;InputStreamReader는 데이터의 원본(노드)에서 직접 데이터를 읽어오는 역할을 하므로 노드 스트림에 속합니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊<br>System.in과 같은&nbsp;InputStream은 Java에서 제공하는&nbsp;노드 스트림(Node Stream)&nbsp;중 하나입니다.&nbsp;InputStream은 바이트 단위로 데이터를 읽어오는 스트림입니다. 이는 데이터의 원본(노드)에서 직접 데이터를 읽어오는 역할을 하므로 노드 스트림에 속합니다.&nbsp;System.in은 표준 입력 스트림으로, 주로 키보드 입력을 받기 위해 사용됩니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊<br>+) <a data-tooltip-position="top" aria-label="https://www.acmicpc.net/board/view/9744" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/board/view/9744" target="_blank">글 읽기 - BufferedReader를 어떻게 사용해야 할지 모르겠습니다.</a><br>
일반적으로 BufferedReader 를 통해 입력받을때 유의하셔야 할 점이 몇가지 있습니다.&nbsp;<br>1. 기본적으로 BufferedReader는 한 줄을 통째로 입력받는 방법으로 주로 쓰입니다.<br>2. readLine() 메서드는 값을 읽어올 때, String값으로 개행문자(엔터값)를 포함해&nbsp;한줄을 전부 읽어오는 방식입니다.<br>&nbsp;- 비슷한 예로 Scanner메서드 중 nextLine()도 스트링 값과 개행문자(엔터값)을 같이 읽어옵니다.(반면 next()는 개행문자는 제외하고 스트링 값만 읽어옵니다.)<br>&nbsp;- 예제의 입력 예제를 보면 각 문장이 모두 개행문자(엔터)로 구별되있는것을 확인하실 수 있습니다. 따라서 이 문제에서&nbsp;개행문자를 입력받는것은 필수입니다!<br>3. read() 메서드는 값을 읽어올 때, int값으로 변형하여 읽어오는 방식입니다.&nbsp;<br>&nbsp;- 예를들어 input.txt에 저장된&nbsp;1이라는 숫자를 read()를 통해 읽어오면&nbsp;&nbsp;int형 숫자 1을 읽어오는 것이 아닌, txt형식으로 저장된 ASCII 형식의 문자값 '1'을 읽어오는 것이므로 결국 int값으론 49를 읽어오는 것이 됩니다.&nbsp;<br>&nbsp;- 이를 해결하려면&nbsp;int a = br.read() - 48; br.readLine();&nbsp;을 하여 ASCII 값에서 뻴셈을 이용한 뒤&nbsp;엔터 값을 읽어오거나,&nbsp;int a = Integer.parseInt(br.readLine());&nbsp;를 통해 엔터값을 포함해 한줄을 통째로 입력받은 뒤 해당 스트링값을 int로 형변환 해주는 방법이 있습니다. (저같은 경우에는 주로 후자의 방법을 사용합니다)]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/bufferedreader.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/BufferedReader.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 25 May 2024 15:32:56 GMT</pubDate></item><item><title><![CDATA[DNA]]></title><description><![CDATA[ 
 <br><br>ID: 1969<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1969" target="_blank">https://www.acmicpc.net/problem/1969</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 구현, 그리디 알고리즘, 문자열, 브루트포스 알고리즘<br>
생성 일시: 2023년 8월 4일 오전 12:41<br>
💡 ******************Deep Copy******************<br>count = [{'A':0, 'T':0, 'G':0, 'C':0}]*M
# Deep Copy

count = [{'A':0, 'T':0, 'G':0, 'C':0} for _ in range(M)]
# Shallow Copy
복사<br>**lambda reverse**<br>ch_list = sorted(ch.items(), key=lambda x:x[1])
# 오름차순

ch_list = sorted(ch.items(), key=lambda x:-x[1])
# 내림차순
복사<br><br><br><br><br><br>DNA란 어떤 유전물질을 구성하는 분자이다. 이 DNA는 서로 다른 4가지의 뉴클레오티드로 이루어져 있다(Adenine, Thymine, Guanine, Cytosine). 우리는 어떤 DNA의 물질을 표현할 때, 이 DNA를 이루는 뉴클레오티드의 첫글자를 따서 표현한다. 만약에 Thymine-Adenine-Adenine-Cytosine-Thymine-Guanine-Cytosine-Cytosine-Guanine-Adenine-Thymine로 이루어진 DNA가 있다고 하면, “TAACTGCCGAT”로 표현할 수 있다. 그리고 Hamming Distance란 길이가 같은 두 DNA가 있을 때, 각 위치의 뉴클오티드 문자가 다른 것의 개수이다. 만약에 “AGCAT"와 ”GGAAT"는 첫 번째 글자와 세 번째 글자가 다르므로 Hamming Distance는 2이다.<br>우리가 할 일은 다음과 같다. N개의 길이 M인 DNA s1, s2, ..., sn가 주어져 있을 때 Hamming Distance의 합이 가장 작은 DNA s를 구하는 것이다. 즉, s와 s1의 Hamming Distance + s와 s2의 Hamming Distance + s와 s3의 Hamming Distance ... 의 합이 최소가 된다는 의미이다.<br><br>첫 줄에 DNA의 수 N과 문자열의 길이 M이 주어진다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 DNA가 주어진다. N은 1,000보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다.<br><br>첫째 줄에 Hamming Distance의 합이 가장 작은 DNA 를 출력하고, 둘째 줄에는 그 Hamming Distance의 합을 출력하시오. 그러한 DNA가 여러 개 있을 때에는 사전순으로 가장 앞서는 것을 출력한다.<br><br>5 8
TATGATAC
TAAGCTAC
AAAGATCC
TGAGATAC
TAAGATGT

복사<br><br>TAAGATAC
7

복사<br><br>4 10
ACGTACGTAC
CCGTACGTAG
GCGTACGTAT
TCGTACGTAA

복사<br><br>ACGTACGTAA
6

복사<br><br>6 10
ATGTTACCAT
AAGTTACGAT
AACAAAGCAA
AAGTTACCTT
AAGTTACCAA
TACTTACCAA

복사<br><br>AAGTTACCAA
12

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/1" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/1" target="_blank">ICPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/7" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/7" target="_blank">Regionals</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/42" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/42" target="_blank">Asia Pacific</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/211" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/211" target="_blank">Korea</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/1066" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/1066" target="_blank">Asia Regional - Seoul 2006</a>&nbsp;B번<br>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jsa3824" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jsa3824" target="_blank">jsa3824</a>
<br>잘못된 번역을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/previc1" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/previc1" target="_blank">previc1</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/sohnjunior" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/sohnjunior" target="_blank">sohnjunior</a>
<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/tncks0121" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/tncks0121" target="_blank">tncks0121</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>
<br>
그 자리의 것들만 비교

<br>
4가지 종류 반복

<br>
그냥 최빈값들로다가…

<br>
dict 써서,

<br>
deep copy

<br>count = [{'A':0, 'T':0, 'G':0, 'C':0}]*M
# Deep Copy

count = [{'A':0, 'T':0, 'G':0, 'C':0} for _ in range(M)]
# Shallow Copy
복사<br>
<br>lambda reverse(오름 → 내림)
<br>ch_list = sorted(ch.items(), key=lambda x:x[1])
# 오름차순

ch_list = sorted(ch.items(), key=lambda x:-x[1])
# 내림차순
복사<br><br>import sys

def solution():
    N,M = map(int, sys.stdin.readline().rstrip().split())
    count = [{'A':0, 'C':0, 'G':0, 'T':0} for _ in range(M)]
    result = ""
    sum = 0

    for i in range(N):
        line = sys.stdin.readline().rstrip()
        for j in range(M):
            if count[j].get(line[j]) == None:
                count[j][line[j]] = 1
            else:
                count[j][line[j]] += 1

    for ch in count:
        ch_list = sorted(ch.items(), key=lambda x:-x[1])
        result += ch_list[0][0]
        sum += (ch_list[1][1] + ch_list[2][1] + ch_list[3][1])
        print(ch_list)

    print(result)
    print(sum)

if __name__ =="__main__":
    solution()
복사<br><br><br>@pubhan35

def find_min_dna():
    neucleotide, haming_distance, final_dna = 'ACGT', 0, ''
    element = {alp: 0 for alp in neucleotide}
    for j in range(M):
        each_cnt, each_key = 0, ''
        for i in range(N):
            element[dna_list[i][j]] += 1
        for key in neucleotide:
            if element[key] &gt; each_cnt:
                each_cnt, each_key = element[key], key
            element[key] = 0
        final_dna += each_key
        haming_distance += (N - each_cnt)
        
    print(final_dna, haming_distance, sep='\n')

import sys
new_input = sys.stdin.readline
N, M = map(int, new_input().split())
dna_list = [new_input().rstrip() for _ in range(N)]
find_min_dna()
복사<br>
<br>변수명 깔끔.

<br>알파벳은 alp로…


<br>2차원 data 접근

<br>나는 row → colum순으로 접근만 가능하다고 착각하고 있었는데,
<br>위에 코드 처럼 col을 고정하고 row를 돌리는 것도 간단하게 가능.

<br>그렇게 해서 한 col 끝나면 바로 그 줄에 대한 결과 뽑아내고..




]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/dna.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/DNA.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[N과 M(1)]]></title><description><![CDATA[ 
 <br><br>ID: 15649<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/15649" target="_blank">https://www.acmicpc.net/problem/15649</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
생성 일시: 2023년 9월 3일 오후 6:19<br><br><br><br><br>자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.<br>
<br>1부터 N까지&nbsp;자연수 중에서 중복 없이 M개를 고른 수열
<br><br>첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)<br><br>한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.<br>수열은 사전 순으로 증가하는 순서로 출력해야 한다.<br><br>3 1

복사<br><br>1
2
3

복사<br><br>4 2

복사<br><br>1 2
1 3
1 4
2 1
2 3
2 4
3 1
3 2
3 4
4 1
4 2
4 3

복사<br><br>4 4

복사<br><br>1 2 3 4
1 2 4 3
1 3 2 4
1 3 4 2
1 4 2 3
1 4 3 2
2 1 3 4
2 1 4 3
2 3 1 4
2 3 4 1
2 4 1 3
2 4 3 1
3 1 2 4
3 1 4 2
3 2 1 4
3 2 4 1
3 4 1 2
3 4 2 1
4 1 2 3
4 1 3 2
4 2 1 3
4 2 3 1
4 3 1 2
4 3 2 1

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br><br>
<br>모든 경우의 수 구하기는 BFS → level 1, 2, 3,…
<br>다른말로 backtracking (사용한 node 만나면 뒤로가기) → pop으로 구
<br>복사<br><br>import sys

def n_m():
    def recursive(result):
        for i in range(n):
            if len(result) == m:
                print(" ".join(result))
                break
            if str(i+1) not in result:
                result.append(str(i+1))
                recursive(result)
        if len(result) != 0:
            result.pop()
            return ""

    n, m = map(int, sys.stdin.readline().rstrip().split())
    recursive([])

if __name__ == "__main__":
    n_m()
복사<br><br>from itertools import permutations
N,M = map(int, input().split(' '))
print('\n'.join(list(map(' '.join, permutations(map(str, range(1, N+1)), M)))))
복사<br>
<br>
그냥 조합을 구해주는 함수를 사용해도됨ㅋㅋㅋㅋ

<br>
itertools permutations, combinations 등

<br>
그리고 아, 굳이 result를 안넘겨 줘도 되는 구나… 같은 list 중복해서 쓰는 줄 알았는데, 차피 pop을 하게 되니까 괜찬은 건가?

<br>
아 그리고 잠시만,,, bfs → stack으로 구현가능ㅋㅋㅋㅋㅋ → 아니다 이건 트리라서 좀 다른 거 같음.

<br>n, m = list(map(int, input().split()))
s = []
li=[]
def dfs():
    if len(s) == m:
        li.append(s)
        return
    for i in range(1,n+1):
        if i not in s:
            s.append(i)
            dfs()
            s.pop()
dfs()
print(li)
복사<br>
<br>나는 for문 밖에서 pop을 하니까, 길이가 0일때 생기는 문제가 있었는데, 그냥 (전단계, 레벨로) 돌아와서 바로 pop하면 되는구나..
<br>그리고 프린트 한번에 하기.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/n과-m(1).html</link><guid isPermaLink="false">1. Study/Coding Test/PS/N과 M(1).md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[ATM]]></title><description><![CDATA[ 
 <br><br>ID: 11399<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/11399" target="_blank">https://www.acmicpc.net/problem/11399</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 그리디 알고리즘, 정렬<br>
생성 일시: 2023년 8월 7일 오후 10:21<br><br>
💡 **input을 int의 list로 받을 때 깔끔하게 쓰는 법**<br>P = list(map(int,sys.stdin.readline().split()))
복사<br><br><br><br><br>인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번&nbsp;사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.<br>사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1&nbsp;= 3, P2&nbsp;= 1, P3&nbsp;= 4, P4&nbsp;= 3, P5&nbsp;= 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.<br>줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.<br>줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi&nbsp;≤ 1,000)<br><br>첫째 줄에&nbsp;각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.<br><br>5
3 1 4 3 2

복사<br><br>32

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/hakgb11" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/hakgb11" target="_blank">hakgb11</a>
<br><br>복사<br><br>import sys

def atm():
    N = int(sys.stdin.readline().rstrip())
    P = list(map(int,sys.stdin.readline().split()))
    time = 0

    P.sort()

    for i in range(N):
        time += P[i]*(N-i)

    print(time)

if __name__ == "__main__":
    atm()
복사<br><br>P = list(map(int,sys.stdin.readline().split()))
복사<br>
<br>input을 int의 list로 받을 때 깔끔하게 쓰는 법
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/atm.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/ATM.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[99 club 2기 코테 문제 정리]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br><br>
<br>비기너: 폰켓몬 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/1845" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/1845</a>)
<br>미들러: 전화번호 목록 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42577" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42577</a>)
<br>챌린저: 베스트앨범 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42579" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42579</a>)
<br><br>
<br>비기너: 완주하지 못한 선수 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42576" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42576</a>)
<br>미들러: 의상 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42578" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42578</a>)
<br>챌린저: 비슷한 단어 (<a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2179" target="_blank">https://www.acmicpc.net/problem/2179</a>)
<br><br>
<br>비기너: 같은 숫자는 싫어(<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/12906" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/12906</a>)
<br>미들러: 기능개발 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42586" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42586</a>)
<br>챌린저: 다리를 지나는 트럭 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42583" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42583</a>)
<br><br>
<br>비기너: Valid Parentheses (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank">https://leetcode.com/problems/valid-parentheses/description/</a>)
<br>미들러: 올바른 괄호 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/12909/" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/12909/</a>)
<br>챌린저: 주식 가격 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42584" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42584</a>)
<br><br>
<br>비기너: Minimum Number Game(<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/minimum-number-game/description/" target="_blank">https://leetcode.com/problems/minimum-number-game/description/</a>)
<br>미들러: 더 맵게 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42626" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42626</a>)
<br>챌린저: 디스크 컨트롤러 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42627" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42627</a>)
<br><br>
<br>비기너: Maximum Product of Two Elements in an array (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/smallest-number-in-infinite-set/description/" target="_blank">https://leetcode.com/problems/smallest-number-in-infinite-set/description/</a>)
<br>미들러: smallest-number-in-infinite-set (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/smallest-number-in-infinite-set/description/" target="_blank">https://leetcode.com/problems/smallest-number-in-infinite-set/description/</a>)
<br>챌린저: 이중우선순위큐 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42628" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42628</a>)
<br><br>
<br>비기너: k번째 수 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42748" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42748</a>)
<br>미들러: 가장 큰 수 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42746" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42746</a>)
<br>챌린저: Put Marbles in Bags (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/put-marbles-in-bags/description/" target="_blank">https://leetcode.com/problems/put-marbles-in-bags/description/</a>)
<br><br>
<br>비기너: count-pairs-whose-sum-is-less-than-target (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/" target="_blank">https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/</a>)
<br>미들러: H 인덱스 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42747" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42747</a>)
<br>챌린저: orderly-queue (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/orderly-queue/description/" target="_blank">https://leetcode.com/problems/orderly-queue/description/</a>)
<br><br>
<br>비기너: 최소직사각형 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/86491" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/86491</a>)
<br>미들러: 카펫 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42842" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42842</a>)
<br>챌린저: 모음사전 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/84512" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/84512</a>)
<br><br>
<br>비기너: 모의고사 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42840" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42840</a>)
<br>미들러: 소수찾기 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42839" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42839</a>)
<br>챌린저: 전력망을 둘로 나누기 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/86971" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/86971</a>)
<br><br>
<br>비기너: Range sum of bst (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/range-sum-of-bst/" target="_blank">https://leetcode.com/problems/range-sum-of-bst/</a>)
<br>미들러: 타겟넘버 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/43165" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/43165</a>)
<br>챌린저: 퍼즐조각채우기 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/84021" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/84021</a>)
<br><br>
<br>비기너: Find a Corresponding Node of a Binary Tree in a Clone of That Tree (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/description/" target="_blank">https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/description/</a>)
<br>미들러: 게임 맵 최단거리 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/1844" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/1844</a>)
<br>챌린저: 여행경로(<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/43164" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/43164</a>)
<br><br>
<br>비기너: Invert-binary-tree (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/invert-binary-tree/" target="_blank">https://leetcode.com/problems/invert-binary-tree/</a>)
<br>미들러: All-paths-from-source-to-target (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/all-paths-from-source-to-target/description/" target="_blank">https://leetcode.com/problems/all-paths-from-source-to-target/description/</a>)
<br>챌린저: 단어변환 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/43163" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/43163</a>)
<br><br>
<br>비기너: Maximum-depth-of-binary-tree (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a>)
<br>미들러: Reverse Odd Levels of Binary Tree (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/description/" target="_blank">https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/description/</a>)
<br>챌린저: 네트워크(<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/43162" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/43162</a>)
<br><br>
<br>비기너: 체육복 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42862" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42862</a>)
<br>미들러: 조이스틱 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42860" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42860</a>)
<br>챌린저: 섬연결하기 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42861" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42861</a>)
<br><br>
<br>비기너: Split-a-string-in-balanced-strings (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/split-a-string-in-balanced-strings/description/" target="_blank">https://leetcode.com/problems/split-a-string-in-balanced-strings/description/</a>)
<br>미들러: 구명보트 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42885" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42885</a>)
<br>챌린저: 단속카메라(<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42884" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42884</a>)
<br><br>
<br>비기너: Counting-bits (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/counting-bits/" target="_blank">https://leetcode.com/problems/counting-bits/</a>)
<br>미들러: All-possible-full-binary-trees (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/all-possible-full-binary-trees/description/" target="_blank">https://leetcode.com/problems/all-possible-full-binary-trees/description/</a>)
<br>챌린저: N으로 표현 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42895" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42895</a>)
<br><br>
<br>비기너: pascals-triangle (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/pascals-triangle/description/" target="_blank">https://leetcode.com/problems/pascals-triangle/description/</a>)
<br>미들러: Count Sorted Vowel Strings (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/count-sorted-vowel-strings/description/" target="_blank">https://leetcode.com/problems/count-sorted-vowel-strings/description/</a>)
<br>챌린저: 정수 삼각형 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/43105" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/43105</a>)
<br><br>
<br>비기너: Fibonacci-number (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/fibonacci-number/description/" target="_blank">https://leetcode.com/problems/fibonacci-number/description/</a>)
<br>미들러: partition-array-for-maximum-sum (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/partition-array-for-maximum-sum/description/" target="_blank">https://leetcode.com/problems/partition-array-for-maximum-sum/description/</a>)
<br>챌린저: 사칙연산 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/1843" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/1843</a>)
<br><br>
<br>비기너: divisor-game (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/divisor-game/description/" target="_blank">https://leetcode.com/problems/divisor-game/description/</a>)
<br>미들러: Count Square Submatrices with All Ones (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/count-square-submatrices-with-all-ones/description/" target="_blank">https://leetcode.com/problems/count-square-submatrices-with-all-ones/description/</a>)
<br>챌린저: 도둑질 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42897" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42897</a>)
<br><br>
<br>비기너: Search Insert Position (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/search-insert-position/description/" target="_blank">https://leetcode.com/problems/search-insert-position/description/</a>)
<br>미들러: 입국심사 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/43238" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/43238</a>)
<br>챌린저: 징검다리(<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/43236" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/43236</a>)
<br><br>
<br>비기너: Count-negative-numbers-in-a-sorted-matrix (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description/" target="_blank">https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description/</a>)
<br>미들러: Capacity-to-ship-packages-within-d-days (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank">https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/</a>)
<br>챌린저: K-th-smallest-prime-fraction (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/k-th-smallest-prime-fraction/description/" target="_blank">https://leetcode.com/problems/k-th-smallest-prime-fraction/description/</a>)
<br><br>
<br>비기너: Find-center-of-star-graph (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/find-center-of-star-graph/description/" target="_blank">https://leetcode.com/problems/find-center-of-star-graph/description/</a>)
<br>미들러: 가장 먼 노드 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/49189" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/49189</a>)
<br>챌린저: 방의 개수 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/49190" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/49190</a>)
<br><br>
<br>비기너: Minimum Number of Moves to Seat Everyone (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/description/?envType=daily-question&amp;envId=2024-06-13" target="_blank">https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/description/?envType=daily-question&amp;envId=2024-06-13</a>)
<br>미들러: 순위 (<a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/49191" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/49191</a>)
<br>챌린저: Find-if-path-exists-in-graph (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/find-if-path-exists-in-graph/description/" target="_blank">https://leetcode.com/problems/find-if-path-exists-in-graph/description/</a>)
<br><br>
<br>비기너: shuffle-the-array (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/shuffle-the-array/description/" target="_blank">https://leetcode.com/problems/shuffle-the-array/description/</a>)
<br>미들러: subrectangle-queries (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/subrectangle-queries/description/" target="_blank">https://leetcode.com/problems/subrectangle-queries/description/</a> )
<br>챌린저: h-index-ii (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/h-index-ii/description/" target="_blank">https://leetcode.com/problems/h-index-ii/description/</a>)
<br><br>
<br>비기너: number-of-good-pairs (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/number-of-good-pairs/description/" target="_blank">https://leetcode.com/problems/number-of-good-pairs/description/</a>)
<br>미들러: find-the-original-array-of-prefix-xor (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/find-the-original-array-of-prefix-xor/description/" target="_blank">https://leetcode.com/problems/find-the-original-array-of-prefix-xor/description/</a>)
<br>챌린저: maximum-number-of-alloys (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/maximum-number-of-alloys/description/" target="_blank">https://leetcode.com/problems/maximum-number-of-alloys/description/</a>)
<br><br>
<br>비기너: find-words-containing-character (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/find-words-containing-character/description/" target="_blank">https://leetcode.com/problems/find-words-containing-character/description/</a>)
<br>미들러: group-the-people-given-the-group-size-they-belong-to (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/description/" target="_blank">https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/description/</a>)
<br>챌린저: count-the-hidden-sequences (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/count-the-hidden-sequences/description/" target="_blank">https://leetcode.com/problems/count-the-hidden-sequences/description/</a>)
<br><br>
<br>비기너:  count-items-matching-a-rule (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/count-items-matching-a-rule/description/" target="_blank">https://leetcode.com/problems/count-items-matching-a-rule/description/</a>)
<br>미들러: iterator-for-combination (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/iterator-for-combination/description/" target="_blank">https://leetcode.com/problems/iterator-for-combination/description/</a>)
<br>챌린저: next-greater-element-iii (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/next-greater-element-iii/description/" target="_blank">https://leetcode.com/problems/next-greater-element-iii/description/</a>)
<br><br>
<br>비기너: shuffle-string (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/shuffle-string/description/" target="_blank">https://leetcode.com/problems/shuffle-string/description/</a>)
<br>미들러: minimum-suffix-flips (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/minimum-suffix-flips/description/" target="_blank">https://leetcode.com/problems/minimum-suffix-flips/description/</a>)
<br>챌린저: longest-palindromic-substring (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/longest-palindromic-substring/description/" target="_blank">https://leetcode.com/problems/longest-palindromic-substring/description/</a>)
<br><br>
<br>비기너:  decode-the-message (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/decode-the-message/description/" target="_blank">https://leetcode.com/problems/decode-the-message/description/</a>)
<br>미들러: sort-characters-by-frequency (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/sort-characters-by-frequency/description/" target="_blank">https://leetcode.com/problems/sort-characters-by-frequency/description/</a>)
<br>챌린저: remove-k-digits (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/remove-k-digits/description/" target="_blank">https://leetcode.com/problems/remove-k-digits/description/</a>)
<br><br>
<br>비기너: neither-minimum-nor-maximum (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/neither-minimum-nor-maximum/description/" target="_blank">https://leetcode.com/problems/neither-minimum-nor-maximum/description/</a>)
<br>미들러: top-k-frequent-elements/ (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank">https://leetcode.com/problems/top-k-frequent-elements/description/</a>)
<br>챌린저: minimum-lines-to-represent-a-line-chart (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/description/" target="_blank">https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/description/</a>)
<br><br>
<br>비기너:  find-target-indices-after-sorting-array (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/find-target-indices-after-sorting-array/description/" target="_blank">https://leetcode.com/problems/find-target-indices-after-sorting-array/description/</a>)
<br>미들러: reordered-power-of-2 (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/reordered-power-of-2/description/" target="_blank">https://leetcode.com/problems/reordered-power-of-2/description/</a>)
<br>챌린저: append-k-integers-with-minimal-sum (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/append-k-integers-with-minimal-sum/description/" target="_blank">https://leetcode.com/problems/append-k-integers-with-minimal-sum/description/</a>)
<br><br>
<br>비기너: Number-of-students-unable-to-eat-lunch (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/description/" target="_blank">https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/description/</a>)
<br>미들러: find-the-winner-of-the-circular-game (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/find-the-winner-of-the-circular-game/description/" target="_blank">https://leetcode.com/problems/find-the-winner-of-the-circular-game/description/</a>)
<br>챌린저: minimum-number-of-coins-for-fruits (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/minimum-number-of-coins-for-fruits/description/" target="_blank">https://leetcode.com/problems/minimum-number-of-coins-for-fruits/description/</a>)
<br><br>
<br>비기너: number-of-recent-calls (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/number-of-recent-calls/" target="_blank">https://leetcode.com/problems/number-of-recent-calls/</a>)
<br>미들러: flatten-nested-list-iterator (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/flatten-nested-list-iterator/description/" target="_blank">https://leetcode.com/problems/flatten-nested-list-iterator/description/</a>)
<br>챌린저: continuous-subarrays (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/continuous-subarrays/description/" target="_blank">https://leetcode.com/problems/continuous-subarrays/description/</a>)
<br><br>
<br>비기너: final-prices-with-a-special-discount-in-a-shop (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/description/" target="_blank">https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/description/</a>)
<br>미들러: Removing-stars-from-a-string (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/removing-stars-from-a-string/description/" target="_blank">https://leetcode.com/problems/removing-stars-from-a-string/description/</a>)
<br>챌린저: Using-a-robot-to-print-the-lexicographically-smallest-string (<a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/usin" target="_blank">https://leetcode.com/problems/usin</a>...
<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/99-club-2기-코테-문제-정리.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/99 club 2기 코테 문제 정리.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 25 Jun 2024 03:27:42 GMT</pubDate></item><item><title><![CDATA[894. All Possible Full Binary Trees]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-06<br>Link: <a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/all-possible-full-binary-trees/description/" target="_blank">https://leetcode.com/problems/all-possible-full-binary-trees/description/</a><br>Level: Medium<br>Category: <br><a data-href="Dynamic Programming" href="https://sunha20.github.io/digital-garden/Dynamic Programming" class="internal-link" target="_self" rel="noopener nofollow">Dynamic Programming</a><br><a data-href="Tree" href="https://sunha20.github.io/digital-garden/Tree" class="internal-link" target="_self" rel="noopener nofollow">Tree</a><br>Success: ⭕<br>Git: -<br><br>Given an integer&nbsp;n, return&nbsp;a list of all possible&nbsp;full binary trees&nbsp;with&nbsp;n&nbsp;nodes. Each node of each tree in the answer must have&nbsp;Node.val == 0.<br>Each element of the answer is the root node of one possible tree. You may return the final list of trees in&nbsp;any order.<br>A&nbsp;full binary tree&nbsp;is a binary tree where each node has exactly&nbsp;0&nbsp;or&nbsp;2&nbsp;children.<br>Example 1:<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png" referrerpolicy="no-referrer"><br>Input: n = 7<br>
Output: <a data-href="0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0" href="https://sunha20.github.io/digital-garden/0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0" class="internal-link" target="_self" rel="noopener nofollow">0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0</a><br>Example 2:<br>Input: n = 3<br>
Output: <a data-href="0,0,0" href="https://sunha20.github.io/digital-garden/0,0,0" class="internal-link" target="_self" rel="noopener nofollow">0,0,0</a><br>Constraints:<br>
<br>1 &lt;= n &lt;= 20
<br><br>
<br>한참 헤메다가 쓰는 코드 자체에서 재귀를 하면 좋겠다는 생각.
<br>이번 문제는 재귀가 반복문보다 깔끔하게 느껴짐…
<br>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&lt;TreeNode&gt; allPossibleFBT(int n) {
        // root of (sub)tree
        TreeNode root = new TreeNode(0);
        n -= 1;
        List&lt;TreeNode&gt; trees = new ArrayList&lt;&gt;();
        // return when it is edge.      
        if(n == 0) {
            trees.add(root);
            return trees;
        }
  
        // children of root
        for (int i = 1; i &lt;= n-1; i+=2) {
            TreeNode newRoot = copyTreeNode(root);
            List&lt;TreeNode&gt; left = allPossibleFBT(i);
            List&lt;TreeNode&gt; right = allPossibleFBT(n-i);
            for (TreeNode l:left) {
                newRoot.left = l;
                for (TreeNode r:right) {
                    newRoot.right = r;
                    trees.add(newRoot);
                }
            }
        }
        return trees;
    }
  
        private TreeNode copyTreeNode(TreeNode node) {
        TreeNode newNode = new TreeNode(0);
        if (node.left != null) {
            newNode.left = copyTreeNode(node.left);
        }
        if (node.right != null) {
            newNode.right = copyTreeNode(node.right);
       }
        return newNode;
    }
}
복사<br>
<br>중간에 잘못이해 → TreeNode를 새로 생성해주는 순간을 헷갈림. + 굳이 copy 할 필요도 없음. 이때 만들어진 node는 아직 자식 요소가 하나도 없잖아… 이제 연결해줘야할뿐.
<br><br>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&lt;TreeNode&gt; allPossibleFBT(int n) {
        // root of (sub)tree / return List
        n -= 1;
        List&lt;TreeNode&gt; trees = new ArrayList&lt;&gt;();
        // return when it is edge.      
        if(n == 0) {
            trees.add(new TreeNode(0));
            return trees;
        }
  
        // children of root
        for (int i = 1; i &lt;= n-1; i+=2) {
            List&lt;TreeNode&gt; left = allPossibleFBT(i);
            List&lt;TreeNode&gt; right = allPossibleFBT(n-i);
            for (TreeNode l:left) {
                for (TreeNode r:right) {
                    TreeNode newRoot = new TreeNode(0);
                    newRoot.left = l;
                    newRoot.right = r;
                    trees.add(newRoot);
                }
            }
        }
        return trees;
    }
}
복사<br>
<br>
시간 3ms 더 줄일 수 있을 것 같은데.

<br>
아 우와 진짜 dp로 하려면, n에 따른 tree를 기억하고 있어야겠구나! → map사용해서 dp 구현

<br><br>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
  
import java.util.*;
class Solution {
    public List&lt;TreeNode&gt; allPossibleFBT(int n) {
        Map&lt;Integer, List&lt;TreeNode&gt;&gt; map = new HashMap&lt;&gt;();
        return solve(n, map);
    }
  
    public List&lt;TreeNode&gt; solve(int n, Map&lt;Integer, List&lt;TreeNode&gt;&gt; map){
        // root of (sub)tree / return List
        n -= 1;
        List&lt;TreeNode&gt; trees = new ArrayList&lt;&gt;();
        // return when it is edge.      
        if(n == 0) {
            trees.add(new TreeNode(0));
            return trees;
        }
        if (map.containsKey(n)) {
            return map.get(n);
        }
  
        // children of root
        for (int i = 1; i &lt;= n-1; i+=2) {
            List&lt;TreeNode&gt; left = solve(i, map);
            List&lt;TreeNode&gt; right = solve(n-i, map);
            for (TreeNode l:left) {
                for (TreeNode r:right) {
                    TreeNode newRoot = new TreeNode(0);
                    newRoot.left = l;
                    newRoot.right = r;
                    trees.add(newRoot);
                }
            }
        }
        map.put(n, trees);
        return trees;
    }
}
복사<br>
<br>1ms
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/894.-all-possible-full-binary-trees.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/894. All Possible Full Binary Trees.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Thu, 06 Jun 2024 08:05:51 GMT</pubDate><enclosure url="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[42860. 조이스틱]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-04<br>Link: <a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42860" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42860</a><br>Level: lv2<br>Category: greedy<br>Success: -<br>Git: -<br><br><br>조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.<br>
ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA<br>조이스틱을 각 방향으로 움직이면 아래와 같습니다.<br>▲ - 다음 알파벳
▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)
◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
▶ - 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 이동하면 첫 번째 문자에 커서)
복사<br>예를 들어 아래의 방법으로 "JAZ"를 만들 수 있습니다.<br>- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.
- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.
- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.
따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.
복사<br>만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.<br><br>
<br>name은 알파벳 대문자로만 이루어져 있습니다.
<br>name의 길이는 1 이상 20 이하입니다.
<br><br><br><br><br>/**
 * 그냥 차례대로...
 */
class Solution {
    public int solution(String name) {
        int row_cnt = name.length() -1;
        int col_cnt = 0;
        for (int i=0; i&lt;name.length(); i++) {
            col_cnt += Math.min(91 - ((int) name.charAt(i)), ((int) name.charAt(i)) - 65);
            System.out.println(Math.min(91 - ((int) name.charAt(i)), ((int) name.charAt(i)) - 65));
        }
        return row_cnt + col_cnt;
    }
}
복사<br>
<br>이렇게 작성하는 코드가 더 간단해보여서 좌우로 커서 움직이는 걸 그냥 name 길이로 넣어줬는데, 이러면 뒤에 굳이 안바꿔도 되는 문자열이 위치했을 때 문제가 생김.
<br>좌우움직임을 안 신경씀…
<br><br>/**
 * 그냥 차례대로...
 */
class Solution {
    public int solution(String name) {
        int row_min = name.length();
        int row_max = 0;
        int col_cnt = 0;        
        
        for (int i=0; i&lt;name.length(); i++) {
            int ascii = (int) name.charAt(i);
            // col
            col_cnt += Math.min(91 - ascii, ascii - 65);
            // row
            if (i != 0 &amp;&amp; ascii != 65) {
                if (row_min &gt; i) row_min = i;
                if (row_max &lt; i) row_max = i;
            }
        }
        int answer = col_cnt + Math.min(name.length() - row_min, row_max);
        return answer;
    }
}
복사<br>
<br>반례:|"BBABAAAABBBAAAABABB" 〉 26|  //27 출력
<br>어머. 시작 위치를 마음대로 할 수 있는건가? → 아님
<br>/**
 * 그냥 차례대로...
 */
class Solution {
    public int solution(String name) {
        // initial state
        int len = name.length();
        int rowL = 0;       // 왼쪽으로 갔을 때 가장 끝 인덱스 (오른쪽에서 가장 가까운 변할 문자)
        int rowR = 0;       // 오른쪽으로 갔을 때 가장 끝 인덱스 (왼쪽에서 가장 가까운 변할 문자)
        for (int i=len-1; i &gt;= 0; i--) {
            if (name.charAt(i) != 'A') {
                rowR = i-len;
                break;
            }
        }
        
        System.out.println("init: " + rowL +", " + rowR);
        int row_cnt = len;
        int col_cnt = 0; 
        
        for (int i=0; i&lt;len; i++) {
            int ascii = (int) name.charAt(i);
                       
            // col
            col_cnt += Math.min(91 - ascii, ascii - 65);
            System.out.println(Math.min(91 - ascii, ascii - 65));
            
            // row
            //// check rowL for now
            if (rowL%len &lt;= i) {
                for (int j=i+1; j&lt;i+len; j++) {
                    int idx = j% len;
                    if (name.charAt(idx) != 'A') {
                        rowL = j;
                        break;
                    }
                }
            }
            
            //// min value of row
            int distanceToR = len + rowR - i;
            int distanceToL = i + len -rowL;
            int rowMin = Math.min(distanceToR, distanceToL);
            if (rowMin &lt; row_cnt) row_cnt = rowMin;
            System.out.println("point: " + rowR + " | " + rowL);
            System.out.println("distance: "+distanceToR + " | " + distanceToL);
            System.out.println();
            
            //// check rowR for next
            if (ascii != 65) rowR = i;
        }
    return col_cnt + row_cnt;
    }
}
복사<br>
<br>
완전 잘못이해 했어요… 시작은 0에서 왔다리 갔다리를 할 수 있는 거였을 뿐임.

<br>
경우의 수가

<br>왼쪽으로만 가는 경우
<br>오른쪽으로만 가능 경우
<br>(짧은) 오른쪽 다녀와서 왼쪽으로 가는 경우
<br>(짧은) 왼쪽 다녀와서 오른쪽으로 가능 경우


<br>
구체적인 수치…

<br>다 구해서 비교..?
<br>관점을 ‘나눠지는 부분’에 두는 게 좋을 듯.

<br>ABAAAABB 

<br>오왼왼왼
<br>오오오오오오오


<br>ABAAABBA

<br>오왼왼왼왼
<br>오오오오오오


<br>→ A가 있는 곳에서 나누어짐


<br>+) 시작이 A와 접해있는지. → 한쪽방향으로만 이동해도 범위가 줄어들 가능성이 큼.
<br>반대의 경우에는 한쪽방향으로만 이동하면 이동범위가 줄어들 수 없음


<br>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/42860.-조이스틱.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/42860. 조이스틱.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Wed, 05 Jun 2024 04:08:52 GMT</pubDate></item><item><title><![CDATA[84512. 모음사전]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-04-20<br>Link: <a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/84512" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/84512</a><br>Level: lv2<br>Category: <a data-href="Search" href="https://sunha20.github.io/digital-garden/Search" class="internal-link" target="_self" rel="noopener nofollow">Search</a><br>Success: <br>Git: -<br><br><br>사전에 알파벳 모음 'A', 'E', 'I', 'O', 'U'만을 사용하여 만들 수 있는, 길이 5 이하의 모든 단어가 수록되어 있습니다. 사전에서 첫 번째 단어는 "A"이고, 그다음은 "AA"이며, 마지막 단어는 "UUUUU"입니다.<br>단어 하나 word가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째 단어인지 return 하도록 solution 함수를 완성해주세요.<br><br>
<br>word의 길이는 1 이상 5 이하입니다.
<br>word는 알파벳 대문자 'A', 'E', 'I', 'O', 'U'로만 이루어져 있습니다.
<br><br><br><br><br>입출력 예 #1<br>사전에서 첫 번째 단어는 "A"이고, 그다음은 "AA", "AAA", "AAAA", "AAAAA", "AAAAE", ... 와 같습니다. "AAAAE"는 사전에서 6번째 단어입니다.<br>입출력 예 #2<br>"AAAE"는 "A", "AA", "AAA", "AAAA", "AAAAA", "AAAAE", "AAAAI", "AAAAO", "AAAAU"의 다음인 10번째 단어입니다.<br>입출력 예 #3<br>"I"는 1563번째 단어입니다.<br>입출력 예 #4<br>"EIO"는 1189번째 단어입니다.<br><br>
<br>
만들고 탐색하거나….

<br>
이건 tree인데… 깊이 우선 탐색<br>
tree<br>
root<br>
a e i o u<br>
a e i o u<br>
…

<br>
근데 다 탐색 안하고 level 별로 자식 개수가 정해져 있으니까, 그냥 그거 더하면 안되나?

]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/84512.-모음사전.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/84512. 모음사전.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 28 May 2024 02:50:31 GMT</pubDate></item><item><title><![CDATA[49191. 순위]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-13<br>Link: <a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/49191" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/49191</a><br>Level: lv3<br>Category: <br><a data-href="Graph" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/graph/graph.html" class="internal-link" target="_self" rel="noopener nofollow">Graph</a><br>Success: ⭕<br>Git: -<br><br><br>n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.<br>선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.<br><br>
<br>선수의 수는 1명 이상 100명 이하입니다.
<br>경기 결과는 1개 이상 4,500개 이하입니다.
<br>results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다.
<br>모든 경기 결과에는 모순이 없습니다.
<br><br><br><br>2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다.<br>
5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.<br><br><br>
<br>내가 모르는 알고리즘임. 구글링 → <a data-tooltip-position="top" aria-label="https://chanhuiseok.github.io/posts/algo-50/" rel="noopener nofollow" class="external-link" href="https://chanhuiseok.github.io/posts/algo-50/" target="_blank">플로이드 - 워</a>
<br><br>class Solution {
    public int solution(int n, int[][] results) {
        int answer = 0;
        int[][] rank = new int[n][n];
        
        for (int[] r: results) {            // 초기 배열
            rank[r[0]-1][r[1]-1] = 1;       // 이겼을때
            rank[r[1]-1][r[0]-1] = -1;      // 졌을때
        }
        
        for (int k=0; k&lt;n; k++) {           // k = 중간노드 역할   
            for (int i=0; i&lt;n; i++) {
                for (int j=0; j&lt;n; j++) {
                    if (rank[i][k]==-1 &amp;&amp; rank[k][j]==-1) {
                        // i는 k한테 졌고, k는 j한테 졌을 때 =&gt; i&lt;k&lt;j = i&lt;j
                        rank[i][j] = -1;
                        rank[j][i] = 1;
                    }
                }
            }
        }
        
        for (int i=0; i&lt;n; i++) {
            int zero = 1;
            // 자기자신과의 승률만 0인 경우 해당 player의 순위를 명확히 알 수 있음
            for (int j=0; j&lt;n; j++) {
                if (rank[i][j] == 0) zero -= 1;
            }
            if (zero == 0) answer += 1;
        }
        
        return answer;
    }
}
복사<br>
<br>처음에는 1,1일 때 1지정 -1,-1일때 -1 지정 따로해주려고 했지만, 생각해보니 그럴 필요없음… 이긴쪽(1) 반대편이 무조건 진쪽(-1)이니까
<br>정확하게 순위를 매길 수 있는 선수의 수 = rank 배열이 다 찼을때.
<br>+) 위상정렬?<br>+) bfs, dfs는 사실 같음.. 재귀로 푸냐, 큐로 푸냐.. / 재귀로 푸는(dfs)는 안되는 문제들도 있음..<br>
bfs가 제일간단하고 빠르고 대중적…]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/49191.-순위.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/49191. 순위.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Thu, 13 Jun 2024 13:54:27 GMT</pubDate></item><item><title><![CDATA[43165. 타겟넘버]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-05-31<br>Link: <a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/43165" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/43165</a><br>Level: lv2<br>Category: <a data-href="BFS, DFS" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/graph/bfs,-dfs.html" class="internal-link" target="_self" rel="noopener nofollow">BFS, DFS</a><br>Success: ⭕<br>Git: -<br><br><br>n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.<br>-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
복사<br>사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.<br><br>
<br>주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
<br>각 숫자는 1 이상 50 이하인 자연수입니다.
<br>타겟 넘버는 1 이상 1000 이하인 자연수입니다.
<br><br><br><br>입출력 예 #1<br>문제 예시와 같습니다.<br>입출력 예 #2<br>+4+1-2+1 = 4
+4-1+2-1 = 4
복사<br>
<br>총 2가지 방법이 있으므로, 2를 return 합니다.
<br><br><br>
<br>특정 알고리즘을 사용한다기보단, 문제 해결에 초점을 맞추는 게 더 효율적일 때도 있음.
<br>파라미터로 넘기기 귀찮아서 전역변수를 종종 썼었는데 좋지 않은 습관임 (<a data-tooltip-position="top" aria-label="https://jaehoney.tistory.com/75" rel="noopener nofollow" class="external-link" href="https://jaehoney.tistory.com/75" target="_blank">참고</a>)
<br>class Solution {
    
    public int solution(int[] numbers, int target) {
        int idx = 0;
        int cnt = checkTarget(numbers, target, 0, 0);
        return cnt;
    }
    
    private int checkTarget(int [] numbers, int target, int idx, int num) {
        if (idx == numbers.length) {
            if (num == target) return 1;
            else return 0;
        }
        
        return checkTarget(numbers, target, idx+1, num+numbers[idx]) + checkTarget(numbers, target, idx+1, num-numbers[idx]);
    }
}
복사<br>
<br>파라미터가 많을 때는 여기서 기본적인 실수를 많이 함… 잘 체크하기.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/43165.-타겟넘버.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/43165. 타겟넘버.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 31 May 2024 02:11:57 GMT</pubDate></item><item><title><![CDATA[42885. 구명보트]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-05<br>Link: <a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42885" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42885</a><br>Level: lv2<br>Category: greedy<br>Success: ⭕<br>Git: -<br><br><br>무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대&nbsp;2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.<br>예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.<br>구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.<br>사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.<br><br>
<br>무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.
<br>각 사람의 몸무게는 40kg 이상 240kg 이하입니다.
<br>구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.
<br>구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.
<br><br><br><br><br><br>import java.util.*;

class Solution {
    public int solution(int[] people, int limit) {
        int answer = 0;
        
        Arrays.sort(people);
        int ir = 0;
        for (int i=people.length-1; i&gt;=0; i--) {
            // 가장 많이 가져가는 걸 일단 목표로 해보자.
            int inBoat = people[i];
            while (inBoat &lt;= limit) {
                int possible = limit - inBoat;
                
                if (people[ir] &lt;= possible) {
                    inBoat += people[ir];
                    ir += 1;
                    continue;
                } 
                break;
            }
            answer += 1;
            System.out.println(inBoat);
            if (ir &gt;= i) {
                break;
            }
        }
        return answer;
    }
}
복사<br>
<br>
후반부 문제들 다 틀림 → 런타임 에러

<br>
시간 부족도 해결해야 함

<br>
아놔… 2명씩 밖에 탈 수 없고 라네…

<br><br>import java.util.*;

class Solution {
    public int solution(int[] people, int limit) {
        int answer = 0;
        
        Arrays.sort(people);
        int ir = 0;
        for (int i=people.length-1; i&gt;=0; i--) {
            // 사용한 건 -1fh qkRnrl
            // 가장 많이 가져가는 걸 일단 목표로 해보자.
            int inBoat = people[i];
            int possible = limit - inBoat;
            if (possible &gt;= people[ir]) {
                ir += 1;
            }
            answer += 1;
            if (ir &gt;= i) {
                break;
            }
        }
        return answer;
    }
}

복사<br><br>
<br>Q: 문제 풀이 아이디어가<br>
(1) 가장 무거운 사람 + (추가로 태울 수 있다면) 가장 가벼운 사람인데..<br>
저는 (2) 가장 무거운 사람 + 추가로 태울 수 있는 사람 중 가장 무거운 사람<br>
이 정답일 거라고 생각했거든요 ((2)도 효율성 제외하면 테케가 다 맞긴 합니다)<br>
(1)이 왜 정답인지 직관적으로 이해가 잘 되지 않습니다<br>
혹시 이유를 설명해주실 분 계실까요<br>

<br>A: 저도 그렇게 생각했다가, 어차피 한 배에 두 명 밖에 못태우기 때문에 꼭 두번째 무거운 사람을 뽑아야 할 이유가 없기 때문에 구현이 간단한 (1)번 아이디어로 한다고 생각했어요.<br>
예를 들어 [40,30,20,10]의 무게 사람이 있고 보트의 최대 무게가 70인 상황을 가정했을때, 40과 같이 태울 사람을 뽑을때 두번째로 무거운 30을 뽑아도 어차피 가벼운 사람 [20, 10] 두명이서 두 번째 보트를 타야하기 때문에 처음에 뽑을 때 굳이 가벼운 사람을 아껴둘 필요가 없다.(?) 라고 생각했어요.<br>
만약에 보트 당 탈 수 있는 사람 수에 제한이 없으면, 공간을 처음부터 최대한 빡빡히 넣어서 두번째 보트를 꾸릴때 더 많은 명수를 넣을 수 있다는 이득을 취할 수 있기 때문에 (2)번 아이디어로 풀어야 하겠죠.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/42885.-구명보트.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/42885. 구명보트.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Thu, 06 Jun 2024 06:24:49 GMT</pubDate></item><item><title><![CDATA[42747. H-Index]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-05-27<br>Link: <a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42747" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42747</a><br>Level: lv2<br>Category: <a data-href="Sort" href="https://sunha20.github.io/digital-garden/Sort" class="internal-link" target="_self" rel="noopener nofollow">Sort</a><br>Success: <br>Git: -<br><br>H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과<a data-tooltip-position="top" aria-label="https://school.programmers.co.kr/learn/courses/30/lessons/42747#fn1" rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42747#fn1" target="_blank">1</a>에 따르면, H-Index는 다음과 같이 구합니다.<br>어떤 과학자가 발표한 논문&nbsp;n편 중,&nbsp;h번 이상 인용된 논문이&nbsp;h편 이상이고 나머지 논문이 h번 이하 인용되었다면&nbsp;h의 최댓값이 이 과학자의 H-Index입니다.<br>어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.<br><br>
<br>과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.
<br>논문별 인용 횟수는 0회 이상 10,000회 이하입니다.
<br><br><br><br>이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다.<br><br>힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! →&nbsp;<a data-tooltip-position="top" aria-label="https://school.programmers.co.kr/learn/courses/14743?itm_content=lesson42747" rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/14743?itm_content=lesson42747" target="_blank">클릭</a><br>※ 공지 - 2019년 2월 28일 테스트 케이스가 추가되었습니다.<br><br><br>
<br>Arrays.sort(citations, Collections.reverseOrder()); 사용 불가 primitive type이라 comparator가 없음.
<br>Arrays.sort() vs Collections.sort()

<br><a data-tooltip-position="top" aria-label="https://velog.io/@minizero0/Arrays.sort%EC%99%80-Collections.sort" rel="noopener nofollow" class="external-link" href="https://velog.io/@minizero0/Arrays.sort%EC%99%80-Collections.sort" target="_blank">Arrays.sort()와 Collections.sort()</a>


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/42747.-h-index.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/42747. H-Index.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 31 May 2024 01:52:49 GMT</pubDate></item><item><title><![CDATA[42839. 소수 찾기]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-05-29<br>Link: <a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42839" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42839</a><br>Level: lv2<br>Category: <a data-href="Search" href="https://sunha20.github.io/digital-garden/Search" class="internal-link" target="_self" rel="noopener nofollow">Search</a><br>Success: -<br>Git: -<br><br><br>한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.<br>각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.<br><br>
<br>numbers는 길이 1 이상 7 이하인 문자열입니다.
<br>numbers는 0~9까지 숫자만으로 이루어져 있습니다.
<br>"013"은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.
<br><br><br><br>예제 #1<br>
[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다.<br>예제 #2<br>
[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다.<br>
<br>11과 011은 같은 숫자로 취급합니다.
<br><br><br>
<br>다 만들고 체크…. 해도 되려나?
<br>만들기는 몇중 for문을 해야하는 거야? → 굳이 만들고 다시 돌릴 필요 없을 듯.
<br>중복 체크

<br>11 == 011 → int로 바꾸면 될일.
<br>정렬해두고 앞이랑 같으면 탐색하지 않고 넘어가는 걸로.


<br>소수 판별: java의 isPrime() 함수…! (있는지 몰랐다… 파이썬은 없었던거 같은데…)
<br>소수 판변부분이 간단하니까 그냥 바로바로 체크해서 넘어가도 될듯.
<br>int cnt = 0;
int loop = numbers.length;
private void countPrime (int[] numList, String offset){
	private int[] newNumList = new int[];
	for (int num : numList) {
		if (num.isPrime()) cnt += 1;
		for(String o : offset) {
			newNumList.push(num*10 +o);
		}
	}
	
	if (loop != 0) countPrime(newNumList, offset);
	else return;
}

복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/42839.-소수-찾기.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/42839. 소수 찾기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 31 May 2024 01:51:35 GMT</pubDate></item><item><title><![CDATA[2336. Smallest Number in Infinite Set]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:질문/코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#질문/코딩테스트</a> 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-05-25<br>Link: <a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/smallest-number-in-infinite-set/description/" target="_blank">https://leetcode.com/problems/smallest-number-in-infinite-set/description/</a><br>Category: <a data-href="heap (Priority Queue)" href="https://sunha20.github.io/digital-garden/heap (Priority Queue)" class="internal-link" target="_self" rel="noopener nofollow">heap (Priority Queue)</a><br>Level: Medium<br>Success: ⭕ +a<br>Git: <br>추가로 해볼 것:<br>
<br><br>
<br>처음에 1000개 들어가 배열 사용하지 않는 것도 방법일듯…! 
<br><br>You have a set which contains all positive integers&nbsp;[1, 2, 3, 4, 5, ...].<br>Implement the&nbsp;SmallestInfiniteSet&nbsp;class:<br>
<br>SmallestInfiniteSet()&nbsp;Initializes the&nbsp;SmallestInfiniteSet&nbsp;object to contain&nbsp;all&nbsp;positive integers.
<br>int popSmallest()&nbsp;Removes&nbsp;and returns the smallest integer contained in the infinite set.
<br>void addBack(int num)&nbsp;Adds&nbsp;a positive integer&nbsp;num&nbsp;back into the infinite set, if it is&nbsp;not&nbsp;already in the infinite set.
<br>Example 1:<br>**Input**
["SmallestInfiniteSet", "addBack", "popSmallest", "popSmallest", "popSmallest", "addBack", "popSmallest", "popSmallest", "popSmallest"]
[[], [2], [], [], [], [1], [], [], []]
**Output**
[null, null, 1, 2, 3, null, 1, 4, 5]
복사<br>Explanation<br>
SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();<br>
smallestInfiniteSet.addBack(2);    // 2 is already in the set, so no change is made.<br>
smallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set.<br>
smallestInfiniteSet.popSmallest(); // return 2, and remove it from the set.<br>
smallestInfiniteSet.popSmallest(); // return 3, and remove it from the set.<br>
smallestInfiniteSet.addBack(1);    // 1 is added back to the set.<br>
smallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and<br>
// is the smallest number, and remove it from the set.<br>
smallestInfiniteSet.popSmallest(); // return 4, and remove it from the set.<br>
smallestInfiniteSet.popSmallest(); // return 5, and remove it from the set.<br>Constraints:<br>
<br>1 &lt;= num &lt;= 1000
<br>At most&nbsp;1000&nbsp;calls will be made&nbsp;in total&nbsp;to&nbsp;popSmallest&nbsp;and&nbsp;addBack.
<br>Hint&nbsp;1<br>Based on the constraints, what is the maximum element that can possibly be popped?<br><br>Hint&nbsp;2<br>Maintain whether elements are in or not in the set. How many elements do we consider?<br><br>Similar Questions<br><a data-tooltip-position="top" aria-label="https://leetcode.com/problems/first-missing-positive/" rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/first-missing-positive/" target="_blank">First Missing Positive</a><br><br><br>
<br>leet는 처음이라 문제 보는 법이 어려움.

<br>특히 input 부분은 아직도 모르겠다.


<br>infinity set이란 걸 어떻게 만들지 당황했는데, 아래 제한 사항을 살펴보니 입력되는 num이 1000 이하였음 → 1~1000까지 힙 만들기.
<br>empty check 또한 할 필요 없음 → infinity set이며 최대 pop 호출 건수가 1000번이기 때문에.
<br>이전 <a data-tooltip-position="top" aria-label="42626. 더맵게" data-href="42626. 더맵게" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/42626.-더맵게.html" class="internal-link" target="_self" rel="noopener nofollow">heap 문제</a>에서는 add를 사용했는데 대신 offer를사용 

<br>add(): 우선순위 큐에 원소를 추가. 큐가 꽉 찬 경우&nbsp;에러 발생
<br>offer(): 우선순위 큐에 원소를 추가. 값 추가 실패 시&nbsp;false를 반환


<br>priority queue에서 값을 조회하는 함수 peek()
<br><a href="https://sunha20.github.io/digital-garden?query=tag:질문/코딩테스트" class="tag" target="_blank" rel="noopener nofollow">#질문/코딩테스트</a><br>
<br>priority queue의 capacity 문제 → 잘모르겠음.
<br><br>import java.util.*;

class SmallestInfiniteSet {
    private PriorityQueue&lt;Integer&gt; sis;
    public SmallestInfiniteSet() {
        sis = new PriorityQueue&lt;&gt;(1000);
        for (int i=1; i&lt;=1000; i++) {
            sis.offer(i);
        }
    }
    
    public int popSmallest() {
        return sis.poll();
    }

    public void addBack(int num) {
        Integer minInSet = sis.peek();
        if (minInSet == null || minInSet &gt; num) { // minInSet == null -&gt; queue is empty
            sis.offer(num);
        }
    }
}
복사<br>["SmallestInfiniteSet","popSmallest","addBack","popSmallest","popSmallest","popSmallest","addBack","addBack","popSmallest","popSmallest"]

[[],[],[1],[],[],[],[2],[3],[],[]]

Use Testcase

Output

[null,1,null,1,2,3,null,null,2,4]
복사<br>
<br>pop은 smallest number만 가능하기 때문에, (작은 순서대로 숫자가 사라지니) addBack의 할 때, 해당 숫자가 set에 존재하는 지를 set 가장 작은 숫자를 조회에서 확인 할 수 있다고 생각했음

<br>즉, set에 들어있는 숫자는 건너뛰는 경우없이 촘촘히 채워져 있다고 생각
<br>하지만, 123이 빠진 와중에 2가 addBack을 통해 추가되면, 3은 기존 확인 방법에서 제외되지만 사실 추가될 수 있는 상태


<br>해결:

<br>includes? (아 요즘 js를 많이 썼더니….) 말고 contains


<br><br>import java.util.*;

 class SmallestInfiniteSet {
    private PriorityQueue&lt;Integer&gt; sis;
    
    public SmallestInfiniteSet() {
        sis = new PriorityQueue&lt;&gt;(1000);
        for (int i=1; i&lt;=1000; i++) {
            sis.offer(i);
        }
    }

    public int popSmallest() {
        return sis.poll();
    }

    public void addBack(int num) {
        if (!sis.contains(num)){
            sis.offer(num);
        }
    }
}
복사<br>
<br>시간이 66ms → 조금 줄이고 싶음
<br>contains()… 아까부터 맘에 안듦.

<br>TreeSet 사용하면 중복 없고, 자동 정렬 가능! contains() 체크 안하고 그냥 추가 가능.


<br>import java.util.*;

class SmallestInfiniteSet {
    private TreeSet&lt;Integer&gt; sis;
    
    public SmallestInfiniteSet() {
        sis = new TreeSet&lt;&gt;();
        for (int i=1; i&lt;=1000; i++) {
            sis.add(i);
        }
    }

    public int popSmallest() {
        return sis.pollFirst();
    }

    public void addBack(int num) {
        sis.add(num);
    }
}
복사<br>
<br>시간이 반절 정도 줌.
<br>처음에 1000개 들어가 배열 사용하지 않는 것도 방법일듯…! 
<br><br>class SmallestInfiniteSet {
    HashSet&lt;Integer&gt; remov;
    int i;
    
    public SmallestInfiniteSet() {
        remov=new HashSet();
        i=1;
    }

    public int popSmallest() {
        while(remov.contains(i)){
            i++;
        }
        remov.add(i);
        return i++;
    }

    public void addBack(int num) {
        if(remov.contains(num)){
            remov.remove(num);
            if(i&gt;num){
                i=num;
            }
        }
    }

}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/2336. Smallest Number in Infinite Set.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 31 May 2024 01:53:32 GMT</pubDate></item><item><title><![CDATA[42746. 가장 큰 수]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-05-26<br>Link: <a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/42746" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/42746</a><br>Category: <a data-href="Sort" href="https://sunha20.github.io/digital-garden/Sort" class="internal-link" target="_self" rel="noopener nofollow">Sort</a><br>Success: -<br>Git: -<br><br><br>0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.<br>예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.<br>0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.<br><br>
<br>numbers의 길이는 1 이상 100,000 이하입니다.
<br>numbers의 원소는 0 이상 1,000 이하입니다.
<br>정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.
<br><br><br><br><br>
<br>
가장 앞자리 숫자끼리 비교해야함.

<br>String으로 바꿔서 인덱스로 접근


<br>
숫자가 같은 경우

<br>다음 숫자를 비교

<br>다음 숫자가 없을 경우

<br>다른 요소의 첫번째 숫자와 비교. (이때는 비교중인 상대 정수도 포함.)

<br>필요 없겠다. 이미 큰 수는 앞에서 사용했으니까.








<br>
String으로 만들어 정렬하면 그냥 되지 않을까?

<br>3,30,34,5,9 -&gt; 9,5,34,3(3),30
<br>이런식으로 정렬되도록 comparator 구 


<br><br>
<br>convert int[] to String[], 간단한 버전

<br><a data-tooltip-position="top" aria-label="https://makemepositive.tistory.com/6" rel="noopener nofollow" class="external-link" href="https://makemepositive.tistory.com/6" target="_blank">[Java] String to Integer, Integer to String — 성장을 공유하는 개발자</a>


<br>comparator vs comparable

<br><a data-tooltip-position="top" aria-label="https://st-lab.tistory.com/243" rel="noopener nofollow" class="external-link" href="https://st-lab.tistory.com/243" target="_blank">자바 [JAVA] - Comparable 과 Comparator의 이해</a>


<br><br>import java.util.*;

class Solution {
    public String solution(int[] numbers) {
        String answer = "";
        String[] strNums = Arrays.stream(numbers)
                .mapToObj(String::valueOf)
                .toArray(String[]::new);
        Arrays.sort(strNums, new BigNumComparator());
        for (String str: strNums) {
            answer += str;
        }
        return answer;
    }
}


class BigNumComparator implements Comparator&lt;String&gt; {
    public int compare(String s1, String s2) {
        int i = 0;
        while (i &lt; Math.max(s1.length(), s2.length())) {
            char c1, c2;

            if (i &lt; s1.length())
                c1 = s1.charAt(i);
            else
                c1 = s1.charAt(s1.length() - 1);

            if (i &lt; s2.length())
                c2 = s2.charAt(i);
            else
                c2 = s2.charAt(s2.length() - 1);

            if (c1 - c2 == 0) i += 1;
            else return -(c1-c2);
        }
        return 0;
    }
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/42746.-가장-큰-수.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/42746. 가장 큰 수.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 31 May 2024 01:53:08 GMT</pubDate></item><item><title><![CDATA[42626. 더맵게]]></title><description><![CDATA[ 
 <br><a data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">1. Study/Coding Test/PS/PS.md</a><br><br>매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.<br>섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)
복사<br>Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.<br>
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.<br><br>
<br>scoville의 길이는 2 이상 1,000,000 이하입니다.
<br>K는 0 이상 1,000,000,000 이하입니다.
<br>scoville의 원소는 각각 0 이상 1,000,000 이하입니다.
<br>모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.
<br><br><br><br>
<br>스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.<br>
새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5<br>
가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]
<br>스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.<br>
새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13<br>
가진 음식의 스코빌 지수 = [13, 9, 10, 12]
<br>모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.<br><br><br>
<br>참고: <a data-tooltip-position="top" aria-label="https://wrtn.ai/chat/u/65d591e80c06023ae70af73a/c/66508d0cdd60135f5bf99c8e?type=u" rel="noopener nofollow" class="external-link" href="https://wrtn.ai/chat/u/65d591e80c06023ae70af73a/c/66508d0cdd60135f5bf99c8e?type=u" target="_blank">뤼튼</a>
<br><br>: if (minA == null || minB == null) {<br>
<br>null과 int를 비교하여 생긴 문제.
<br>원래 목적: 

<br>우선순위 큐에서 poll()은 첫 번째 값을 반환하고&nbsp;제거, 비어있으면&nbsp;null을 반환하기 때문에 반환값이 null인 경우를 체크하려고 했다.
<br>우선순위 큐에 담겨있는 값은 Integer라서 Integer 대신 int 사용. → 이유: 익숙해서…


<br>문제: int는 reference type이 아닌 primitive type이기 때문에 null이 안 됨…
<br>해결방안

<br>int 대신 Integer(wrapper class) 사용


<br>/*
목표: 모든 음식의 스코빌 지수 &gt; K;
방법: 스코빌 지수가 가장 낮은 두개의 음식으로 새 음식을 만들기;

- 최소 힙 이용(by 우선순위 큐)
*/

import java.util.*;
class Solution {
    public int solution(int[] scoville, int K) {
        PriorityQueue&lt;Integer&gt; hp = new PriorityQueue&lt;&gt;();
        for (int s: scoville) {
            hp.add(s);
        }
        
        int cnt = 0;
        Integer minA;
        Integer minB;
        
        while (true) {
            minA = hp.poll();
            minB = hp.poll();
            if (minA == null || minB == null) {
                return -1;
            }
            if (minA &gt;= K) {
                return cnt;
            }
            
            int newFood = minA + (minB * 2);
            hp.add(newFood);
            cnt += 1;
        }
    }
}
복사<br><br>
<br>정확성 테스트 3개 정도 실패
<br>원인

<br>16, 22, 23 문제는 제공된 scoville이 2개인 경우에 대한 테스트입니다. (<a data-tooltip-position="top" aria-label="https://school.programmers.co.kr/questions/50794" rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/questions/50794" target="_blank">질문글 참고</a> / <a data-href="42626. 더맵게#테스트 케이스 추가 팁" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/42626.-더맵게.html#테스트_케이스_추가_팁" class="internal-link" target="_self" rel="noopener nofollow">42626. 더맵게 &gt; 테스트 케이스 추가 팁</a>)
<br>null check가 먼저 이루어지면서 문제가 생김 → 새로 뽑은 수가 null인데 이미, 조건(K 이상)을 만족했을 때
<br>단순히 null 체크와 조건 체크 순서를 바꾸면 minA가 null일 때 문제가 생김.

<br>수 하나는 무조건 큐에 추가되기 때문에 minA가 null일 리는 없음
<br>처음 주어지는 input도 2개 이상.




<br>/*
목표: 모든 음식의 스코빌 지수 &gt; K;
방법: 스코빌 지수가 가장 낮은 두개의 음식으로 새 음식을 만들기;

- 최소 힙 이용(by 우선순위 큐)
*/

import java.util.*;
class Solution {
    public int solution(int[] scoville, int K) {
        PriorityQueue&lt;Integer&gt; hp = new PriorityQueue&lt;&gt;();
        for (int s: scoville) {
            hp.add(s);
        }
        
        int cnt = 0;
        Integer minA;
        Integer minB;
        
        while (true) {
            // 가장 스코빌 지수가 낮은 음식 2개
            minA = hp.poll();
            minB = hp.poll();
            
            // 조건 체크1 (문제 조건상 항상 minA != null 만족)
            if (minA &gt;= K) {
                return cnt;
            }
            // 조건 체크2
            if (minB == null) {
                return -1;
            }

            // 새로운 음식 추가 및, 시도 횟수 늘리기.
            int newFood = minA + (minB * 2);
            hp.add(newFood);
            cnt += 1;
        }
    }
}
복사<br><br>
<br>기본 테스트 케이스: 문제에서 주어진 예제 테스트 케이스부터 실행해 보세요.
<br>경계값 테스트: 입력 값의 최소, 최대 경계에서의 동작을 확인하세요. 예를 들어, 비밀번호의 길이가 최대(6자리) 또는 최소(1자리)일 때의 동작을 확인해 보세요.
<br>특별한 경우 테스트: 일반적이지 않은 입력값이나 특별한 상황에서의 동작을 확인해 보세요. 예를 들어, DB가 비어있는 경우나, 같은 비밀번호를 가진 여러 회원이 있는 경우 등입니다.
<br>랜덤한 테스트: 여러 다양한 입력 조건에서의 동작을 확인하기 위해 랜덤한 입력값을 사용한 테스트 케이스를 추가해 보세요.
<br>순차적 테스트: 입력값이 특정 순서에 따라 동작을 확인하는 테스트 케이스를 추가해 보세요. 예를 들어, DB에 회원 정보가 아이디 순서나 비밀번호 순서에 따라 정렬된 경우 등입니다
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/42626.-더맵게.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/42626. 더맵게.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 31 May 2024 01:53:56 GMT</pubDate></item><item><title><![CDATA[30804. 과일 탕후루]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-07-03<br>Link: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/30804" target="_blank">https://www.acmicpc.net/problem/30804</a><br>Level: s2<br>Category: <br>two pointer<br>Success: two pointer 공부하고 풀기<br><br><br><br>은하는 긴 막대에&nbsp;개의 과일이 꽂혀있는 과일 탕후루를 만들었습니다. 과일의 각 종류에는&nbsp;부터&nbsp;까지의 번호가 붙어있고, 앞쪽부터 차례로번 과일이 꽂혀있습니다. 과일 탕후루를 다 만든 은하가 주문을 다시 확인해보니 과일을 두 종류 이하로 사용해달라는 요청이 있었습니다.<br>탕후루를 다시 만들 시간이 없었던 은하는, 막대의 앞쪽과 뒤쪽에서 몇 개의 과일을 빼서 두 종류 이하의 과일만 남기기로 했습니다. 앞에서&nbsp;개, 뒤에서&nbsp;개의 과일을 빼면&nbsp;번 과일, 총&nbsp;개가 꽂혀있는 탕후루가 됩니다.&nbsp;&nbsp; <br>이렇게 만들 수 있는 과일을 두 종류 이하로 사용한 탕후루 중에서, 과일의 개수가 가장 많은 탕후루의 과일 개수를 구하세요.<br><br>첫 줄에 과일의 개수&nbsp;𝑁이 주어집니다.&nbsp;(1≤𝑁≤200000) <br>둘째 줄에 탕후루에 꽂힌 과일을 의미하는&nbsp;개의 정수&nbsp;이 공백으로 구분되어 주어집니다.&nbsp; <br><br>문제의 방법대로 만들 수 있는 과일을 두 종류 이하로 사용한 탕후루 중에서, 과일의 개수가 가장 많은 탕후루의 과일 개수를 첫째 줄에 출력하세요.<br><br>5<br>
5 1 1 2 1<br><br>4<br>과일을 앞에서&nbsp;개, 뒤에서&nbsp;개의 과일을 빼면 남은 과일은&nbsp;번 과일이 꽂혀있는 탕후루가 됩니다. 과일의 개수는&nbsp;개입니다.<br><br>3<br>
1 1 1<br><br>3<br>탕후루가 이미 두 종류 이하의 과일로만 이루어져 있습니다.<br><br>9<br>
1 2 3 4 5 6 7 8 9<br><br>2<br>과일을 앞에서&nbsp;개, 뒤에서&nbsp;개의 과일을 빼면 남은 과일은&nbsp;번 과일이 꽂혀있는 탕후루가 됩니다. 과일의 개수는&nbsp;개입니다.<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/45" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/45" target="_blank">Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/859" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/859" target="_blank">solved.ac</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/1003" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/1003" target="_blank">solved.ac Grand Arena #3</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/4059" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/4059" target="_blank">Division 2</a>&nbsp;C번<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/45" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/45" target="_blank">Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/859" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/859" target="_blank">solved.ac</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/1003" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/1003" target="_blank">solved.ac Grand Arena #3</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/4060" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/4060" target="_blank">Division 1</a>&nbsp;A번<br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cologne" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/cologne" target="_blank">cologne</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/havana723" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/havana723" target="_blank">havana723</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/solvedac" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/solvedac" target="_blank">solvedac</a>
<br>문제를 검수한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cologne" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/cologne" target="_blank">cologne</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cozyyg" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/cozyyg" target="_blank">cozyyg</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/gs18115" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/gs18115" target="_blank">gs18115</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/moonrabbit2" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/moonrabbit2" target="_blank">moonrabbit2</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/seonah" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/seonah" target="_blank">seonah</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/80" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/80" target="_blank">두 포인터</a>
<br><br>import java.sql.SQLOutput;  
import java.util.*;  
import java.io.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        int N = Integer.parseInt(br.readLine());  
        String[] temp = br.readLine().split(" ");  
        List&lt;Integer&gt; stick = new LinkedList&lt;&gt;();  
        Map&lt;Integer, Integer&gt; fruit = new HashMap&lt;&gt;();  
        for (int n=0; n&lt;N; n++) {  
            int key = Integer.parseInt(temp[n]);  
            stick.add(key);  
            if (fruit.containsKey(key)) {  
                fruit.replace(key, fruit.get(key));  
            } else {  
                fruit.put(key, 1);  
            }  
        }  
  
        ListIterator&lt;Integer&gt; front = stick.listIterator();  
        ListIterator&lt;Integer&gt; back = stick.listIterator(N-1);  
        int max = 0;  
        int all = N;  
  
        for (int i=0; i&lt;N; i++) {  
            int nowF = front.next();  
            for (int j=0; j&lt;N; j++) {  
                int  
            }  
        }  
  
    }  
}
복사<br>
<br>바뀌는 부분에 인덱스를 요소로 가진 리스트를 따로 만들어 두는 거 어때?
<br>이중 포문 싫음.
<br><br>import java.util.*;  
import java.io.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        int N = Integer.parseInt(br.readLine());  
        String[] stick = br.readLine().split(" ");  
  
        List&lt;Integer&gt; change = new ArrayList&lt;&gt;();  
        String before = "0";  
        String bbefore = "0";  
        for (int n=0; n&lt;N; n++) {  
            if (!before.equals(stick[n])) {  
                if (!bbefore.equals(stick[n])) {  
                    change.add(n);  
                }  
                bbefore = before;  
                before = stick[n];  
            }  
        }  
        change.add(N);  
  
        if (change.size() &lt; 3) {  
            System.out.println(N);  
            return;  
        }  
  
        int max = 0;  
        for (int i=0; i&lt;change.size()-2; i++) {  
            int p1 = change.get(i);  
            int p2 = change.get(2+i);  
            if (p2-p1 &gt; max) max = p2-p1;  
        }  
        System.out.println(max);  
  
    }  
}
복사<br>
<br>
하나가 아니라 총 2개 까지 가능이니까, 동일한 과일끼리 연결되있는 것을 한 덩어리로 칠때, i 번째 덩어리의 과일이, i-1번째 덩어리의 과일과는 다르지만, i-2번째 덩어리 과일과는 동일 할 수도 있음.

<br>
그래서 before, bbefore 두개 체크하기로 했는데 이게 문제가 있는 듯.

<br>
그냥 map으로 과일 종류랑 같이 저장하는 거 어때?

<br>순서대로 정렬하려면 linkedhashmap 쓰거나, hashmap에서 key set으로 정렬.


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/30804.-과일-탕후루.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/30804. 과일 탕후루.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Thu, 11 Jul 2024 04:22:22 GMT</pubDate></item><item><title><![CDATA[2805. 나무 자르기]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-29<br>Link: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/2805" target="_blank">https://www.acmicpc.net/problem/2805</a><br>Level: s2<br>Category: <br>매개 변수 탐색<br>이분탐색<br>Success: ⭕<br><br><br><br>상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를&nbsp;이용해서 나무를 구할것이다.<br>목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.<br>상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)<br>둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.<br><br>적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.<br><br>4 7<br>
20 15 10 17<br><br>15<br><br>5 20<br>
4 42 40 26 46<br><br>36<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/45" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/45" target="_blank">Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/17" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/17" target="_blank">Croatian Open Competition in Informatics</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/19" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/19" target="_blank">COCI 2011/2012</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/72" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/72" target="_blank">Contest #5</a>&nbsp;2번<br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/csehydrogen" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/csehydrogen" target="_blank">csehydrogen</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/upple1" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/upple1" target="_blank">upple1</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/vyu" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/vyu" target="_blank">vyu</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jongseo_park" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jongseo_park" target="_blank">jongseo_park</a>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/rdd6584" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/rdd6584" target="_blank">rdd6584</a>
<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/tncks0121" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/tncks0121" target="_blank">tncks0121</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/12" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/12" target="_blank">이분 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/170" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/170" target="_blank">매개 변수 탐색</a>
<br><br>
<br>왜 이게 이진탐색?
<br>다 더하고 하나씩 빼가면서 보기… 어때?
<br>import java.util.*;  
import java.io.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int N = Integer.parseInt(st.nextToken());       // 나무 수  
        int M = Integer.parseInt(st.nextToken());       // 나무 길이  
  
        st = new StringTokenizer(br.readLine());  
        int[] trees = new int[N];  
        int sum = 0;  
        for (int n = 0; n &lt; N; n++) {  
            trees[n] = Integer.parseInt(st.nextToken());  
            sum += trees[n];  
        }  
        Arrays.sort(trees);  
  
        // 이진탐색 초기화  
        int l = 0;  
        int r = N - 1;  
  
    }  
}
복사<br>
<br>
일단 여기까지 하고 직전문제 풀고오기 <a data-href="1654. 랜선 자르기" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1654.-랜선-자르기.html" class="internal-link" target="_self" rel="noopener nofollow">1654. 랜선 자르기</a>

<br>
최대: 가장 큰 나무

<br>
최소: 0

<br>
sort를 해야할까? → 하는 게 좋을 듯, tree 길이 배열을 거꾸로 돌려서 나무 길이가 칼 위치보다 낮아지면, 반복문 종료하기.

<br>import java.util.*;  
import java.io.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int N = Integer.parseInt(st.nextToken());       // 나무 수    
int M = Integer.parseInt(st.nextToken());       // 나무 길이    
        st = new StringTokenizer(br.readLine());  
        int[] trees = new int[N];  
        for (int n = 0; n &lt; N; n++) {  
            trees[n] = Integer.parseInt(st.nextToken());  
        }  
        Arrays.sort(trees);  
  
        // 이진탐색 초기화  
        int hi = trees[N-1]+1;  
        int lo = 0;  
  
        while (lo &lt; hi) {  
            int now = (hi+lo) / 2;  
            long sum = 0;  
            for (int n=N-1; n&gt;=0; n--){  
                if (trees[n] &lt; now) break;  
                sum += (trees[n] - now);  
            }  
  
            if (sum &lt; M) {  
                hi = now;  
            } else {  
                lo = now + 1;  
            }  
        }  
  
        System.out.println(lo-1);  
    }  
}

복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/2805.-나무-자르기.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/2805. 나무 자르기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Wed, 03 Jul 2024 06:24:57 GMT</pubDate></item><item><title><![CDATA[24228. 젓가락]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-28<br>Link: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/24228" target="_blank">https://www.acmicpc.net/problem/24228</a><br>Level: s4<br>Category: <br>수학<br>비둘기집 원리<br>Success: ⭕<br>Git: -<br><br><br><br>젓가락통에&nbsp;𝑁&nbsp;종류의 젓가락이 종류별로 충분히 많이 들어있다. 당신은 이 젓가락통에서 무작위로 젓가락을 뽑아서&nbsp;𝑅개의 짝을 맞춰야 한다.&nbsp;최악의 경우 몇 개의 젓가락을 뽑아야 하는가?<br><br>두 개의 정수&nbsp;𝑁,𝑅이 주어진다.&nbsp;(1≤𝑁,𝑅≤1018) <br><br>최악의 경우 뽑아야 하는 젓가락의 개수를 출력한다.<br><br>2 1<br><br>3<br><img src="https://upload.acmicpc.net/c59e0233-6568-4aaa-91a1-e11c602a392d/-/preview/" referrerpolicy="no-referrer"><br>2개만 뽑으면 짝이 0개일 가능성이 있다. 반면에 3개를 뽑으면 모든 경우에 대해서 짝이 최소 1개는 맞춰진다.<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/5" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/5" target="_blank">University</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/409" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/409" target="_blank">경인지역 6개대학 연합</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/2984" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/2984" target="_blank">shake! 2021</a>&nbsp;A번<br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/Coxie" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/Coxie" target="_blank">Coxie</a>
<br>문제를 검수한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/rhs0266" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/rhs0266" target="_blank">rhs0266</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/spectaclehong" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/spectaclehong" target="_blank">spectaclehong</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/189" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/189" target="_blank">비둘기집 원리</a>
<br><br>
<br>
N개중 1개 → 그외에 젓가락 → 그외의 젓가락 → (N-1번) → 짝 1개 → 2개 → 3개 → … → N개

<br>
N개를 뽑음. → A 젓가락 짝을 맞춤 → A젓가락 1개 뽑음 → A젓가락 두번째로 짝을 맞춤

<br>
N + (2*R) - 1 

<br>
<br>
경우의 수 문제가 아니라 횟문제.

<br>
입력값을 int로 변환할때, 문제가 생김…

<br>입력값이 최대 10^18이므로(2^31-1 보다 큼) long 타입으로 변수를 선언


<br><br>import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] line = br.readLine().split(" ");
        long N = Long.parseLong(line[0]);
        long R = Long.parseLong(line[1]);

        System.out.println(N + (R * 2) -1);

        br.close();
    }
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/24228.-젓가락.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/24228. 젓가락.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 28 Jun 2024 06:48:01 GMT</pubDate><enclosure url="https://upload.acmicpc.net/c59e0233-6568-4aaa-91a1-e11c602a392d/-/preview/" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://upload.acmicpc.net/c59e0233-6568-4aaa-91a1-e11c602a392d/-/preview/"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1844. 게임 맵 최단거리]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-05-31<br>Link: <a rel="noopener nofollow" class="external-link" href="https://school.programmers.co.kr/learn/courses/30/lessons/1844" target="_blank">https://school.programmers.co.kr/learn/courses/30/lessons/1844</a><br>Level: lv2<br>Category: <a data-href="BFS, DFS" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/graph/bfs,-dfs.html" class="internal-link" target="_self" rel="noopener nofollow">BFS, DFS</a><br>Success: ⭕<br>Git: -<br><br><br>ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.<br>지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.<br><img alt="최단거리1_sxuruo.png" src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dc3a1b49-13d3-4047-b6f8-6cc40b2702a7/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B51_sxuruo.png" referrerpolicy="no-referrer" style="width: 143px; max-width: 100%;"><br>위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.<br>
아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.<br>
<br>첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.
<br><img alt="최단거리2_hnjd3b.png" src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9d909e5a-ca95-4088-9df9-d84cb804b2b0/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B52_hnjd3b.png" referrerpolicy="no-referrer" style="width: 143px; max-width: 100%;"><br>
<br>두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.
<br><img alt="최단거리3_ntxygd.png" src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4b7cd629-a3c2-4e02-b748-a707211131de/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B53_ntxygd.png" referrerpolicy="no-referrer" style="width: 143px; max-width: 100%;"><br>위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.<br>만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.<br><img alt="최단거리4_of9xfg.png" src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d963b4bd-12e5-45da-9ca7-549e453d58a9/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B54_of9xfg.png" referrerpolicy="no-referrer" style="width: 141px; max-width: 100%;"><br>게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의&nbsp;최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.<br><br>
<br>maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다.

<br>n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다.


<br>maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.
<br>처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.
<br><br><br><br><br>입출력 예 #1<br>
주어진 데이터는 다음과 같습니다.<br><img alt="최단거리6_lgjvrb.png" src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/6db71f7f-58d3-4623-9fab-7cd99fa863a5/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B56_lgjvrb.png" referrerpolicy="no-referrer"><br>캐릭터가 적 팀의 진영까지 이동하는 가장 빠른 길은 다음 그림과 같습니다.<br><img alt="최단거리2_hnjd3b (1).png" src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d223d017-b3e2-4772-9045-a565133d45ff/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B52_hnjd3b%20%281%29.png" referrerpolicy="no-referrer"><br>따라서 총 11칸을 캐릭터가 지나갔으므로 11을 return 하면 됩니다.<br>입출력 예 #2<br>
문제의 예시와 같으며, 상대 팀 진영에 도달할 방법이 없습니다. 따라서 -1을 return 합니다.<br><br><br>
<br>최단 거리 구하는 알고리즘: bfs
<br>재귀에서 목적지에 도착했는지를 가장 먼저 check하고 return해줘야하는 듯. 최단 거리 보장이니까
<br><br>import java.util.*;
class Solution {
    static int[][] offset = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int solution(int[][] maps) {
        Queue&lt;int[]&gt; que = new LinkedList&lt;&gt;();
        int[][] visited = new int[maps.length][maps[0].length];
        que.offer(new int[] {0,0});
        bfs(0, 0, que, maps, visited);        
        
        return 0;
    }
    private void bfs(int r, int c, Queue&lt;int[]&gt; que, int[][] maps, int[][] visited) {
        // 전체 완료
        if (que.size() == 0) return ;       
        
        // 이번 탐색
        visited[r][c] = 1;
        
        // 인접 node들 que에 삽입
        for (int[] o : offset) {
            int newR = r+o[0];
            int newC = c+o[1];
                
            // out of index
            if (newR &lt; 0 || newC &lt; 0 || newR &gt;= maps.length || newC &gt;= maps[0].length) continue;
            // invaild node
            if (maps[newR][newC] == 0 || visited[newR][newC] != 0) continue;
            
            que.offer(new int[] {newR, newC});
        }
        
        // 다음 탐색
        int[] newNode = que.poll();
        System.out.println(newNode[0] + " " + newNode[1]);
        bfs(newNode[0], newNode[1], que, maps, visited);

    }
}
복사<br>
<br>여기서 최단거리 측정 logic을 모르겠음.
<br>구글링 해보니 대부분 visited 배열을 사용.
<br>재귀보다 반복문이 훨씬 편하네…
<br>아 바로 전 좌표가 있구나… 그걸로 이전 visit 값 가져오면 되겠구만.
<br><br>import java.util.*;
class Solution {
    static int[][] offset = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int solution(int[][] maps) {
        int[][] visited = new int[maps.length][maps[0].length];
        visited[0][0] = 1;
        bfs(maps, visited);        
        int answer = visited[maps.length-1][maps[0].length-1];
        if (answer == 0) answer = -1;
        return answer;
    }
    private void bfs(int[][] maps, int[][] visited) {        
        Queue&lt;int[]&gt; que = new LinkedList&lt;&gt;();
        que.offer(new int[] {0,0});
        
        while (!que.isEmpty()) {
            int[] node = que.poll();
            int r = node[0];
            int c = node[1];  
        
            // 인접 node들 que에 삽입
            for (int[] o : offset) {
                int newR = r+o[0];
                int newC = c+o[1];

                // out of index
                if (newR &lt; 0 || newC &lt; 0 || newR &gt;= maps.length || newC &gt;= maps[0].length) continue;
                // invaild node
                if (maps[newR][newC] == 0 || visited[newR][newC] != 0) continue;

                que.offer(new int[] {newR, newC});
                
                // visit 처리
                visited[newR][newC] = visited[r][c] + 1;
            }
        }

    }
}
복사<br>
<br>왜 최단 거리를 보장하는가.

<br>가장 먼저 도달했을 때의 거리를 visit 배열에 넣어주면, 그 후에 그 node에 접근하는 애들들은 접근부터 불가능함. 최소 거리로 남아있음.


<br>목적지에 도달했을 때 바로 loop 끝내고 돌아가는 것도 가능. → 오히려 시간 줄일 듯.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1844.-게임-맵-최단거리.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1844. 게임 맵 최단거리.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 31 May 2024 09:14:37 GMT</pubDate><enclosure url="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dc3a1b49-13d3-4047-b6f8-6cc40b2702a7/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B51_sxuruo.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dc3a1b49-13d3-4047-b6f8-6cc40b2702a7/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B51_sxuruo.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1654. 랜선 자르기]]></title><description><![CDATA[ 
 <br><br><br><br><br>집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이&nbsp;캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.<br>이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는&nbsp;버려야 한다. (이미 자른 랜선은 붙일 수 없다.)<br>편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 2^31-1보다 작거나 같은 자연수이다.<br><br>첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.<br><br>4 11
802
743
457
539

복사<br><br>200

복사<br><br>802cm 랜선에서 4개, 743cm 랜선에서 3개, 457cm 랜선에서 2개, 539cm 랜선에서 2개를 잘라내 모두 11개를 만들 수 있다.<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/plzrun" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/plzrun" target="_blank">plzrun</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/skydreamer21" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/skydreamer21" target="_blank">skydreamer21</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/twicedtna" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/twicedtna" target="_blank">twicedtna</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/helloworld123" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/helloworld123" target="_blank">helloworld123</a>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/iriszero" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/iriszero" target="_blank">iriszero</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/12" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/12" target="_blank">이분 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/170" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/170" target="_blank">매개 변수 탐색</a>
<br><br>참고: <a data-tooltip-position="top" aria-label="https://st-lab.tistory.com/269" rel="noopener nofollow" class="external-link" href="https://st-lab.tistory.com/269" target="_blank">[백준] 1654번 : 랜선 자르기 - JAVA [자바]</a> / <a data-tooltip-position="top" aria-label="https://st-lab.tistory.com/267" rel="noopener nofollow" class="external-link" href="https://st-lab.tistory.com/267" target="_blank">[백준] 10816번 : 숫자 카드 2 - JAVA [자바]</a><br>
<br>길이에대한 이분탐색
<br>최소길이와 최대길이 정하기

<br>최대: 다 더해서 / 필요한 랜선 
<br>최소: 가장 짧은 랜선 / (필요한 랜선수 / 가진 랜선 수)


<br>주의:

<br>2^31-1 → int형 최댓값임 long으로 선언
<br>이분탐색에서 max 설정할 때 널널하게 +1 꼭 해주기.


<br><br>import java.util.*;  
import java.io.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int K = Integer.parseInt(st.nextToken());       // 가지고 있는 랜선 수  
        int N = Integer.parseInt(st.nextToken());       // 필요한 랜선 수  
  
        long[] lines = new long[N];  
        long sum = 0;  
        for (int k = 0; k &lt; K; k++) {  
            lines[k] = Integer.parseInt(br.readLine());  
            sum += lines[k];  
        }  
  
        // 이진탐색 초기화  
        long max = (sum/N)+1;  
        long min = 0L;  
        while (min &lt; max) {  
            long now = (max + min) / 2;      // now = 이번 loop에 사용한 mid값  
  
            int cnt = 0;                    // now에 따라 생성되는 line개수  
            for (long line: lines) {         // line 개수 세기  
                cnt += line/now;  
            }  
  
            /*  
            conut된 line(cnt)와 필요한 line(N) 수를 비교  
            cnt &lt; N -&gt; 줄 개수가 더 많아져야함 = 줄 길이가 현재(now)보다 무조건 짧아야함.  
            cnt &gt;= N -&gt; 줄 개수가 적어져야함. = 줄 길이가 현재(now)보다 무조건 길어야함 (+1).            +) upper bound 방식이므로 N과 cnt가 같은 경우 min으로 설정해줌  
               upper bound: 기준을 초과한 첫번째 값이 반환되도록 -&gt; 던지는 값은 항상 low             */            if (cnt &lt; N) {  
                max = now;  
            } else {  
                min = now + 1;  
            }  
  
        }  
        System.out.println(min-1);  
  
    }  
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1654.-랜선-자르기.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1654. 랜선 자르기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Mon, 01 Jul 2024 06:53:15 GMT</pubDate></item><item><title><![CDATA[1로 만들기]]></title><description><![CDATA[ 
 <br><br>ID: 1463<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1463" target="_blank">https://www.acmicpc.net/problem/1463</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
분류: 다이나믹 프로그래밍<br>
생성 일시: 2023년 8월 13일 오후 11:15<br>
💡 - 이거 진짜 도움됨.<br><a data-tooltip-position="top" aria-label="https://bio-info.tistory.com/159" rel="noopener nofollow" class="external-link" href="https://bio-info.tistory.com/159" target="_blank">[백준] 1463 1로 만들기 (DP) - Python / 자세한 설명 / 여러가지 풀이 / 실버1</a><br><br><br><br><br><br>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.<br>
<br>X가 3으로 나누어 떨어지면, 3으로 나눈다.
<br>X가 2로 나누어 떨어지면, 2로 나눈다.
<br>1을 뺀다.
<br>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.<br><br>첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.<br><br>첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.<br><br>2

복사<br><br>1

복사<br><br>10

복사<br><br>3

복사<br><br>10의 경우에 10 → 9 → 3 → 1 로 3번 만에 만들 수 있다.<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cyj101366" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/cyj101366" target="_blank">cyj101366</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jugol" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jugol" target="_blank">jugol</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/dbfldkfdbgml" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/dbfldkfdbgml" target="_blank">dbfldkfdbgml</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/dynamiseus" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/dynamiseus" target="_blank">dynamiseus</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jooa7878" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jooa7878" target="_blank">jooa7878</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/lcr7324" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/lcr7324" target="_blank">lcr7324</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><br>
<br>Python 3: 1.5 초
<br>PyPy3: 0.7 초
<br>Python 2: 1.5 초
<br>PyPy2: 0.7 초
<br><br>
<br>
10

<br>-1(9)

<br>/3
<br>/3


<br>-2(8)

<br>/2
<br>/2
<br>/2


<br>-3(7)
<br>-4(6)

<br>/3
<br>/2


<br>-5(5)
<br>-6(4)

<br>/2
<br>/2


<br>-7


<br>
빼는 수를 하나씩 늘려가면서, 빼고, 각각의 경우에 2,3으로 나누고 나누어 떨어지는 경우 개수를 비교함

<br>
min

<br>자 계속 틀림...
복사<br>
<br>
dp공부 후…

<br>
dp list는 X길이로 만들어야겠지…

<br>
1을 1로 만들려면 → 0

<br>
2를 1로 만들려면 (2) → 1

<br>
3을 1로 만들려면 /3 → 1

<br>
4를 1로 만들려면 /2/2 → 2

<br>
5를 1로 만들려면 →3

<br>
점화식을 어떻게 만들어야할까.

<br>
f(1) = 0

<br>
f(2) = 1

<br>
f(3) = 1

<br>
f(4) = 2

<br>
f(5) = 3

<br>
f(6) = 2 →

<br>
f(7) = 3 → -1, f(6)

<br>
f(8) = 3 → /2, f(4)

<br>
f(9) = 2 → /3, f(3)

<br>
f(10) = → -1, f(9)

<br><br>복사<br><br><br>import sys

def make_one_topdown(x):
    if x == 1:
        return 0
    elif x%3 == 0 and x%2 == 0:
        return 1+ min(make_one_topdown(x//3), make_one_topdown(x//2), make_one_topdown(x-1))
    elif x%3 == 0:
        return 1+ min(make_one_topdown(x//3), make_one_topdown(x-1))
    elif x%2 == 0:
        return 1+ min(make_one_topdown(x//2), make_one_topdown(x-1))
    else:
        return 1+ make_one_topdown(x-1)

if __name__ == "__main__":
    print(make_one_topdown(int(sys.stdin.readline().rstrip())))
복사<br>
<br>생각해보니까. 이 방식은 메모, 재사용의 취지에 딱 들어맞진 않음.
<br>여기에 table을 추가하는 겨..
<br>import sys

X = int(sys.stdin.readline().rstrip())
dp = {1:0}
def make_one_topdown(x):
    if x in dp:
        return dp[x]
    else:
        dp[x] = 1+ min(make_one_topdown(x//3)+x%3, make_one_topdown(x//2)+x%2, make_one_topdown(x-1))
        return dp[x]

print(make_one_topdown(X))
복사<br>
<br>RecursionError: maximum recursion depth exceeded
<br>생각해보면, make_one_topdown(x-1) 필요 없음…
<br>import sys

X = int(sys.stdin.readline().rstrip())
dp = {1:0,2:1, 3:1}
def make_one_topdown(x):
    if x in dp:
        return dp[x]
    else:
        dp[x] = 1+ min(make_one_topdown(x//3)+ x%3, make_one_topdown(x//2)+x%2)
        return dp[x]

print(make_one_topdown(X))
복사<br>
<br>시간이 거의 10배 차이남
<br>Bottom-up 방식은 dp(1)부터 dp(n)까지 전부 구하지만 top-down 방식은 그렇지 않습니다. 실제로 top-down 코드에서 dp(n) 계산이 끝난 후에 arr 전체를 출력해 보면 1~n 전부가 아닌 일부만 계산되어 있음을 확인할 수 있습니다.
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/board/view/122640" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/board/view/122640" target="_blank">글 읽기 - Top-down Bottom-up 시간 차이에 대한 질문입니다</a>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1로-만들기.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1로 만들기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 06 Aug 2024 17:28:14 GMT</pubDate></item><item><title><![CDATA[1302. Deepest Leaves Sum]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-01<br>Link: <a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/deepest-leaves-sum/" target="_blank">https://leetcode.com/problems/deepest-leaves-sum/</a><br>Level: Medium<br>Category: <a data-href="BFS, DFS" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/graph/bfs,-dfs.html" class="internal-link" target="_self" rel="noopener nofollow">BFS, DFS</a><br>Success: -<br>Git: -<br><br>Given the&nbsp;root&nbsp;of a binary tree, return&nbsp;the sum of values of its deepest leaves.<br>Example 1:<br><img alt="" src="https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png" referrerpolicy="no-referrer" style="width: 213px; max-width: 100%;"><br>Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]<br>
Output: 15<br>Example 2:<br>Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]<br>
Output: 19<br>Constraints:<br>
<br>The number of nodes in the tree is in the range&nbsp;[1, 104].
<br>1 &lt;= Node.val &lt;= 100
<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1302.-deepest-leaves-sum.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1302. Deepest Leaves Sum.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 01 Jun 2024 11:52:00 GMT</pubDate><enclosure url="https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[15969. 행복]]></title><description><![CDATA[ 
 <br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a><br><br><br>코이 초등학교에 새로 부임하신 교장 선생님은 어린 학생들의 행복감과 학생들의 성적 차이 관계를 알아보기로 했다. 그래서 이전 성적을 조사하여 학생 들의 시험 점수 차이 변화를 알아보려고 한다.<br>예를 들어서 2016년 학생 8명의 점수가 다음과 같다고 하자.<br>27, 35, 92, 75, 42, 53, 29, 87<br>그러면 가장 높은 점수는 92점이고 가장 낮은 점수는 27점이므로 점수의 최대 차이는 65이다. 한편 2017년 학생 8명의 점수가 다음과 같았다.<br>85, 42, 79, 95, 37, 11, 72, 32<br>이때 가장 높은 점수는 95점이고 가장 낮은 점수는 11점이므로 점수의 최대 차이는 84이다.<br>N명 학생들의 점수가 주어졌을 때, 가장 높은 점수와 가장 낮은 점수의 차이를 구하는 프로그램을 작성하시오<br><br>표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 학생 수&nbsp;N이 주어진다. 다음 줄에는&nbsp;N명의 학생 점수가 공백 하나를 사이에 두고 주어진다.<br><br>표준 출력으로 가장 높은 점수와 가장 낮은 점수의 차이를 출력한다.<br><br>모든 서브태스크에서 2 ≤&nbsp;N&nbsp;≤ 1,000이고 입력되는 학생들의 점수는 0 이상 1,000 이하의 정수이다.<br><br>학생 수가 2명인 경우만 존재한다.<br><br>점수가 낮은 점수부터 높은 점수까지 순서대로 주어진다.<br><br>원래의 제약 조건 이외에 아무 제약 조건이 없다.<br><br>5<br>
27 35 92 75 42<br><br>65<br><br>8<br>
85 42 79 95 37 11 72 32<br><br>84<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/55" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/55" target="_blank">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/427" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/427" target="_blank">KOI 2018</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/1894" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/1894" target="_blank">초등부</a>&nbsp;1번<br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/121" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/121" target="_blank">사칙연산</a>
<br><br>
<br>파이썬의 map(int, 어쩌구.split())을 java에서 사용하고 싶음… → <a data-tooltip-position="top" aria-label="https://velog.io/@suyyeon/JAVA-String-%EB%B0%B0%EC%97%B4%EC%9D%84-int-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0" rel="noopener nofollow" class="external-link" href="https://velog.io/@suyyeon/JAVA-String-%EB%B0%B0%EC%97%B4%EC%9D%84-int-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0" target="_blank">[JAVA] String 배열을 int 배열로 변환하기</a>
<br>int[] gradeList = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
복사<br><br>import java.io.*;  
import java.util.Arrays;  
  
public class Main {  
    public void Solution() throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        int n = Integer.parseInt(br.readLine());  
        int[] gradeList = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();  
        int max = -1;  
        int min = 1001;  
        for(int grade: gradeList) {  
            if (grade &gt; max) {  
                max = grade;  
            }  
            if (grade &lt; min) {  
                min = grade;  
            }  
        }  
        System.out.println(max-min);  
        br.close();  
    }  
    public static void main(String[] args) throws IOException {  
        new Main().Solution();  
    }  
}
복사<br>
<br>이거 parsed int를 각각에서 하면 조금 시간을 줄일 수있지 않을까? → 와안전 조금 주넼ㅋㅋㅋ
<br>public void Solution2_time() throws IOException {  
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    int n = Integer.parseInt(br.readLine());  
    String[] gradeList = br.readLine().split(" ");  
    int max = -1;  
    int min = 1001;  
    for(String grade: gradeList) {  
        int gradeInt = Integer.parseInt(grade);  
        if (gradeInt &gt; max) {  
            max = gradeInt;  
        }  
        if (gradeInt &lt; min) {  
            min = gradeInt;  
        }  
    }  
    System.out.println(max-min);  
    br.close();  
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/15969.-행복.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/15969. 행복.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 25 May 2024 15:36:52 GMT</pubDate></item><item><title><![CDATA[1541. 잃어버린 괄호]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-28<br>Link: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1541" target="_blank">https://www.acmicpc.net/problem/1541</a><br>Level: s2<br>Category: <br>greedy<br>Success: ⭕<br>Git: -<br><br><br><br>세준이는 양수와 +, -, 그리고 괄호를 가지고&nbsp;식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.<br>그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.<br>괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.<br><br>첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이&nbsp;연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.<br><br>첫째 줄에 정답을 출력한다.<br><br>55-50+40<br><br>-35<br><br>10+20+30+40<br><br>100<br><br>00009-00009<br><br>0<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>잘못된 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/windflower" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/windflower" target="_blank">windflower</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/96" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/96" target="_blank">파싱</a>
<br><br>
<br>

<br>뒤에서 괄호 열기 / - 앞에서 괄호 닫기


<br>split() → 괄호안에 정규식이 들어가기 때문에 +를 기준으로 하려면 \\+로 해주어야한다.
<br><br>import java.util.*;  
import java.io.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        String[] splitByMinus = br.readLine().split("-");  
        int result = 0;  
        int sum = 0;  
        for (int i=0; i&lt;splitByMinus.length; i++) {  
            String[] splitByPlus = splitByMinus[i].split("\\+");  
            sum = 0;  
            for (String num : splitByPlus) {  
                sum += Integer.parseInt(num);  
            }  
            if(i == 0) {result += sum; continue;}  
            result -= sum;  
        }  
        System.out.println(result);  
        br.close();  
    }  
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1541.-잃어버린-괄호.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1541. 잃어버린 괄호.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 28 Jun 2024 06:48:08 GMT</pubDate></item><item><title><![CDATA[1476. Subrectangle Queries]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-14<br>Link: <a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/subrectangle-queries/description/" target="_blank">https://leetcode.com/problems/subrectangle-queries/description/</a><br>Level: Medium<br>Category: -<br>Success: ⭕<br>Git: -<br><br>Implement the class&nbsp;SubrectangleQueries&nbsp;which receives a&nbsp;rows x cols&nbsp;rectangle as a matrix of integers in the constructor and supports two methods:<br>1.&nbsp;updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)<br>
<br>
Updates all values with&nbsp;newValue&nbsp;in the subrectangle whose upper left coordinate is&nbsp;(row1,col1)&nbsp;and bottom right coordinate is&nbsp;(row2,col2).
2.&nbsp;getValue(int row, int col)

<br>
Returns the current value of the coordinate&nbsp;(row,col)&nbsp;from&nbsp;the rectangle.

<br>Example 1:<br>Input<br>
["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue","getValue"]<br>
[<a data-href="[1,2,1],[4,3,4],[3,2,1],[1,1,1" href="https://sunha20.github.io/digital-garden/[1,2,1],[4,3,4],[3,2,1],[1,1,1" class="internal-link" target="_self" rel="noopener nofollow">[1,2,1],[4,3,4],[3,2,1],[1,1,1</a>],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]<br>Output<br>
[null,1,null,5,5,null,10,5]<br>Explanation<br>
SubrectangleQueries subrectangleQueries = new SubrectangleQueries(<a data-href="1,2,1],[4,3,4],[3,2,1],[1,1,1" href="https://sunha20.github.io/digital-garden/1,2,1],[4,3,4],[3,2,1],[1,1,1" class="internal-link" target="_self" rel="noopener nofollow">1,2,1],[4,3,4],[3,2,1],[1,1,1</a>);<br>
// The initial rectangle (4x3) looks like:<br>
// 1 2 1<br>
// 4 3 4<br>
// 3 2 1<br>
// 1 1 1<br>
subrectangleQueries.getValue(0, 2); // return 1<br>
subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);<br>
// After this update the rectangle looks like:<br>
// 5 5 5<br>
// 5 5 5<br>
// 5 5 5<br>
// 5 5 5<br>
subrectangleQueries.getValue(0, 2); // return 5<br>
subrectangleQueries.getValue(3, 1); // return 5<br>
subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);<br>
// After this update the rectangle looks like:<br>
// 5   5   5<br>
// 5   5   5<br>
// 5   5   5<br>
// 10  10  10<br>
subrectangleQueries.getValue(3, 1); // return 10<br>
subrectangleQueries.getValue(0, 2); // return 5 ^ix1<br>
Example 2:<br>
Input<br>
["SubrectangleQueries","getValue","updateSubrectangle","getValue","getValue","updateSubrectangle","getValue"]<br>
[<a data-href="[1,1,1],[2,2,2],[3,3,3" href="https://sunha20.github.io/digital-garden/[1,1,1],[2,2,2],[3,3,3" class="internal-link" target="_self" rel="noopener nofollow">[1,1,1],[2,2,2],[3,3,3</a>],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]<br>
Output<br>
[null,1,null,100,100,null,20]<br>
Explanation<br>
SubrectangleQueries subrectangleQueries = new SubrectangleQueries(<a data-href="1,1,1],[2,2,2],[3,3,3" href="https://sunha20.github.io/digital-garden/1,1,1],[2,2,2],[3,3,3" class="internal-link" target="_self" rel="noopener nofollow">1,1,1],[2,2,2],[3,3,3</a>);<br>
subrectangleQueries.getValue(0, 0); // return 1<br>
subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);<br>
subrectangleQueries.getValue(0, 0); // return 100<br>
subrectangleQueries.getValue(2, 2); // return 100<br>
subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);<br>
subrectangleQueries.getValue(2, 2); // return 20<br>Constraints:<br>
<br>There will be at most&nbsp;500&nbsp;operations considering both methods:&nbsp;updateSubrectangle&nbsp;and&nbsp;getValue.
<br>1 &lt;= rows, cols &lt;= 100
<br>rows ==&nbsp;rectangle.length
<br>cols == rectangle[i].length
<br>0 &lt;= row1 &lt;= row2 &lt; rows
<br>0 &lt;= col1 &lt;= col2 &lt; cols
<br>1 &lt;= newValue, rectangle[i][j] &lt;= 10^9
<br>0 &lt;= row &lt; rows
<br>0 &lt;= col &lt; cols
<br><br>
<br>이번에는 간단한 클래스 만들기 문제라서,,, 별로 어렵지 않았다.
<br>어제 정기세션에서도 느꼈지만, 문제 이해를 돕는 설명을 이렇게 적으면 되겠다. 하는 걸 배움. 다음에 연습해볼것 (참고:<a data-tooltip-position="top" aria-label="1476. Subrectangle Queries > ^ix1cra" data-href="1476. Subrectangle Queries#^ix1cra" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1476.-subrectangle-queries.html#^ix1cra" class="internal-link" target="_self" rel="noopener nofollow">Explanation</a>)
<br>class SubrectangleQueries {
    private int[][] rectangle;
    public SubrectangleQueries(int[][] rectangle) {
        this.rectangle = rectangle;
    }
    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {
        for (int r=row1; r&lt;=row2; r++) {
            for (int c=col1; c&lt;=col2; c++){
                rectangle[r][c] = newValue;
            }
        }
    }

    public int getValue(int row, int col) {
        return rectangle[row][col];
    }
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1476.-subrectangle-queries.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1476. Subrectangle Queries.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 25 Jun 2024 03:46:47 GMT</pubDate></item><item><title><![CDATA[1309.동물원]]></title><description><![CDATA[ 
 <br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a><br><br><br>어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.<br><img alt="" src="https://www.acmicpc.net/upload/201004/dnfl.JPG" referrerpolicy="no-referrer" style="width: 164px; max-width: 100%;"><br>이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.<br>동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.<br><br>첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.<br><br>첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.<br><br>4<br><br>41<br><br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/joon8409" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/joon8409" target="_blank">joon8409</a>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/xhark" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/xhark" target="_blank">xhark</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><br><br>
<br>brute-force로..는 안될 것같음.
<br>다이나믹
<br>와씨 사자를 몇마리 이상 배치해야한다는 말이 없음…
<br>추가되는 경우의 수 → x/오/왼<br><br><br><br><br><br>\3 → xrl<br><br>2 → xr<br><br>2 → xl<br>=&gt; x → 3 / r → 2 / l → 2 (원래 111)<br><br>
<br>dp 사용시, 처음에 입력값들을 예외처리로 미리 빼주는 거 잊지 말기.
<br>아악 나누기 안해줌.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1309.동물원.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1309.동물원.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 25 May 2024 15:36:53 GMT</pubDate><enclosure url="https://www.acmicpc.net/upload/201004/dnfl.JPG" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.acmicpc.net/upload/201004/dnfl.JPG"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[12865. 평범한 배낭]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:골드/5" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#골드/5</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener nofollow">#코딩테스트</a><br>
<a href="https://sunha20.github.io/digital-garden?query=tag:골드/5" class="tag" target="_blank" rel="noopener nofollow">#골드/5</a><br><br><br>이 문제는 아주 평범한 배낭에 관한 문제이다.<br>한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.<br>준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.<br><br>첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.<br>입력으로 주어지는 모든 수는 정수이다.<br><br>한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.<br><br>4 7<br>
6 13<br>
4 8<br>
3 6<br>
5 12<br><br>14<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/Acka" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/Acka" target="_blank">Acka</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/kpqi5858" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/kpqi5858" target="_blank">kpqi5858</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/leedongbin" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/leedongbin" target="_blank">leedongbin</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/riroan" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/riroan" target="_blank">riroan</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/skyoliver" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/skyoliver" target="_blank">skyoliver</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/148" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/148" target="_blank">배낭 문제</a>
<br><br>
<br>다이나믹 프로그래밍 문제 → 최적부분구조를 어떻게 증명할것인가… → 안될 것같은데

<br>반례:

<br>(가치,무게) → (1, 1) (2, 1) (3, 1) (4, 1) (5, 4) / 최대 무게 4 인경우
<br>가치 5를 선택하는 것보다, 가치 4321을 선택하는 것이 더 큼.


<br>단순히 무게가 초과하지 않는 한 가치가 높은 것부터 선택한다는 풀이는 잘못됨.


<br>(무게-가치)로 판단을 해볼까? → 안<br>
```python<br>
import sys  
<br>def backpack():<br>
N, K = map(int, sys.stdin.readline().split())  <br>cnt = 0<br>
result = 0<br>
inDict = {}  <br>while N &gt; 0:<br>
N -= 1<br>
w, v = map(int, sys.stdin.readline().split())<br>
if v - w not in inDict:<br>
inDict[v - w] = [w, v]<br>
else:<br>
inDict[v - w]  <br>lst = sorted(inDict.keys(), key=lambda x: -x)  <br>for k, v in inDict.items():<br>
if v[0] &gt; K:<br>
continue  <br>result += v[1]<br>
K -= v[0]  <br>print(result)  <br>if name == "main":<br>
backpack()<br>- 같은 key에 추가… 하려면 복잡..

- 그냥 일단 다 돌려보자. 가능한 조합을 다? 시간 절대 안될 것같은데…
- 
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/12865.-평범한-배낭.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/12865. 평범한 배낭.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 05 Mar 2024 06:14:42 GMT</pubDate></item><item><title><![CDATA[1406. 에디터]]></title><description><![CDATA[ 
 <br>
<br>linkedList로도 풀어보기. ✅ 2024-07-03
<br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-07-03<br>Link: <a rel="noopener nofollow" class="external-link" href="https://acmicpc.net/problem/1406" target="_blank">https://acmicpc.net/problem/1406</a><br>Level: s2<br>Category: <br>Stack<br>LinkedList<br>Success: ⭕<br><br><br><br>한 줄로 된 간단한 에디터를 구현하려고 한다. 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 최대 600,000글자까지 입력할 수 있다.<br>이 편집기에는 '커서'라는 것이 있는데, 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 문장의 맨 뒤(마지막 문자의 오른쪽), 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다.<br>이 편집기가 지원하는 명령어는 다음과 같다.<br><br>초기에 편집기에 입력되어 있는 문자열이 주어지고, 그 이후 입력한 명령어가 차례로 주어졌을 때, 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 구하는 프로그램을 작성하시오. 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 위치하고 있다고 한다.<br><br>첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M&nbsp;≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.<br><br>첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.<br><br>abcd<br>
3<br>
P x<br>
L<br>
P y<br><br>abcdyx<br><br>abc<br>
9<br>
L<br>
L<br>
L<br>
L<br>
L<br>
P x<br>
L<br>
B<br>
P y<br><br>yxabc<br><br>dmih<br>
11<br>
B<br>
B<br>
P x<br>
L<br>
B<br>
B<br>
B<br>
P y<br>
D<br>
D<br>
P z<br><br>yxz<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/25" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/25" target="_blank">Croatian Highschool Competitions in Informatics</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/51" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/51" target="_blank">2004</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/294" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/294" target="_blank">National Competition #1 - Juniors</a>&nbsp;2번<br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author5" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/author5" target="_blank">author5</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>
<br>메모리 제한을 수정한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>
<br>시간 제한을 수정한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/naong606" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/naong606" target="_blank">naong606</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/wkd48632" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/wkd48632" target="_blank">wkd48632</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/71" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/71" target="_blank">스택</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/154" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/154" target="_blank">연결 리스트</a>
<br><br>
<br>Java 8: 2 초
<br>Java 8 (OpenJDK): 2 초
<br>Kotlin (JVM): 2 초
<br>C# 6.0 (Mono): 2 초
<br>C# 3.0 (Mono): 2 초
<br>VB.NET 2.0 (Mono): 2 초
<br>VB.NET 4.0 (Mono): 2 초
<br><br>
<br>시간 제한 때문에 Linked list를 사용하는 게 용이 → 삽입, 삭제에 시간이 덜 듬.
<br><br>
<br>조회의 경우 node를 타고 가야 하기에 시간이 걸림.
<br>삽입 삭제시 앞뒤로 움직이는 것, → linked
<br>삽입 삭제 시 뒤에 요소들을 이동시키는 것 → array 
<br>+) LinkedList는 초기값 설정안
<br><br>import java.util.*;  
import java.io.*;  
  
public class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        List&lt;String&gt; text = new LinkedList&lt;&gt;(Arrays.asList(br.readLine().split("")));  
        int end = text.size();  
        int start = 0;  
        int cursor = end;  
  
        int M = Integer.parseInt(br.readLine());  
  
        for (int m=0; m&lt;M; m++) {  
            String inst = br.readLine();  
            if (inst.startsWith("L") &amp;&amp; cursor != start) {  
                cursor -= 1;  
                continue;  
            }  
            if (inst.startsWith("D") &amp;&amp; cursor != end) {  
                cursor += 1;  
                continue;  
            }  
            if (inst.startsWith("B") &amp;&amp; cursor != start) {  
                text.remove(cursor-1);  
                cursor -= 1;  
                end -= 1;  
                continue;  
            }  
            if (inst.startsWith("P")) {  
                text.add(cursor, inst.substring(2));  
                cursor += 1;  
                end += 1;  
            }  
        }  
  
        System.out.println(String.join("",text));  
    }  
}
복사<br><br>
<br>매번 움직이고 추가하는게 아니라, 다 정리해두고 마지막에 차례대로 접근해서 처리해버리는 거 어때? → map 사용
<br>java map iteration
<br>// 방법1
Iterator&lt;String&gt; keys = map.keySet().iterator();  
while (keys.hasNext()) {  
    String key = keys.next();  
    System.out.println(String.format("키 : %s, 값 : %s", key, map.get(key)));  
}  
// 방법2  
for (Map.Entry&lt;String, String&gt; elem : map.entrySet()) {  
    System.out.println(String.format("키 : %s, 값 : %s", elem.getKey(), elem.getValue()));  
}  
// 방법3  
for (String key : map.keySet()) {  
    System.out.println(String.format("키 : %s, 값 : %s", key, map.get(key)));  
}

복사<br>
<br>
hashmap → 순서보장 안됨

<br>순서보장하려면 → LinkedHashMap 사용


<br>
아 map으로 하면 같은 key가 안된다는 단점이 있음…. → multivaluemap의 경우에는 중복 key가 가능 하지만, 순서보장이 안됨.

<br>
아니지 순서보장을 할 필요가 없지?

<br><br>
<br>stack은 Arrays.asList 말고 addAll(List.of(~))를 사용해야함…
<br>출력 순서 신경쓰기.
<br><br>import java.util.*;  
import java.io.*;  
  
public class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
        Stack&lt;String&gt; textL = new Stack&lt;&gt;();  
        Stack&lt;String&gt; textR = new Stack&lt;&gt;();  
        textL.addAll(List.of(br.readLine().split("")));  
        String resultL = "";  
        String resultR = "";  
        int M = Integer.parseInt(br.readLine());  
  
        for (int m=0; m&lt;M; m++) {  
            String inst = br.readLine();  
            if (inst.startsWith("L") &amp;&amp; !textL.isEmpty()) {  
                textR.push(textL.pop());  
                continue;  
            }  
            if (inst.startsWith("D") &amp;&amp; !textR.isEmpty()) {  
                textL.push(textR.pop());  
                continue;  
            }  
            if (inst.startsWith("B") &amp;&amp; !textL.isEmpty()) {  
                textL.pop();  
                continue;  
            }  
            if (inst.startsWith("P")) {  
                textL.push(inst.substring(2));  
            }  
        }  
  
        while (!textL.isEmpty()) {resultL = textL.pop() + resultL;}  
        while (!textR.isEmpty()) {resultR = resultR + textR.pop();}  
  
        bw.write(resultL+resultR);  
        br.close();  
        bw.close();  
    }  
}
복사<br>
<br>String builder로 reverse하기…

<br><a data-tooltip-position="top" aria-label="https://onlyfor-me-blog.tistory.com/317" rel="noopener nofollow" class="external-link" href="https://onlyfor-me-blog.tistory.com/317" target="_blank">[JAVA] StringBuilder란? StringBuilder 사용법</a>


<br><br>import java.util.*;  
import java.io.*;  
  
public class Main {  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));  
        Stack&lt;String&gt; textL = new Stack&lt;&gt;();  
        Stack&lt;String&gt; textR = new Stack&lt;&gt;();  
        textL.addAll(List.of(br.readLine().split("")));  
        int M = Integer.parseInt(br.readLine());  
  
        for (int m=0; m&lt;M; m++) {  
            String inst = br.readLine();  
            if (inst.startsWith("L") &amp;&amp; !textL.isEmpty()) {  
                textR.push(textL.pop());  
                continue;  
            }  
            if (inst.startsWith("D") &amp;&amp; !textR.isEmpty()) {  
                textL.push(textR.pop());  
                continue;  
            }  
            if (inst.startsWith("B") &amp;&amp; !textL.isEmpty()) {  
                textL.pop();  
                continue;  
            }  
            if (inst.startsWith("P")) {  
                textL.push(inst.substring(2));  
            }  
        }  
  
        StringBuilder sb = new StringBuilder();  
        while (!textL.isEmpty()) {  
            sb.append(textL.pop());  
        }  
        sb.reverse();  
        while (!textR.isEmpty()) {  
            sb.append(textR.pop());  
        }  
  
        bw.write(sb.toString());  
        br.close();  
        bw.flush();  
        bw.close();  
    }  
}
복사<br>
<br>string 연산이 꽤나 많이 시간을 잡아먹는 구나,,,,
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.tcpschool.com/java/java_collectionFramework_iterator" rel="noopener nofollow" class="external-link" href="https://www.tcpschool.com/java/java_collectionFramework_iterator" target="_blank">ListIterator</a>
<br><br>import java.util.*;
import java.io.*;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        List&lt;String&gt; text = new LinkedList&lt;&gt;(Arrays.asList(br.readLine().split("")));
        ListIterator&lt;String&gt; iter = text.listIterator();
        while (iter.hasNext()) iter.next();

        int M = Integer.parseInt(br.readLine());
        for (int m=0; m&lt;M; m++) {
            String inst = br.readLine();
            if (inst.startsWith("L") &amp;&amp; iter.hasPrevious()) {
                iter.previous();
                continue;
            }
            if (inst.startsWith("D") &amp;&amp; iter.hasNext()) {
                iter.next();
                continue;
            }
            if (inst.startsWith("B") &amp;&amp; iter.hasPrevious()) {
                iter.previous();
                iter.remove();
                continue;
            }
            if (inst.startsWith("P")) {
                iter.add(inst.substring(2));
            }
        }

        bw.write(String.join("",text));
        br.close();
        bw.flush();
        bw.close();
    }
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1406.-에디터.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1406. 에디터.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Wed, 03 Jul 2024 11:47:13 GMT</pubDate></item><item><title><![CDATA[1260. DFS와 BFS]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-27<br>Link: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1260" target="_blank">https://www.acmicpc.net/problem/1260</a><br>Level: s2<br>Category: <br><a data-href="BFS, DFS" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/graph/bfs,-dfs.html" class="internal-link" target="_self" rel="noopener nofollow">BFS, DFS</a><br>Success: ⭕<br>Git: -<br><br><br><br>그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다.&nbsp;정점 번호는 1번부터 N번까지이다.<br><br>첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.<br><br>첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.<br><br>4 5 1<br>
1 2<br>
1 3<br>
1 4<br>
2 4<br>
3 4<br><br>1 2 4 3<br>
1 2 3 4<br><br>5 5 3<br>
5 4<br>
5 2<br>
1 2<br>
3 4<br>
3 1<br><br>3 1 2 5 4<br>
3 1 4 2 5<br><br>1000 1 1000<br>
999 1000<br><br>1000 999<br>
1000 999<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author5" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/author5" target="_blank">author5</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/dfghcvb11" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/dfghcvb11" target="_blank">dfghcvb11</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/doju" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/doju" target="_blank">doju</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/doju" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/doju" target="_blank">doju</a>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/pumpyboom" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/pumpyboom" target="_blank">pumpyboom</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/7" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/7" target="_blank">그래프 이론</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/11" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/11" target="_blank">그래프 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/126" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/126" target="_blank">너비 우선 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/127" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/127" target="_blank">깊이 우선 탐색</a>
<br><br>
<br>visited 초기화 과정이 필요..! → 그냥 2개 만들 → 아니다… flag num을 그냥 parameter로 보내주자.
<br>import java.util.*;  
import java.io.*;  
  
public class Main {  
    static int[][] gp;  
    static int[] visited;  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int N = Integer.parseInt(st.nextToken()); // # of node  
        int M = Integer.parseInt(st.nextToken()); // # of line  
        int V = Integer.parseInt(st.nextToken()); // start node  
  
        // create graph        gp = new int[N+1][N+1];  
        visited = new int[N+1];  
  
        // fill graph  
        for (int m=0; m&lt;M; m++) {  
            st = new StringTokenizer(br.readLine());  
            int x = Integer.parseInt(st.nextToken());  
            int y = Integer.parseInt(st.nextToken());  
            gp[x][y] = 1;  
            gp[y][x] = 1;  
        }  
        visited[V] = 1;  
        System.out.println(dfs(V, 1));  
        visited[V] = 2;  
        System.out.println(bfs(V, 2));  
        br.close();  
    }  
  
    public static String dfs(int now, int flag){  
        String result = now + "";  
        for (int i=0; i&lt;gp.length; i++) {  
            if (gp[now][i] == 1 &amp;&amp; visited[i] != flag) {  
                visited[i] = flag;  
                 result += (" " + dfs(i, flag));  
            }  
        }  
        return result;  
    }  
  
    public static String bfs(int start, int flag){  
        Queue&lt;Integer&gt; que = new LinkedList&lt;Integer&gt;();  
        que.offer(start);  
        String result="";  
        while (!que.isEmpty()){  
            int now = que.poll();  
            result += now + " ";  
            for (int i=0; i&lt;gp.length; i++){  
                if (gp[now][i] == 1 &amp;&amp; visited[i] != flag) {  
                    visited[i] = flag;  
                    que.offer(i);  
                }  
            }  
        }  
        return result;  
    }  
  
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1260.-dfs와-bfs.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1260. DFS와 BFS.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Thu, 27 Jun 2024 10:25:28 GMT</pubDate></item><item><title><![CDATA[1157. 단어 공부]]></title><description><![CDATA[ 
 <br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a><br><br><br>알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.<br><br>첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.<br><br>첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.<br><br>Mississipi<br><br>?<br><br>zZa<br><br>Z<br><br>z<br><br>Z<br><br>baaa<br><br>A<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author5" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/author5" target="_blank">author5</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jejeje8" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jejeje8" target="_blank">jejeje8</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/kimhs" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/kimhs" target="_blank">kimhs</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/rnjs4197" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/rnjs4197" target="_blank">rnjs4197</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><br><br>
<br>굳이 BufferedReader를 쓸 필요가 없음… <a data-href="BufferedReader" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/bufferedreader.html" class="internal-link" target="_self" rel="noopener nofollow">BufferedReader</a>
<br>//생략
    public void Solution2_noBuffer() throws IOException {  
        int[] cntList = new int[65+26];  
        byte[] inputByteList = new byte[8192];  
        int max=0;  
        int same=0;  
        InputStream is = System.in;  
        is.read(inputByteList);  
  
  
        for (int i=0; i&lt;inputByteList.length; i++) {  
            byte b = inputByteList[i];  
            System.out.println(b);  
            cntList[b] += 1;  
        }  
  
        for (int i=65; i&lt;cntList.length; i++) {  
            if(cntList[i] &gt; max) {  
                max = i;  
                same = 0;  
            } else if (cntList[i] == max) {  
                same = 1;  
            }  
        }  
  
        if (same == 0) {  
            System.out.println(max);  
        }else {  
            System.out.println("?");  
        }  
    }  
    public static void main(String[] args) throws IOException {  
        new Main().Solution2_noBuffer();  
    }  
}
복사<br>
<br>
byte로 받는 걸로 바꾸다가 생긴 문제점… upper case로만 치는 거 어떻게 할건데?

<br>다른 사람 풀이의 &amp;31이 그 방법인가 싶은데… <a data-tooltip-position="top" aria-label="https://gimkuku0708.tistory.com/19" rel="noopener nofollow" class="external-link" href="https://gimkuku0708.tistory.com/19" target="_blank">(C++) 2018 KAKAO BLIND RECRUITMENT[1차] : 뉴스 클러스터링</a> → 3. 알파벳들을 모두 대소문자를 구분없는 숫자로 바꾼다 =&gt; 아스키연산 &amp;31 부분.
<br>A:65 = 0010 0001
<br>a:97= 0110 0001
<br>&amp;31 = 0001 1111 = 1+2+4+8+16 = 31

<br>차이가 있는 32bit 자리는 0으로
<br>쓸데없이 값을 크게하는 64bit자리도으로
<br>나며지는 1이면 1, 0이면 0으로 출력.
<br>즉 → 아래 5bit만 살려주겠다!


<br>&amp;32 = 0100 0000 → 대소문자 바꾸기. 32bit자리를 크고 꺼주기…

<br>아 이건 AND가 아니라 XOR로 해서 대소문자 바꾸기로 써줄 수 있음.
<br>주어진 32bit 자리가 1이면 11이라 0 / 0이면 01이라 1




<br>
그리고 byte list의 capacity말고, size를 반환하는 방법도 문제.

<br>primitive type의 경우에는 length변수만 사용가능한데 이건 capacity를 반환.
<br>처음에는 while문으로 buffer의 값이 0보다 크면, 으로 했는데 잘 작동 안함
<br>for (int i=0;buf[i]&gt;64;i++) 와 같은 방법으로 해결


<br>
출력할때는 |64로 대문자로 만들어주기.

<br><br>:런타임 에러&nbsp;(ArrayIndexOutOfBounds)<br>
<br>input byte개수가 최대 1000000라는 걸 간과
<br><br>:틀]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1157.-단어-공부.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1157. 단어 공부.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 25 May 2024 15:36:52 GMT</pubDate></item><item><title><![CDATA[11724. 연결 요소의 개수]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-07-01<br>Link: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/11724" target="_blank">https://www.acmicpc.net/problem/11724</a><br>Level: s2<br>Category: <br><a data-href="BFS, DFS" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/graph/bfs,-dfs.html" class="internal-link" target="_self" rel="noopener nofollow">BFS, DFS</a><br>Success: ⭕ +a<br>Git: -<br><br><br><br>방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.<br><br>첫째 줄에 연결 요소의 개수를 출력한다.<br><br>6 5<br>
1 2<br>
2 5<br>
5 1<br>
3 4<br>
4 6<br><br>2<br><br>6 8<br>
1 2<br>
2 5<br>
5 1<br>
3 4<br>
4 6<br>
5 4<br>
2 4<br>
2 3<br><br>1<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/seoo2001" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/seoo2001" target="_blank">seoo2001</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/YunGoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/YunGoon" target="_blank">YunGoon</a>
<br>잘못된 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/songjuh" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/songjuh" target="_blank">songjuh</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/7" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/7" target="_blank">그래프 이론</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/11" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/11" target="_blank">그래프 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/126" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/126" target="_blank">너비 우선 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/127" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/127" target="_blank">깊이 우선 탐색</a>
<br><br>import java.util.*;  
import java.io.*;  
  
public class Main {  
    static int[][] gp;  
    static int[] visited;  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        String[] line = br.readLine().split(" ");  
        int N = Integer.parseInt(line[0]);              // node 개수  
        int M = Integer.parseInt(line[1]);              // 간선 개수  
  
        gp = new int[N + 1][N + 1];  
        visited = new int[N + 1];  
        for (int m = 0; m &lt; M; m++) {  
            line = br.readLine().split(" ");  
            int x = Integer.parseInt(line[0]);  
            int y = Integer.parseInt(line[1]);  
            gp[x][y] = 1;  
            gp[y][x] = 1;  
        }  
  
        int cnt = 0;  
        for (int n = 1; n &lt;= N; n++) {  
            if (visited[n] == 0) {  
                dfs(n);  
                cnt ++;  
            }  
        }  
        System.out.println(cnt);  
    }  
  
    static void dfs(int N) {  
        visited[N] = 1;  
        for (int i = 1; i &lt; gp.length; i++) {  
            if (gp[N][i] == 1 &amp;&amp; visited[i] == 0) dfs(i);  
        }  
    }  
}
복사<br>bfs로도 풀어보기..]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/11724.-연결-요소의-개수.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/11724. 연결 요소의 개수.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Mon, 01 Jul 2024 09:02:33 GMT</pubDate></item><item><title><![CDATA[1249. 보급로]]></title><description><![CDATA[ 
 <br><br>2차 세계 대전에서 연합군과 독일군의 전투가 점점 치열해지고 있다.  <br>전투가 진행중인 지역은 대규모 폭격과 시가전 등으로 인해 도로 곳곳이 파손된 상태이다.  <br>그림 1(a)에서와 같이 도로들은 전투로 인해 트럭이나 탱크와 같은 차량들이 지날 갈 수 없다.  <br>전투에서 승리하기 위해서는 기갑사단과 보급부대가 신속하게 이동하기 위한 도로가 있어야 한다.  <br>공병대는 출발지(S) 에서 도착지(G)까지 가기 위한 도로 복구 작업을 빠른 시간 내에 수행하려고 한다.  <br>도로가 파여진 깊이에 비례해서 복구 시간은 증가한다.  <br>출발지에서 도착지까지 가는 경로 중에 복구 시간이 가장 짧은 경로에 대한 총 복구 시간을 구하시오.  <br>깊이가 1이라면 복구에 드는 시간이 1이라고 가정한다.  <br>&nbsp;<br><img src="https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&amp;fileId=AV2XdCCqDhkBBASl" referrerpolicy="no-referrer"> 그림 1 (a) 파손된 도로&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;(b) 지도 형태와 이동 방향<br>지도 정보는 그림1(b)와 같이 2차원 배열 형태로 표시된다.  <br>출발지는 좌상단의 칸(S)이고 도착지는 우하단의 칸(G)가 된다.  <br>이동 경로는 상하좌우 방향으로 진행할 수 있으며, 한 칸씩 움직일 수 있다.  <br>지도 정보에는 각 칸마다 파여진 도로의 깊이가 주어진다. 현재 위치한 칸의 도로를 복구해야만 다른 곳으로 이동할 수 있다.  <br>&nbsp;<br><img src="https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&amp;fileId=AV2XdHuaDhoBBASl" referrerpolicy="no-referrer"><br>그림 2 지도 정보<br>이동하는 시간에 비해 복구하는데 필요한 시간은 매우 크다고 가정한다.  <br>따라서, 출발지에서 도착지까지 거리에 대해서는 고려할 필요가 없다.  <br>지도 정보는 그림2에서 보듯이 2차원 배열의 형태이다.  <br>출발지(S)와 도착지(G)는 좌상단과 우하단이 되고 입력 데이터에서는 0으로 표시된다.  <br>출발지와 도착지를 제외한 곳이 0인 것은 복구 작업이 불필요한 곳이다.  <br>다음과 같은 지도에서 복구 작업 시간이 최소인 시간은 2이고 회색으로 칠해진 경로가 된다.  <br>&nbsp;<br><img src="https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&amp;fileId=AV2Xe9hKDikBBASl" referrerpolicy="no-referrer"><br>[입력]  <br>가장 첫 줄은 전체 테스트케이스의 수이다.  <br>각 테스트 케이스마다 지도의 크기(N x N)가 주어진다. 지도의 크기는 최대 100 x 100이다.  <br>그 다음줄 부터 지도의 크기만큼 2차원 배열 형태의 지도 정보가 주어진다.  <br>&nbsp;<br>
[출력]  <br>각 테스트 케이스의 답을 순서대로&nbsp;출력하며, 각 케이스마다 줄의 시작에 “#C”를 출력하여야 한다.  <br>이때 C는 케이스의 번호이다.  <br>같은 줄에 빈 칸을 하나 두고, 주어진 입력에서 출발지에서 도착지까지 가는 경로 중에 복구 작업에 드는 시간이 가장 작은 경로의 복구 시간을 출력하시오.<br>입력<br>
10<br>
4<br>
0100<br>
1110<br>
1011<br>
1010<br>
6<br>
011001<br>
010100<br>
010011<br>
101001<br>
010101<br>
111010<br>
8<br>
. . .<br>출력<br>
#1 2<br>
#2 2<br>
. . .]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1249.-보급로.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1249. 보급로.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Thu, 24 Oct 2024 04:44:20 GMT</pubDate><enclosure url="https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&amp;fileId=AV2XdCCqDhkBBASl" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&amp;fileId=AV2XdCCqDhkBBASl"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[1074. Z]]></title><description><![CDATA[ 
 <br><br><br>한수는 크기가 2N&nbsp;× 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.<br><img alt="" src="https://u.acmicpc.net/21c73b56-5a91-43aa-b71f-9b74925c0adc/Screen%20Shot%202020-12-02%20at%208.09.46%20AM.png" referrerpolicy="no-referrer" style="width: 150px; max-width: 100%;"><br>N &gt; 1인 경우, 배열을 크기가 2N-1&nbsp;× 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.<br>다음 예는 22&nbsp;× 22&nbsp;크기의 배열을 방문한 순서이다.<br><img alt="" src="https://u.acmicpc.net/adc7cfae-e84d-4d5c-af8e-ee011f8fff8f/Screen%20Shot%202020-12-02%20at%208.11.17%20AM.png" referrerpolicy="no-referrer" style="width: 280px; max-width: 100%;"><br>N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.<br>다음은 N=3일 때의 예이다.<br><img alt="" src="https://u.acmicpc.net/d3e84bb7-9424-4764-ad3a-811e7fcbd53f/Screen%20Shot%202020-12-30%20at%2010.50.47%20PM.png" referrerpolicy="no-referrer" style="width: 340px; max-width: 100%;"><br><br>첫째 줄에 정수 N, r, c가 주어진다.<br><br>r행 c열을 몇 번째로 방문했는지 출력한다.<br><br>
<br>1 ≤ N ≤ 15
<br>0 ≤ r, c &lt; 2N
<br><br>2 3 1<br><br>11<br><br>3 7 7<br><br>63<br><br>1 0 0<br><br>0<br><br>4 7 7<br><br>63<br><br>10 511 511<br><br>262143<br><br>10 512 512<br><br>786432<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>잘못된 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/hmw9309" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/hmw9309" target="_blank">hmw9309</a>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1074.-z.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1074. Z.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Thu, 24 Oct 2024 04:45:29 GMT</pubDate><enclosure url="https://u.acmicpc.net/21c73b56-5a91-43aa-b71f-9b74925c0adc/Screen%20Shot%202020-12-02%20at%208.09.46%20AM.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://u.acmicpc.net/21c73b56-5a91-43aa-b71f-9b74925c0adc/Screen%20Shot%202020-12-02%20at%208.09.46%20AM.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[11279. 최대 힙]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:실버/2" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실버/2</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener nofollow">#코딩테스트</a><br>
<a href="https://sunha20.github.io/digital-garden?query=tag:실버/2" class="tag" target="_blank" rel="noopener nofollow">#실버/2</a><br><br><br>널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.<br>
<br>배열에 자연수 x를 넣는다.
<br>배열에서 가장 큰 값을 출력하고,&nbsp;그 값을 배열에서 제거한다.
<br>프로그램은 처음에 비어있는 배열에서 시작하게 된다.<br><br>첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 231보다 작다.<br><br>입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.<br><br>13<br>
0<br>
1<br>
2<br>
0<br>
0<br>
3<br>
2<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br><br>0<br>
2<br>
1<br>
3<br>
2<br>
1<br>
0<br>
0<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/dantebald" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/dantebald" target="_blank">dantebald</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/spotky1004" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/spotky1004" target="_blank">spotky1004</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/1927" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1927" target="_blank">1927번. 최소 힙</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/11286" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/11286" target="_blank">11286번. 절댓값 힙</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/59" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/59" target="_blank">우선순위 큐</a>
<br><br>
<br>Java 8: 2 초
<br>Java 8 (OpenJDK): 2 초
<br>Java 11: 2 초
<br>Kotlin (JVM): 2 초
<br><br>
<br>오 이거 우선순위 큐 아닌가
<br>어떻게 구현 했었지… 
<br>deque없이 하려면 list에서는 가장 뒤에 걸 지웠을 때 시간복잡도가 작으니(남은 값들 옮길 필요 없음.) 오름차순으로 정렬.
<br>import sys  
  
def max_heap():  
N = int(sys.stdin.readline().rstrip())  
lst = []  
  
while N &gt; 0:  
N -= 1  
x = int(sys.stdin.readline().rstrip())  
  
if x != 0:  
lst.append(x)  
  
else:  
if len(lst) != 0:  
lst.sort()  
print(lst.pop())  
else:  
print(0)  
  
if __name__ == "__main__":  
max_heap()
복사<br>
<br>결과: 시간초과…
<br><br>
<br>
<a data-tooltip-position="top" aria-label="https://yoongrammer.tistory.com/81" rel="noopener nofollow" class="external-link" href="https://yoongrammer.tistory.com/81" target="_blank">[자료구조] 우선순위 큐 (Priority Queue) 개념 및 구현</a>

<br>
오 힙으로 구현해야하는데, 트리 다 까먹었는데….

<br>
파이썬 heap관련 모듈: heapq

<br>import sys, heapq  
  
  
def max_heap():  
N = int(sys.stdin.readline().rstrip())  
heap = []  
  
while N &gt; 0:  
N -= 1  
x = int(sys.stdin.readline().rstrip())  
  
if x != 0:  
heapq.heappush(heap, -x)  
  
else:  
if len(heap) != 0:  
print(-heapq.heappop(heap))  
else:  
print(0)  
  
if __name__ == "__main__":  
max_heap()

복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/11279.-최대-힙.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/11279. 최대 힙.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 02 Mar 2024 03:15:50 GMT</pubDate></item><item><title><![CDATA[1012. 유기농 배추]]></title><description><![CDATA[ 
 <br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a><br><br><br><br>차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고&nbsp;배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에&nbsp;효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아&nbsp;먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.<br>한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.<br><br><br>입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어종성공 → dfs 추가<br>import java.io.*;  
import java.util.*;  
  
public class Main {  
    static int[][] field;  
    static int[][] visited;  
    static final int[] X = {0,0,-1,1};  
    static final int[] Y = {-1,1,0,0};  
  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st;  
        int M, N, K;  
        int bug;  
        int T = Integer.parseInt(br.readLine());  
  
        for (int t = 0; t &lt; T; t++) {  
            // 밭 만들기  
            st = new StringTokenizer(br.readLine(), " ");  
            M = Integer.parseInt(st.nextToken());  
            N = Integer.parseInt(st.nextToken());  
            K = Integer.parseInt(st.nextToken());  
            field = new int[M][N];  
            visited = new int[M][N];  
  
            // 밭 채우기  
            for (int k = 0; k &lt; K; k++) {  
                st = new StringTokenizer(br.readLine(), " ");  
                int x = Integer.parseInt(st.nextToken());  
                int y = Integer.parseInt(st.nextToken());  
                field[x][y] = 1;  
            }  
  
            // 밭 탐색  
            bug = 0;  
            for (int n = 0; n &lt; N; n++) {  
                for (int m = 0; m &lt; M; m++) {  
                    if (field[m][n] == 1 &amp;&amp; visited[m][n] == 0) {  
                        //bfs(m, n);  
                        dfs(m, n);  
                        bug++;  
                    }  
                    visited[m][n] = 1;  
                }  
            }  
            System.out.println(bug);  
        }  
        br.close();  
  
    }  
  
    public static void dfs(int x, int y) {  
        visited[x][y] = 1;  
        int endX = field.length - 1;  
        int endY = field[0].length - 1;  
  
        for (int i = 0; i &lt; 4; i++) {  
            int nx = x + X[i];  
            int ny = y + Y[i];  
            if (nx &gt; endX || ny &gt; endY || nx &lt; 0 || ny &lt; 0) continue;  
            if (field[nx][ny] == 0 || visited[nx][ny] == 1) continue;  
            visited[nx][ny] = 1;  
            dfs(nx, ny);  
        }  
    }  
  
  
    public static void bfs(int x, int y) {  
        Queue&lt;List&lt;Integer&gt;&gt; que = new LinkedList&lt;&gt;();  
        que.offer(new ArrayList(Arrays.asList(x, y)));  
        int endX = field.length - 1;  
        int endY = field[0].length - 1;  
  
        while (!que.isEmpty()) {  
            List&lt;Integer&gt; nowNode = que.poll();  
            for (int i = 0; i &lt; 4; i++) {  
                int nx = nowNode.get(0) + X[i];  
                int ny = nowNode.get(1) + Y[i];  
                if (nx &gt; endX || ny &gt; endY || nx &lt; 0 || ny &lt; 0) continue;  
                if (field[nx][ny] == 0 || visited[nx][ny] == 1) continue;  
                que.offer(new ArrayList(Arrays.asList(nx, ny)));  
                visited[nx][ny] = 1;  
            }  
        }  
  
    }  
}
복사<br>
<br>오히려 dfs가 더 간단한것 같기도?
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1012.-유기농-배추.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1012. 유기농 배추.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Thu, 27 Jun 2024 06:46:28 GMT</pubDate></item><item><title><![CDATA[1107. 리모컨]]></title><description><![CDATA[ 
 <br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a><br><br><br>수빈이는 TV를 보고 있다. 수빈이는 채널을 돌리려고 했지만, 버튼을 너무 세게 누르는 바람에, 일부 숫자 버튼이 고장났다.<br>리모컨에는 버튼이 0부터 9까지 숫자, +와 -가 있다. +를 누르면 현재 보고있는 채널에서 +1된 채널로 이동하고, -를 누르면 -1된 채널로 이동한다. 채널 0에서 -를 누른 경우에는 채널이 변하지 않고, 채널은 무한대 만큼 있다.<br>수빈이가 지금 이동하려고 하는 채널은 N이다. 어떤 버튼이 고장났는지 주어졌을 때, 채널 N으로 이동하기 위해서 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오.<br>수빈이가 지금 보고 있는 채널은 100번이다.<br><br>첫째 줄에 수빈이가 이동하려고 하는 채널 N (0 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 고장난 버튼의 개수 M (0 ≤ M ≤ 10)이 주어진다. 고장난 버튼이 있는 경우에는 셋째 줄에는 고장난 버튼이 주어지며, 같은 버튼이 여러 번 주어지는 경우는 없다.<br><br>첫째 줄에 채널 N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지를 출력한다.<br><br>5457<br>
3<br>
6 7 8<br><br>6<br><br>100<br>
5<br>
0 1 2 3 4<br><br>0<br><br>500000<br>
8<br>
0 2 3 4 6 7 8 9<br><br>11117<br><br>100<br>
3<br>
1 0 5<br><br>0<br><br>14124<br>
0<br><br>5<br><br>1<br>
9<br>
1 2 3 4 5 6 7 8 9<br><br>2<br><br>80000<br>
2<br>
8 9<br><br>2228<br><br>예제 1의 경우 5455++ 또는 5459--<br><br><br>
<br>가장 가까운 곳은 어떻게 고를 것인가?

<br>100에서 +-누르는 수.
<br>못누르는 버튼 찾기
<br>위로 가장 가까운것 찾기
<br>아래로 가자 가까운 것 찾기
<br>비교
<br>최솟감 출력


<br>방법

<br>일단 그냥 반복


<br><br>5676인데<br>
78가 고장남<br>
<br>5 → +1
<br>6 → +1
<br>7 → 불가능! 

<br>up: 9
<br>down: 6


<br>6 → 앞의 영향을 받음

<br>up인경우: 0
<br>down인경우: 9


<br><br>5676인데<br>
789가 고장남<br>
<br>‘’
<br>‘’
<br>7

<br>up → 0 → 2번을 7로…?안됨 8로…? 안됨 9로 안됨… 0으로… → 1을 6으로
<br>down → ‘’


<br>6

<br>up → 0
<br>down: 9


<br><br>4321인데<br>
012가 고장남<br>
<br>4
<br>3
<br>2 

<br>up: 3
<br>down: 1 안됨 → 0 안됨 → 9 :: 2번 2안됨 → 1 안됨 → … 9 :: 1번 3으로…


<br>1

<br>up: 0
<br>down: 9


<br><br>4421인데<br>
012가 고장남<br>
<br>4
<br>3
<br>2 

<br>up: 3
<br>down: 1 안됨 → 0 안됨 → 9 :: 2번 3


<br>1

<br>up: 0
<br>down: 9


<br><br>
<br>이거 너무 복잡함
<br>일단 안전지대를 찾자
<br>+1 되어서 1이 올라가는 경우되는 경우
<br>-1 되어서 0이 되어 9로 내려가는 경우
<br>이 두경우를 표시해두는 거지

<br>flag = “UUDDN” → 위험한 경우


<br><br>
<br>일단 result를 위해 필요한 data

<br>자릿수 + 차이


<br>그냥 아래에서 부터 올라가도 될것같아.

<br>마지막에 그냥 숫자만 바꿔주면 되니까.
<br>그러려면 change point를 아는게 중요하겠네.


<br><br>import sys  
  
def remote_control():  
channel = int(sys.stdin.readline().rstrip())  
trialList = [abs(channel-100), 0,0]  
trialList[1] = list(map(int,str(channel)))  
trialList[2] = trialList[1][:]  
  
brokenNum = int(sys.stdin.readline().rstrip())  
  
if brokenNum == 0:  
print(len(str(channel)))  
exit()  
  
brokenBtns = list(map(int,sys.stdin.readline().split(" ")))  
availableBtns = ""  
for btn in range(10):  
if btn not in brokenBtns:  
availableBtns += str(btn)  
  
trialList[1] = to_upper_ch(trialList[1], availableBtns)  
trialList[2] = to_lower_ch(trialList[2], availableBtns)  
  
trialList[1] = abs(trialList[1] - channel) + len(str(trialList[1]))  
trialList[2] = abs(trialList[2] - channel) + len(str(trialList[2]))  
  
# T: 정상 / F: 고장 / U: 올림 가능한 경우(가장 가까운 괜찮은 버튼 +1) / D: 내림 가능한 경우 (가장 가까운 괜찮은 버튼 -1)print(trialList)  
print(min(trialList))  
def to_upper_ch(upChannel, availableBtns):  
idx = len(upChannel) - 1  
result = 0  
setMinIdx = -1  
while idx &gt;= 0:  
if str(upChannel[idx] % 10) not in availableBtns: # 누를 수 있는 버튼 이 아닌 경우 1씩 올려준다.  
upChannel[idx] += 1  
  
else:  
if upChannel[idx] &gt;= 10: # 자릿수 침범한 경우를 따져야함.  
upChannel[idx] %= 10 # 일의 자릿수만 남기기  
setMinIdx = idx # 이 인덱스 아랫자리부터는 최소 숫자로 변경 (자릿수 올림된 수기 때문에 아래를 최대한 작은 수로 맞춰는 것.)  
  
if idx == 0: # 1 올려주기  
upChannel = [1] + upChannel  
else:  
upChannel[idx - 1] = 1  
idx -= 1  
  
if setMinIdx != -1:  
set_min(upChannel, setMinIdx, int(availableBtns[0])) # 이 아래로는 가장 작은 숫자로 맞춤  
  
for n in upChannel: # 숫자로 합치기  
result = result * 10 + n  
  
return result  
  
  
def to_lower_ch(downChannel, availableBtns):  
idx = len(downChannel) - 1  
result = 0  
setMaxIdx = -1  
while idx &gt;= 0:  
if str(downChannel[idx] % 10) not in availableBtns: # 누를 수 있는 버튼 이 아닌 경우 1씩 빼준다.  
downChannel[idx] -= 1  
  
else:  
if downChannel[idx] &lt; 0: # 자릿수 침범한 경우를 따져야함.  
downChannel[idx] %= 10 # 일의 자릿수만 남기기  
setMaxIdx = idx # 이 인덱스 아랫자리부터는 최소 숫자로 변경 (자릿수 올림된 수기 때문에 아래를 최대한 작은 수로 맞춰는 것.)  
  
if idx == len(downChannel) - 1: # 1 올려주기  
downChannel = downChannel[1:]  
else:  
downChannel[idx - 1] -= 1  
idx -= 1  
  
set_min(downChannel, setMaxIdx, int(availableBtns[-1])) # 이 아래로는 가장 작은 숫자로 맞춤  
  
for n in downChannel: # 숫자로 합치기  
result = result * 10 + n  
  
return result  
  
def set_min(target, idx, num):  
for i in range(idx+1, len(target)):  
target[i] = num  
  
def set_max(target, idx, num):  
for i in range(idx+1, len(target)):  
target[i] = num  
  
if __name__ == "__main__":  
remote_control()
복사<br>
<br>자릿수를 따질 때는 각자리수 list로 다루는 게 편할듯.
<br><br>
<br>모든 숫자 버튼이 고장난 경우 ✅ 2024-04-04
<br>고장난 버튼이 없는 경우 ✅ 2024-04-04

<br>위에 둘다 버튼num 받아서 그게 10일때, 0일때 처


<br>0보다 작은 채널로 계산 할 경우 ✅ 2024-04-04

<br>계산 다하고 음수면 빼기

<br>다시 반례 ✅ 2024-04-04
<br>in: 0 / 2 / 0 1
<br>답: 3
<br>실: 1
<br>문제점: 음수가 나오면 제외하고 최솟값 계산하기로 했는데 로직상 음수가 나올 수 없음

<br>음수가 나오면, 그 자리 빼기 해줌..


<br>해결: 음수가 나올수 있게 → 내림받을 숫자가 더이상 없으면 그 자릿수를 그냥 삭제해버리는데, len이 1이면 -1로 유지하도록 만듬




<br>내림 부분에 수정안한 오류 ✅ 2024-04-04

<br>4321/3/012 에서 down side에 오류남 -1이 나올 수가 없는데
<br>idx가 가장 위의 자리를 가리킬 때를 따져야하는데, 1의 자리를 가리킬 때로, 오류를 수정하지 않음.


<br>수정오류: 자리수 침범이 있을 때, 해당 수를 mod를 통해 제대로된 수로 바꾸어 주어야하는데 그 구문을 빼놓 ✅ 2024-04-04

<br>위랑 같은 반례


<br>반례 1555/8/0 1 3 4 5 6 7 9 ✅ 2024-04-04

<br>setmin에 문제가 있어보임. → 숫자버튼으로 ㅣㅇ동한 경우가 2888 임. 2222여야하는데
<br>setmin, setmax idx 설정 위치 오류
<br>하나라도 숫자가 변하면 아래는 바꿔줘야하고
<br>위에는 지릿구 문제가 생기면 바꿔줘야함
<br>두개를 구분을 못함.
<br>또문제 답은 670인데 실제는 671이 나옴… 1은 어디서 나온거야? ✅ 2024-04-04

<br>1555

<br>up

<br>5→8 → 2
<br>5→8 → 2
<br>5→8 → 2
<br>1→2 *


<br>down

<br>5→2→8
<br>5→2→8
<br>5→2→8
<br>1→x *
<br>




<br>문제 → 자릿수 침범이 일어나면 위에 자릿수도 바뀌기 때문에 set min max idx를 침범을 받은 곳 까지 올려줘야함.

<br>또문제 바꾸었더니 자릿수 에 문제가 생긴듯. (9/5/9 8 7 6 5 → up의 경우 10이 아니라 0이 나옴) ✅ 2024-04-09






<br>또다시 2%로 돌아감

<br>찾은 반례:  199/1/9 → 4인데 14가 나옴.
<br>up의 겨우에 200이 나와야하는데, 110이 나옴? ✅ 2024-04-09

<br>아 위에 자리수에 +1 해줘야하는데 1로만 만들어버림..! +=오타남…


<br>99933/2/3 9 → 73인데 11050이 나옴.

<br>up이 200000이 나와버림..! 100000이 나와야하는데
<br>자리수 침해 해결하고 나서 1을 자리수만 남길 때 list 의 전체 idx가 변경된 경우에 문제가 생김…




<br><br><br>
<br>Stream은 나온지 얼마 안 된 기능이기 때문에, 내부 최적화가 기존에 비해 부족하다.
<br>많은 element에 대해 접근이 많은 상황에선 array나 collection가 좋다.
<br>collection의 경우 간접적으로 접근하기 때문에, stream보다 빠르긴 해도 array만큼 빠르진 않다.
<br>한 element에 대해 많은 연산이 필요한 경우 stream이 유리하다.
<br><br>import java.io.*;  
import java.util.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        // 입력받기  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        int channel = Integer.parseInt(br.readLine());  
        int chLen = (int) (Math.log10(channel) + 1);  
        int M = Integer.parseInt(br.readLine());  
  
        // case1: only press plus minus btn  
        int noNumBtn = press_up_and_down(100, channel);  
  
        /* 극단값 우선 처리  
         if # of broken = 10;            have no choice but to press plus minus btn         */        if (M == 10) {  
            System.out.println(noNumBtn);  
            return;  
        }  
        if (M == 0) {  
            System.out.println(Math.min(noNumBtn, chLen));  
            return;  
        }  
  
        // 입력 데이터 추가 처리  
        /// broken  
        List&lt;Integer&gt; broken = new ArrayList&lt;&gt;();  
        for (String s: br.readLine().split(" ")) {  
            broken.add(Integer.parseInt(s));  
        }  
  
        // case2: 목표 채널보다 위로 가서 -버튼 사용  
        // case3: 목표 채널 보다 아래로 가서 +버튼 사용  
        int up = go_to_upperbound(channel, broken);  
        int down = go_to_lowerbound(channel, broken);  
        int numBtn =  Math.min(up,down);  
  
        // 최솟값 출력  
        System.out.println(Math.min(noNumBtn, numBtn));  
  
    }  
    public static int press_up_and_down(int target, int now) {  
        return (now&gt;target? now-target: target-now);  
    }  
  
    public static int go_to_upperbound(int ch, List&lt;Integer&gt; broken) {  
        int target = ch;  
        int chLen = (int) Math.log10(ch) + 1;  
  
        int newCh = 0;  
        int btn;  
        for (int i=1; i&lt;=Math.pow(10,chLen-1) ; i*=10) {  
            btn = target % 10;  
            target /= 10;  
            for (int j=0; j&lt;10; j++) {  
                if (!broken.contains(btn)){  
                    newCh += (btn * i);  
                    break;  
                }  
                if (j==9) {  
                    return ch+100; //noBtn 보다 항상 큰수  
                }  
                btn++;  
  
            }  
        }  
        int newChLen = (int) Math.log10(newCh) + 1;  
  
        return newChLen + press_up_and_down(ch, newCh);  
    }  
  
    public static int go_to_lowerbound(int ch,  List&lt;Integer&gt; broken) {  
        int target = ch;  
        int chLen = (int) Math.log10(ch) + 1;  
  
        int newCh = ch;  
        int btn;  
        for (int i=1; i&lt;=Math.pow(10,chLen-1); i*=10) {  
            btn = target % (i*10);  
            for (int j=0; j&lt;10; j++) {  
                if (!broken.contains(btn)){  
                    newCh += (btn * i);  
                    break;  
                }  
                btn--;  
  
                if (j==9) {  
                    return ch+100; //noBtn 보다 항상 큰수  
                }  
  
                if (btn == -1) {  
                    btn = 9;  
                    target -= 10*i;  
                }  
  
  
            }  
        }  
        int numBtn = (int) Math.log10(newCh) + 1;  
        int c = press_up_and_down(ch, newCh);  
  
        return numBtn + press_up_and_down(ch, newCh);  
    }  
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1107.-리모컨.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1107. 리모컨.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Mon, 08 Jul 2024 06:23:52 GMT</pubDate></item><item><title><![CDATA[11047. 동전 0]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:실버/4" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실버/4</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener nofollow">#코딩테스트</a><br>
<a href="https://sunha20.github.io/digital-garden?query=tag:실버/4" class="tag" target="_blank" rel="noopener nofollow">#실버/4</a> <br><br><br>준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.<br>동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)<br>둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai&nbsp;≤ 1,000,000, A1&nbsp;= 1, i&nbsp;≥ 2인 경우에&nbsp;Ai는 Ai-1의 배수)<br><br>첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.<br><br>10 4200<br>
1<br>
5<br>
10<br>
50<br>
100<br>
500<br>
1000<br>
5000<br>
10000<br>
50000<br><br>6<br><br>10 4790<br>
1<br>
5<br>
10<br>
50<br>
100<br>
500<br>
1000<br>
5000<br>
10000<br>
50000<br><br>12<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/ai4youej" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/ai4youej" target="_blank">ai4youej</a>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><br><br>import sys  
  
def coin_0():  
N, total = map(int, sys.stdin.readline().split())  
coin = []  
now = 0  
cnt = 0  
  
for _ in range(N):  
coin.append(int(sys.stdin.readline().rstrip()))  
  
for v in reversed(coin):  
  
while now + v &lt;= total:  
cnt += 1  
now += v  
  
if now == total:  
print(cnt)  
break  
  
  
if __name__ == "__main__":  
coin_0()
복사<br>
<br>생각해보니 굳이 반복문 돌릴 필요 없음, 나누기로 해결 가능
<br><br>import sys

def coin_0():
    N, total = map(int, sys.stdin.readline().split())
    coin = []
    now = 0
    cnt = 0

    for _ in range(N):
        coin.append(int(sys.stdin.readline().rstrip()))

    for v in reversed(coin):
        temp = (total - now) // v
        cnt += temp
        now += v * temp

        if now == total:
            print(cnt)
            break

if __name__ == "__main__":
    coin_0()

복사<br><br>
<br>
종류를 무한으로 쓸 수 있는 건 쉬운데, 종류별로 갯수가 정해져있는 건 까다로움…

<br>
일전에 실패했던 배낭문제(<a data-href="12865. 평범한 배낭" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/12865.-평범한-배낭.html" class="internal-link" target="_self" rel="noopener nofollow">12865. 평범한 배낭</a>)와 이문제 (<a data-href="11047. 동전 0" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/11047.-동전-0.html" class="internal-link" target="_self" rel="noopener nofollow">11047. 동전 0</a>) 그리고 동전이 배수가 아닌 경우의 차이가 뭘까.

<br>
내생각

<br>


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/11047.-동전-0.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/11047. 동전 0.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Thu, 07 Mar 2024 05:33:26 GMT</pubDate></item><item><title><![CDATA[1003. 피보나치 함수]]></title><description><![CDATA[ 
 <br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a><br><br><br>다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.<br>int fibonacci(int n) {<br>
if (n == 0) {<br>
printf("0");<br>
return 0;<br>
} else if (n == 1) {<br>
printf("1");<br>
return 1;<br>
} else {<br>
return fibonacci(n‐1) + fibonacci(n‐2);<br>
}<br>
}<br>fibonacci(3)을 호출하면 다음과 같은 일이 일어난다.<br>
<br>fibonacci(3)은&nbsp;fibonacci(2)와&nbsp;fibonacci(1)&nbsp;(첫 번째 호출)을 호출한다.
<br>fibonacci(2)는&nbsp;fibonacci(1)&nbsp;(두 번째 호출)과&nbsp;fibonacci(0)을 호출한다.
<br>두 번째 호출한&nbsp;fibonacci(1)은 1을 출력하고 1을 리턴한다.
<br>fibonacci(0)은 0을 출력하고, 0을 리턴한다.
<br>fibonacci(2)는&nbsp;fibonacci(1)과&nbsp;fibonacci(0)의 결과를 얻고, 1을 리턴한다.
<br>첫 번째 호출한&nbsp;fibonacci(1)은 1을 출력하고, 1을 리턴한다.
<br>fibonacci(3)은&nbsp;fibonacci(2)와&nbsp;fibonacci(1)의 결과를 얻고, 2를 리턴한다.
<br>1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때,&nbsp;fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 테스트 케이스의 개수 T가 주어진다.<br>각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.<br><br>각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.<br><br>3<br>
0<br>
1<br>
3<br><br>1 0<br>
0 1<br>
1 2<br><br>2<br>
6<br>
22<br><br>5 8<br>
10946 17711<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/connotation" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/connotation" target="_blank">connotation</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/doju" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/doju" target="_blank">doju</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/wonrok97" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/wonrok97" target="_blank">wonrok97</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cyj101366" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/cyj101366" target="_blank">cyj101366</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><br><br>
<br>
다이나믹 프로그래밍

<br>호출이 아니라 출력의 문제임
<br>(1,0)
<br>2: 1+0 → (1,1)
<br>3: 2+1 → (1,2)
<br>4: 3+2 → (2,3)
<br>5: 4+3 → (3,5)
<br>6: 5+4 → (5,8)
<br>


<br>
down-top 방식으로 구현

<br><br>import sys

def fibonacci():
    N = int(sys.stdin.readline().rstrip())
    dp_0 = [1,0,1]
    dp_1 = [0,1,1]
    while N &gt; 0:
        N -= 1
        num = int(sys.stdin.readline().rstrip())
        if (num &lt; 3):
            print(dp_0[num], dp_1[num])
        else:
            zero = 0
            one = 0
            for i in range(len(dp_0), num+1):
                dp_0.append(dp_0[i - 1] + dp_0[i - 2])
                dp_1.append(dp_1[i - 1] + dp_1[i - 2])
                zero = dp_0[i]
                one = dp_1[i]
            print(zero, one)


if __name__ == "__main__":
    fibonacci()
복사<br>
<br>앞선 순서에서 dp list를 채워 두어 len(dp_0)&gt;num+1 인 경우에, for문이 돌아가지 않고 0 0 이 출력됨.
<br><br>import sys

def fibonacci():
    N = int(sys.stdin.readline().rstrip())
    dp_0 = [1,0,1]
    dp_1 = [0,1,1]
    while N &gt; 0:
        N -= 1
        num = int(sys.stdin.readline().rstrip())
        if (num &lt; len(dp_0)):
            print(dp_0[num], dp_1[num])
        else:
            zero = 0
            one = 0
            for i in range(len(dp_0), num+1):
                dp_0.append(dp_0[i - 1] + dp_0[i - 2])
                dp_1.append(dp_1[i - 1] + dp_1[i - 2])
                zero = dp_0[i]
                one = dp_1[i]
            print(zero, one)


if __name__ == "__main__":
    fibonacci()
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1003.-피보나치-함수.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1003. 피보나치 함수.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 25 May 2024 15:32:54 GMT</pubDate></item><item><title><![CDATA[1011. Capacity To Ship Packages Within D Days]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-06-11<br>Link: <a rel="noopener nofollow" class="external-link" href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank">https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/</a><br>Level: Medium<br>Category: <br><a data-href="Search" href="https://sunha20.github.io/digital-garden/Search" class="internal-link" target="_self" rel="noopener nofollow">Search</a><br>Success: ⭕ +a<br>Git: -<br><br>A conveyor belt has packages that must be shipped from one port to another within&nbsp;days&nbsp;days.<br>The&nbsp;ith&nbsp;package on the conveyor belt has a weight of&nbsp;weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by&nbsp;weights). We may not load more weight than the maximum weight capacity of the ship.<br>Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within&nbsp;days&nbsp;days.<br>Example 1:<br>Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5<br>
Output: 15<br>
Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:<br>
1st day: 1, 2, 3, 4, 5<br>
2nd day: 6, 7<br>
3rd day: 8<br>
4th day: 9<br>
5th day: 10<br>Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.<br>Example 2:<br>Input: weights = [3,2,2,4,1,4], days = 3<br>
Output: 6<br>
Explanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:<br>
1st day: 3, 2<br>
2nd day: 2, 4<br>
3rd day: 1, 4<br>Example 3:<br>Input: weights = [1,2,3,1,1], days = 4<br>
Output: 3<br>
Explanation:<br>
1st day: 1<br>
2nd day: 2<br>
3rd day: 3<br>
4th day: 1, 1<br>Constraints:<br>
<br>1 &lt;= days &lt;= weights.length &lt;= 5 * 104
<br>1 &lt;= weights[i] &lt;= 500
<br><br><br>
<br>
이게 왜 binary search인가? <a data-tooltip-position="top" aria-label="https://velog.io/@soopsaram/Leetcode-1011.-Capacity-To-Ship-Packages-Within-D-Days" rel="noopener nofollow" class="external-link" href="https://velog.io/@soopsaram/Leetcode-1011.-Capacity-To-Ship-Packages-Within-D-Days" target="_blank">참고</a>

<br>binary search는 두 종류의 문제가 있다.

<br>배열 인덱스로 binary search 하는 경우 -&gt; O(logn)
<br>어떤 결과 값을 Up &amp; Down 으로 맞추는 경우(주어진 배열을 이용해 계산) -&gt; O(nlogn)




<br>
최소 capacity에서 true가 나올때 까지 1개 씩 찾아 올라가면 선형탐색

<br>
가능한 최대 capacity에서 반씩 줄여가면서 찾으면 이진탐색

<br>
+) 이진 탐색

<br>binary search 할때, l, r에 mid 값 할당해 줄 때 +1, -1을 어떻게 해줘야하는 지 명확하지 않음
<br>비슷하게 l,r 비교 부등호도  명확하지 않음. (디버거 돌려보면 서 함.)
<br>이진 탐색 공부해보기


<br>
+) 초기값 설정 오류

<br>We have to adjust the low for the binary search depending on the maximum weight that is present in the input, for ex in the case 3, the max weight is 3, we cannot have capacity of two ever transport a weight of 3.


<br>class Solution {

    public int shipWithinDays(int[] weights, int days) {

        int sum = 0;

        int max = 0;

        for (int i=0; i&lt;weights.length; i++) {

            sum += weights[i];

            if (max &lt; weights[i]) max = weights[i];

        }

        int l = max;

        int r = sum;

        int mid = (l+r)/2;

        while (l &lt;= r) {

            mid = (l+r)/2;

            if (exceedingDDays(weights, days, mid)) {

                l = mid + 1;

            } else {

                r = mid - 1;

            }

        }

        return l;

    }

    public boolean exceedingDDays(int[] weights, int days, int capacity) {

        int sum = 0;

        for (int i=0; i&lt;weights.length; i++) {

            sum += weights[i];

            if (sum &gt; capacity) {

                days -= 1;

                sum = weights[i];

            }

            if (days &lt;= 0) return true;

        }

        return false;

    }

}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1011.-capacity-to-ship-packages-within-d-days.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/1011. Capacity To Ship Packages Within D Days.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 11 Jun 2024 09:08:07 GMT</pubDate></item><item><title><![CDATA[01타일]]></title><description><![CDATA[ 
 <br>ID: 1904<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1904" target="_blank">https://www.acmicpc.net/problem/1904</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
생성 일시: 2023년 9월 10일 오후 8:37<br><br><br><br><br>지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.<br>어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다. 결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.<br>그러므로 지원이는 타일로 더 이상 크기가&nbsp;N인&nbsp;모든 2진 수열을 만들 수 없게 되었다. 예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.) 또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.<br>우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.<br><br>첫 번째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 1,000,000)<br><br>첫 번째 줄에 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다.<br><br>4

복사<br><br>5

복사<br><br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/mwy3055" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/mwy3055" target="_blank">mwy3055</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/qortmd7777" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/qortmd7777" target="_blank">qortmd7777</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/wider93" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/wider93" target="_blank">wider93</a>
<br><br>
<br>N=1

<br>1


<br>N=2

<br>00
<br>11


<br>N=3

<br>100
<br>001
<br>111


<br>N=4

<br>0000
<br>1100
<br>1001
<br>0011
<br>1111


<br>
<br>복사<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/01타일.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/01타일.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:23:16 GMT</pubDate></item><item><title><![CDATA[10025. 게으른 백곰]]></title><description><![CDATA[ 
 <br>
<br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/PS/PS.md" data-href="1. Study/Coding Test/PS/PS.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>
<br>Date: 2024-07-08<br>Link: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/10025" target="_blank">https://www.acmicpc.net/problem/10025</a><br>Level: s3<br>Category: -<br>Success: -<br><br><br><br>더운 여름날 동물원의 백곰 앨버트는 너무 더워서 꼼짝도 하기 싫다.&nbsp;다행히도 사육사들이 앨버트의 더위를 식히기 위해 얼음이 담긴 양동이들을 가져다 주었다.&nbsp;앨버트가 가장 적은 거리만 움직이고도 최대한 많은 얼음으로 더위를 식힐 수 있도록 도와주자.<br>우리 안은 1차원 배열로 생각하며, 총 N(1 ≤ N ≤ 100000)개의 얼음 양동이들이 xi(0 ≤ xi&nbsp;≤ 1,000,000)좌표마다 놓여 있고&nbsp;각 양동이 안에는 gi(1 ≤ gi&nbsp;≤ 10,000)씩의 얼음이 들어 있다.&nbsp;일단 앨버트가 자리를 잡으면 그로부터 좌우로 K(1 ≤&nbsp;K ≤ 2,000,000) 만큼 떨어진 양동이까지 닿을 수 있다. 앨버트는 양동이가 놓여 있는 자리에도 자리잡을 수 있다. 모든 얼음 양동이의 위치는 다르다.<br>앨버트가 최적의 자리를 골랐을 때 얼음의 합을 구하시오. 즉, 얼음들의 합의 최댓값을 구해야 한다.<br><br>첫 줄에 정수 N과 K가 들어온다.&nbsp;둘째 줄부터 N째 줄까지, 공백을 사이에 두고 각 양동이의 얼음의 양을 나타내는 gi와 양동이의 좌표를 나타내는 xi가 주어진다.<br><br>앨버트가 택한 최적 위치로부터 K만큼 떨어진 거리 내에 있는 얼음들의 합(최댓값)을 출력한다.<br><br>4 3<br>
4 7<br>
10 15<br>
2 2<br>
5 1<br><br>11<br><br>앨버트가&nbsp;x=4에 자리를 잡으면 x=1, x=2, x=7에 있는 얼음 양동이에 닿을 수 있다.<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/106" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/106" target="_blank">USA Computing Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/281" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/281" target="_blank">2013-2014 Season</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/296" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/296" target="_blank">USACO March 2014 Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/1243" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/category/detail/1243" target="_blank">Bronze</a>&nbsp;2번<br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/pjw" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/pjw" target="_blank">pjw</a>
<br>잘못된 번역을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/swh98" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/user/swh98" target="_blank">swh98</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/139" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/139" target="_blank">누적 합</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/80" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/80" target="_blank">두 포인터</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/68" rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/tag/68" target="_blank">슬라이딩 윈도우</a>
<br><br><br><br>4Byte * 1,000,000 = 4,000,000Byte = 4,000 KB = 4MB이다. 메모리 용량이 충분하기 때문에 1000001칸 배열을 만들어서 얼음 양을 저장한다.<br><br>
<br>pointer1(p1)은 부분합을 구하는 시작 index이자, 다음 부분합에서 빠져야하는 idx값이다.
<br>pointer2(p2)는 부분합의 끝을 알리는 index이므로, 현재 부분합에는 포함되지 않는다. (다음 부분합에 포함된다.)
<br><br>
<br>처음에 배열 크기를 N의 최대 크기로 잡음. (X)
<br>N은 양동이의 개수이므로, 우리 크기와 밀접한 관련을 가지기는 어렵다.
<br>대신 g_i의 경우가 배열 내에 양동이의 위치이므로, 유효한 배열의 크기와 밀접한 관련이 있다.
<br><br>import java.io.*;  
import java.util.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int N = Integer.parseInt(st.nextToken());   // 양동이 개수  
        int K = Integer.parseInt(st.nextToken());   // 움직일 수 있는 거리.  
        int move = 2 * K + 1;  
        int allIce = 0;  
        int len = 0;  
        int[] pen = new int[1000001];  
        for (int n=0; n&lt;N; n++) {  
            st = new StringTokenizer(br.readLine());  
            int ice = Integer.parseInt(st.nextToken());  
            int idx = Integer.parseInt(st.nextToken());  
            pen[idx] = ice;  
            allIce += ice;  
            if (idx &gt; len) len = idx;  
        }  
        len++;  
  
        if (len &lt;= move) {  
            System.out.println(allIce);  
            return;  
        }  
  
        int p1 = 0;                         // pointer 1  
        int p2 = move;                      // pointer 2  
        int sum = 0;                        // 부분합 초기화  
        for (int i=p1; i&lt;(p2); i++) {  
            sum += pen[i];  
        }  
  
        int max = sum;                      // 부분합의 최댓값 구하기.  
        for (int i=1; i&lt;(len-(move)); i++) {  
            sum -= pen[p1];  
            sum += pen[p2];  
            p1++; p2++;  
            if (sum &gt; max) max = sum;  
        }  
  
        System.out.println(max);  
    }  
}
복사<br><br>
<br>배열 생성을 위한 for문에서, 첫 부분합 범위에 속하는 값을 sum에 더해주기

<br>유효한 배열길이(len)&lt; 이동가능 거리(move)일 경우 그냥 전체 얼음개수를 출력해주는 연산을 지워도 될 듯.


<br>아래와 같이 첫 부분합 생성이 끝나면, 그때부터 값 빼주는 연산 진행.
<br> for (int i = 0; i &lt;= 1000000; i++) {
	 if(i-K&gt;=0) sum -= ice[i - K];
	 sum += ice[i];
	 max = Math.max(max,sum);
  }
복사<br><br>import java.io.*;  
import java.util.*;  
  
public class Main {  
    public static void main(String[] args) throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        StringTokenizer st = new StringTokenizer(br.readLine());  
        int N = Integer.parseInt(st.nextToken());   // 양동이 개수  
        int K = Integer.parseInt(st.nextToken());     
        int move = 2 * K + 1;                       // 움직일 수 있는 전체 거리.  
        int[] pen = new int[1000001];  
        int len = 0;  
        int sum = 0;  
        for (int n=0; n&lt;N; n++) {  
            st = new StringTokenizer(br.readLine());  
            int ice = Integer.parseInt(st.nextToken());  
            int idx = Integer.parseInt(st.nextToken());  
            pen[idx] = ice;  
            if (idx &gt; len) len = idx;               // 유효한 배열 크기 구하기  
            if (idx &lt; move) sum += ice;             // 초기 부분합 구하기  
        }  
        len++;  
  
        int p1 = 0;                         // pointer 1  
        int p2 = move;                      // pointer 2  
        int max = sum;                      // 부분합의 최댓값 구하기.  
        for (int i=1; i&lt;(len-(move)); i++) {  
            sum -= pen[p1];  
            sum += pen[p2];  
            p1++; p2++;  
            if (sum &gt; max) max = sum;  
        }  
  
        System.out.println(max);  
    }  
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/10025.-게으른-백곰.html</link><guid isPermaLink="false">1. Study/Coding Test/PS/10025. 게으른 백곰.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Mon, 08 Jul 2024 07:43:00 GMT</pubDate></item><item><title><![CDATA[HELP: 알고리즘]]></title><description><![CDATA[ 
 <br><br>ID: 0<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/blog/view/70" target="_blank">https://www.acmicpc.net/blog/view/70</a><br>
다시풀기: No<br>
분류: help<br>
생성 일시: 2023년 4월 20일 오후 5:56<br>
<br>배열 기반의 리스트 (C++&nbsp;vector, string,&nbsp;Java&nbsp;ArrayList, String,&nbsp;Python&nbsp;list, str, ...)의 중간에 뭔가를 끼워넣거나 빼는 건 O(N)입니다.
<br>퀵소트를 직접 구현하면 O(N^2)이 걸리는 데이터를 손쉽게 만들 수 있습니다. 그냥 내장된 정렬 함수를 쓰세요. 정렬을 직접 구현하는 것을 연습하시고자 한다면, 피벗을 랜덤으로 잡은 퀵소트를 구현하거나 힙소트, 머지소트 등 다른 O(nlogn) 정렬 알고리즘을 구현하는 방법이 있습니다.
<br>격자에서 탐색할 때 범위 체크를 반드시 합시다.
<br>DP를 할 때에는 메모이제이션을 합시다. 안 그러면 DP가 아닙니다.
<br>DFS는 절대로 최단거리를 구해 주지 않습니다.&nbsp;물론 메모이제이션 없이 모든 경로를 탐색하는 DFS는 최단거리를 구해 주겠지만, 시간 초과가 날 것입니다.
  <img alt="https://imgur.com/6griKbJ.png" src="https://imgur.com/6griKbJ.png" referrerpolicy="no-referrer"><br>

<br>BFS는 큐에서 뺀 다음이 아닌, 큐에 넣을 때 방문 체크를 해야 중복 방문이 일어나지 않습니다.&nbsp;BFS 문제에서 시간 초과나 메모리 초과가 나면 이것부터 의심해 보시면 됩니다.
  <img alt="https://imgur.com/TKsmWih.png" src="https://imgur.com/TKsmWih.png" referrerpolicy="no-referrer"><br>

<br>BFS를 할 때 큐의 크기가 제한되어 있도록 구현했다면, 그 크기는 적어도 방문할 수 있는 정점의 총 개수보다는 크게 합시다.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/help-알고리즘.html</link><guid isPermaLink="false">1. Study/Coding Test/Algorithm/HELP 알고리즘.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:28:18 GMT</pubDate><enclosure url="https://imgur.com/6griKbJ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://imgur.com/6griKbJ.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[이분탐색]]></title><description><![CDATA[ 
 <br><br>정렬된 배열에서 원하는 값을 빠르게 찾을 수 있는 탐색 기법으로, 탐색 범위를 절반씩 줄여가며 원하는 값을 찾아가는 방식이다.<br><br>
<br>정렬된 배열에서 중간 값을 기준으로 target 값과 비교한다. 
<br>target이 중간 값보다 크면 왼쪽 부분을 버리고, 작으면 오른쪽 부분을 버린다. 
<br>이 과정을 반복하면서 배열의 범위를 점점 좁혀 target을 찾는다.
<br><br>이분 탐색의 시간복잡도는 O(log N) 이다.<br>탐색의 범위를 절반씩 줄여나가며 탐색을 진행하는 방식으로, 매 실행마다 탐색범위가 절반씩 줄어들게 된다. 따라서 시간 복잡도는 배열 길이 N이 몇 번까지 2로 나누어(나머지 버림)질 수 있는가가 시간복잡도의 기준이 된다. 즉, 으로 시간 복잡도는 O(log N)의 값을 가진다.<br><br>public class Main {  
    public static void main(String[] args) {  
        // 문제 설정  
        int[] list = {0,10,20,30,40,50,60,70,80,90};  
        int target = 10;  
  
        // 탐색 범위 설정을 위한 인덱스 값을 저장하는 변수 선언  
        int si = 0;                         // si: start index  
        int ei = list.length;               // ei: end index  
  
        // 탐색 시작  
        // end index가 start index를 초과할 시
        while (si &lt;= ei) {                              
            int mid = (si+ei)/2;           // mid: 배열 탐색범위의 중간 index   
			int now = list[mid];            // now: 배열 탐색범위의 중간값  
            // target 발견 시 위치를 출력하고 loop 종료  
            if (now == target) {            
                System.out.println(mid);  
                break;  
            }  
			  // target이 mid 값 보다 왼쪽에 있을 시 end index를 mid 위치로 옮김  
            if (now &gt; target) ei = mid;     
            // target이 mid 값 보다 오른쪽에 있을 시 start index를 mid + 1 위치로 옮김  
            if (now &lt; target) si = mid+1;   
        }  
  
    }  
}
복사<br><br><br>lo가 hi보다 클 때만 while문 탈출 가능.<br><br>ex)<br>
lo = 5; hi = 5;<br>
mid = 5;<br>
→ lo나 hi를 갱신해야하는 경우에 mid로 갱신한다면 값이 5로 유지되어 무한루프에 빠짐.<br>따라서 lo나 hi의 갱신을 mid 값이 아닌 lo = mid+1, hi = mid-1로 해주어야한다.<br><br>lo == hi 일때, 마지막으로 mid에서 target 탐색 후 탈출 → 탐색하지 않은 요소가 없음<br><br><br>lo와 hi가 같은 경우에도 while문을 탈출 한다.<br><br>ex)<br>
lo=4; hi=5;<br>
mid = 4;<br>
→ lo를 갱신해야하는 경우 lo의 값이 4로 유지되므로 무한루프에 빠짐.<br> 따라서 lo값을 mid+1로 갱신해주어야한다. (hi값은 mid로 갱신해준다. 둘의 차이는 lo)<br><br>ex)<br>
lo = 5; hi = 6; 이었다가<br>
lo = 5; hi = 5; 로 갱신된 경우, while 문 탈출 → list[4]가 target값과 일치하는지를 탐색하지 못함<br>
→ 해당 부분에 대한 연산을 추가해줘야함.<br><br>
<br>hi == lo일 때까지 탐색을 반복 → 'target값 찾았다고 나가면 안됨.
<br>Lower Bound:

<br>target 이상의 첫 위치 (처음 나타나는 위치)
<br>배열 [1, 2, 4, 4, 4, 5]에서 4의 Lower Bound는 index 2.
<br>target보다 크거나 같은 값을 찾기 위해 mid 값을 기준으로 hi나 lo를 조정.


<br>Upper Bound

<br>target을 초과하는 첫 위치 (마지막 위치 이후)
<br>배열 [1, 2, 4, 4, 4, 5, 6]에서 4의 Upper Bound는 index 5.
<br>target보다 큰 값을 찾기 위해 mid 값을 기준으로 조정하되, target과 동일한 경우에도 lo를 오른쪽으로 이동.


<br><br><br><br>→ mid값으로 초기화 해주어도 됨. lo랑 hi랑 붙어서 지지고 볶고 할 시간도 없이 while문에서 빼내기 때문에,,,<br><br>ex)<br>
lo = 4; hi = 6; 이었다가<br>
lo = 4; hi = 5; 로 갱신된 경우, while 문 탈출 → list[4]와 list[5]가 target값과 일치하는지를 탐색하지 못함<br>
→ 해당 부분에 대한 연산을 추가해줘야함.<br><br>
<br>범위 탐색이나 최적화 문제에 활용.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/이분탐색.html</link><guid isPermaLink="false">1. Study/Coding Test/Algorithm/이분탐색.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Mon, 28 Oct 2024 23:25:03 GMT</pubDate></item><item><title><![CDATA[java 기본]]></title><description><![CDATA[ 
 <br>NAV: <a data-tooltip-position="top" aria-label="1. Study/Coding Test/Algorithm/Algorithm.md" data-href="1. Study/Coding Test/Algorithm/Algorithm.md" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/algorithm.html" class="internal-link" target="_self" rel="noopener nofollow">Algorithm</a><br><a data-tooltip-position="top" aria-label="https://nahwasa.com/entry/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B1%EC%A4%80-%ED%92%80-%EB%95%8C%EC%9D%98-%ED%8C%81-%EB%B0%8F-%EC%A3%BC%EC%9D%98%EC%A0%90-boj-java" rel="noopener nofollow" class="external-link" href="https://nahwasa.com/entry/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B1%EC%A4%80-%ED%92%80-%EB%95%8C%EC%9D%98-%ED%8C%81-%EB%B0%8F-%EC%A3%BC%EC%9D%98%EC%A0%90-boj-java" target="_blank">자바로 백준 풀 때의 팁 및 주의점 (boj java) - Nahwasa</a>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/java-기본.html</link><guid isPermaLink="false">1. Study/Coding Test/Algorithm/java 기본.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 25 May 2024 15:32:56 GMT</pubDate></item><item><title><![CDATA[HELP: 반례 찾기]]></title><description><![CDATA[ 
 <br><br>ID: 0<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/blog/view/70" target="_blank">https://www.acmicpc.net/blog/view/70</a><br>
다시풀기: No<br>
분류: help<br>
생성 일시: 2023년 4월 20일 오후 5:55<br>
<br>가장 중요한 것은 직접 데이터를 만들어서 넣어 보는 것입니다.&nbsp;<a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/14405" target="_blank">https://www.acmicpc.net/problem/14405</a>&nbsp;를 예로 들어 봅시다. 그러면 이런 입력들을 넣어 볼 수 있습니다.
<br>pi 하나만 넣으면? ka? chu? 한 글자만 넣으면? p? k? c? i? a? r?
<br>pika는 YES가 나와야 합니다. 이걸 조금 변형하면? pik? pia? pka? piak? pkia? ipka? kipa? pikaa? pikka? piika? ppika?
<br>kapi도 YES가 나와야 합니다. 이걸 조금 변형하면? kap? kai? api? kaip? kpai? kapii? kaapi?
<br>주어진 예제를 조금 변형하면? pikap? pikpi? pipikach? pipikaphu?
<br>그냥 정말로 아무거나 넣으면? abcd? pipichukachuka? pichaku? ppap? pikach?
<br>입력으로 1 이상 1,000,000 이하의 정수 N이 주어진다면 N=1, N=2 등의 최소 케이스가 잘 나오는지 확인하는 것이 좋습니다.&nbsp;이런 입력이 특이 케이스가 되는 문제들이 종종 있고, 굳이 특이 케이스가 아니더라도 우리의 코드가 최소 케이스에서 틀릴 가능성은 얼마든지 있습니다. 위에서 언급한 "피카츄" 문제의 경우 p, k 등의 한 글자짜리 입력이 여기에 해당되겠죠.
<br>N=1,000,000 같은 최대 케이스를 넣었을 때 주어진 시간 제한 안에 답이 나오는지도 확인해 볼 수 있습니다. 답이 맞는지 확인하는 건 어떨까요? 문제에 따라 답을 손으로 알아내기 힘들 수도 있는데, 적어도 말이 되는 값은 나와야겠죠? 출력이 무조건 0 이상일 수밖에 없는 문제에서 음수가 나오면 뭔가 잘못되었다는 뜻입니다.
<br>매우 간단한 풀이가 있는데 시간복잡도가 너무 커서 못 쓰고, 그 대신 더 효율적인 풀이를 생각해야 하는 문제가 있습니다. 이런 문제는 다음 방법으로도 반례를 찾을 수 있습니다. 매우 간단한 풀이이면 구현하기 쉬워서 틀릴 가능성이 낮다는 점을 이용한 방법입니다.
<br>매우 간단한 풀이를 작성한다.
<br>랜덤으로 데이터를 만든다.
<br>간단한 풀이와 틀린 풀이가 내놓는 답이 일치하는지 검사한다.
<br>2-3번을 반복...
<br><a data-tooltip-position="top" aria-label="http://www.secmem.org/blog/2020/09/19/rte/" rel="noopener nofollow" class="external-link" href="http://www.secmem.org/blog/2020/09/19/rte/" target="_blank">PS에서의 런타임 에러와 디버깅 (링크)</a>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/help-반례-찾기.html</link><guid isPermaLink="false">1. Study/Coding Test/Algorithm/HELP 반례 찾기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:28:43 GMT</pubDate></item><item><title><![CDATA[Help: Python과 Pypy]]></title><description><![CDATA[ 
 <br><br>ID: 0<br>
Site: 백준<br>
URL: <a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/blog/view/70" target="_blank">https://www.acmicpc.net/blog/view/70</a><br>
다시풀기: No<br>
분류: help<br>
생성 일시: 2023년 4월 20일 오후 5:58<br>
<br>BOJ는 numpy 등 외장모듈을 지원하지 않습니다.&nbsp;(사실 모든 언어가 그렇습니다.)
<br>풀이가 분명히 맞고 시간복잡도도 충분히 작은데 시간 초과가 난다면 언어를 Pypy로 설정하고 제출하면 됩니다. 파이썬은 원래 편리성과 속도를 맞바꾼 언어이기 때문에, 맞아야 될 풀이가 시간 초과더라도 이상할 게 전혀 없습니다.
<br>두 수를 입력받고 나서 비교할 때는 반드시 int로 변환을 합시다.&nbsp;문자열의 비교는 사전 순 비교이기 때문에, 3은 10보다 작지만 "3"은 "10"보다 큽니다.
<br>is 키워드는 두 대상의 값이 같은지가 아니라 완전히 같은 대상을 가리키는지를 비교합니다. BOJ에서 이걸 쓸 일은 거의 없습니다.&nbsp;같은 "hello"더라도 따로 정의하면 다른 대상이 됩니다. 이걸 쓰면 디버깅하기도 힘든 게, -5 이상 255 이하의 int는 미리 만들어 놓고 정의할 때마다 가져다 쓰기 때문에, 딱 그 범위까지는 is와 ==가 똑같은 동작을 합니다. 그래서 손으로 반례를 찾으려고 하면 찾아지지 않습니다.
<br>list.pop(0), list.index, list.insert, list.count, x in list, list[:-1]&nbsp;등은 다 O(N)입니다. 이외에도 O(N)이 걸리는 list 연산이 굉장히 많습니다. (len(list)는 O(1))  <a rel="noopener nofollow" class="external-link" href="https://wiki.python.org/moin/TimeComplexity" target="_blank">https://wiki.python.org/moin/TimeComplexity</a>
<br>위의 이유로,&nbsp;list를 큐 또는 덱으로 사용하면 절대, 절대, 절대, 절대, 절대 안 됩니다!! 반드시&nbsp;collections.deque를 써야 합니다.
<br>아니요,&nbsp;queue.Queue도 안 됩니다. 이건 멀티스레딩을 위해 만들어진 큐이고 매우 느립니다.
<br>파이썬의 재귀 깊이는 기본적으로 최대 1,000입니다.&nbsp;sys.setrecursionlimit으로 이 깊이를 조절할 수 있습니다.
<br>두 개의 int를 나누면 float이 됩니다.&nbsp;int(a/b)&nbsp;말고&nbsp;a//b를 쓰는 것이 훨씬 안전합니다.&nbsp;맨 위의 "부동소수점 자료형은 나타내는 수의 범위가 넓지만 ..."을 읽어보세요.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/help-python과-pypy.html</link><guid isPermaLink="false">1. Study/Coding Test/Algorithm/Help Python과 Pypy.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:27:11 GMT</pubDate></item><item><title><![CDATA[Graph]]></title><description><![CDATA[ 
 <br><br><br><a data-tooltip-position="top" aria-label="1. Study/Coding Test/Algorithm/Graph/new file.md" data-href="1. Study/Coding Test/Algorithm/Graph/new file.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/Algorithm/Graph/new file" class="internal-link" target="_self" rel="noopener nofollow">new file</a>   |   <a data-tooltip-position="top" aria-label="1. Study/Coding Test/Algorithm/Graph/new folder/new folder.md" data-href="1. Study/Coding Test/Algorithm/Graph/new folder/new folder.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/Algorithm/Graph/new folder/new folder" class="internal-link" target="_self" rel="noopener nofollow">new folder</a><br><br><br><br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/graph/graph.html</link><guid isPermaLink="false">1. Study/Coding Test/Algorithm/Graph/Graph.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Mon, 28 Oct 2024 22:43:09 GMT</pubDate></item><item><title><![CDATA[BFS, DFS]]></title><description><![CDATA[ 
 <br><br><a data-href="11724. 연결 요소의 개수" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/11724.-연결-요소의-개수.html" class="internal-link" target="_self" rel="noopener nofollow">11724. 연결 요소의 개수</a><br>
<a data-href="1249. 보급로" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1249.-보급로.html" class="internal-link" target="_self" rel="noopener nofollow">1249. 보급로</a><br>
<a data-href="1260. DFS와 BFS" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1260.-dfs와-bfs.html" class="internal-link" target="_self" rel="noopener nofollow">1260. DFS와 BFS</a><br>
<a data-href="1302. Deepest Leaves Sum" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1302.-deepest-leaves-sum.html" class="internal-link" target="_self" rel="noopener nofollow">1302. Deepest Leaves Sum</a><br>
<a data-href="1844. 게임 맵 최단거리" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/1844.-게임-맵-최단거리.html" class="internal-link" target="_self" rel="noopener nofollow">1844. 게임 맵 최단거리</a><br>
<a data-href="43165. 타겟넘버" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/43165.-타겟넘버.html" class="internal-link" target="_self" rel="noopener nofollow">43165. 타겟넘버</a><br>
<a data-href="PS" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/ps/ps.html" class="internal-link" target="_self" rel="noopener nofollow">PS</a>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/graph/bfs,-dfs.html</link><guid isPermaLink="false">1. Study/Coding Test/Algorithm/Graph/BFS, DFS.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Mon, 28 Oct 2024 22:43:09 GMT</pubDate></item><item><title><![CDATA[0. Graph]]></title><description><![CDATA[ 
 <br><br>그래프는 원소들의 연결관계를 표현한 자료구조이다. 정점(node, vertex)와 간선(edge)로 구성되며, 정점은 각 원소를 나타내고 정점과 정점사이의 연결은 간선으로 표현된다. <br><br>
<br>
방향그래프(directed graph): 방향성을 가진 간선으로 이루어진 그래프

<br>
무방향그래프(undirected graph): 방향 없는 간선으로 이루어진 그래프

<br>
부분 그래프(subgraph): 그래프의 일부 정점과 간선으로 이루어진 그래프

<br>꼭 연결되어야할 필요는 없다.
<br>신장 부분 그래프(spanning subgraph): 모든 정점을 포함하는 부분 그래프


<br>
연결 그래프(connected graph): 모든 정점들이 서로 점근 가능할 때,

<br>연결 요소(connected components): disjoint connected subgraph → 연결 부분 그래프이면서 다른 연결요소와 분리되어있는 경우


<br>
트리(tree): 순환하지 않는 연결 그래프

<br>신장 트리(spanning tree) 


<br>
가중치 그래프(weighted graph): 간선에 가중치가 할달된 그래프

<br><br>
<br>정점(vertex, node)
<br>간선(edge)
<br>인접 정접(adjacent vertices): 간선에 의해 직접적으로 연결된 정점.
<br>정점의 차수(degree of a vertex): 정점에 연결되어있는 간선 수

<br>방향 그래프에서는 진입차수(in-degree)와 진출차수(out-degree)로 나눠진다.


<br>경로(path): 두 정점 사이를 연결하는 간선들의 나열.

<br>단순 경로(simple path): 중복된 간선이나 정점이 없는 경로
<br>방향 경로(directed path): 방향 그래프에서, 간선이 모드 같은 방향이어야한다는 제약이 있는 경로


<br>순환(Cycle): 시작과 끝이 같은 정점인 경로

<br>단순 순환(simple cycle): 경로에 중복된 간선이나 정점이 없는 순환
<br>방향 순환(directed cycle): 방향 그래프에서, 간선이 모드 같은 방향이어야한다는 제약이 있는 순환


<br><br><br>
<br>간단하고 직관적(intuitive)이나, 효율적이진 않음
<br>list V: 정점 저장
<br>list E: 간선 저장
<br>vertex object: 데이터와 V 내의 위지 주소 → 간선정보음 
<br>edge object: 데이터(가중치 같은 거), 연결된 vertex object, E 내의 위치 주소
<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/algorithm/graph/0.-graph.html</link><guid isPermaLink="false">1. Study/Coding Test/Algorithm/Graph/0. Graph.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Mon, 28 Oct 2024 22:43:09 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[ 
 <br>]]></description><link>https://sunha20.github.io/digital-garden/index.html</link><guid isPermaLink="false">index.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 29 Oct 2024 02:26:07 GMT</pubDate></item></channel></rss>