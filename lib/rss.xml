<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://sunha20.github.io/digital-garden/</link><image><url>https://sunha20.github.io/digital-garden/lib/media/favicon.png</url><title>Obsidian</title><link>https://sunha20.github.io/digital-garden/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 24 May 2024 13:28:35 GMT</lastBuildDate><atom:link href="https://sunha20.github.io/digital-garden/lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 24 May 2024 13:28:34 GMT</pubDate><copyright><![CDATA[seonha20]]></copyright><ttl>60</ttl><dc:creator>seonha20</dc:creator><item><title><![CDATA[Coding Test]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="1. Study/Coding Test/new file.md" data-href="1. Study/Coding Test/new file.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/new file" class="internal-link" target="_self" rel="noopener">new file</a>   |   <a data-tooltip-position="top" aria-label="1. Study/Coding Test/new folder/new folder.md" data-href="1. Study/Coding Test/new folder/new folder.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test/new folder/new folder" class="internal-link" target="_self" rel="noopener">new folder</a><br><br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/coding-test.html</link><guid isPermaLink="false">1. Study/Coding Test/Coding Test.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 24 May 2024 11:50:21 GMT</pubDate></item><item><title><![CDATA[42626. 더맵게]]></title><description><![CDATA[ 
 <br>NAV: <a data-href="1. Study/Coding Test.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test" class="internal-link" target="_self" rel="noopener">1. Study/Coding Test.md</a><br><br>매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.<br>섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)
복사<br>Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.<br>
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.<br><br>
<br>scoville의 길이는 2 이상 1,000,000 이하입니다.
<br>K는 0 이상 1,000,000,000 이하입니다.
<br>scoville의 원소는 각각 0 이상 1,000,000 이하입니다.
<br>모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.
<br><br><br><br>
<br>스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.<br>
새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5<br>
가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]
<br>스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.<br>
새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13<br>
가진 음식의 스코빌 지수 = [13, 9, 10, 12]
<br>모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.<br><br><br><br>: if (minA == null || minB == null) {<br>
<br>null과 int를 비교하여 생긴 문제.
<br>원래 목적: 

<br>우선순위 큐에서 poll()은 첫 번째 값을 반환하고&nbsp;제거, 비어있으면&nbsp;null을 반환하기 때문에 반환값이 null인 경우를 체크하려고 했다.
<br>우선순위 큐에 담겨있는 값은 Integer라서 Integer 대신 int 사용. → 이유: 익숙해서…


<br>문제: int는 reference type이 아닌 primitive type이기 때문에 null이 안 됨…
<br>해결방안

<br>int 대신 Integer(wrapper class) 사용


<br>/*
목표: 모든 음식의 스코빌 지수 &gt; K;
방법: 스코빌 지수가 가장 낮은 두개의 음식으로 새 음식을 만들기;

- 최소 힙 이용(by 우선순위 큐)
*/

import java.util.*;
class Solution {
    public int solution(int[] scoville, int K) {
        PriorityQueue&lt;Integer&gt; hp = new PriorityQueue&lt;&gt;();
        for (int s: scoville) {
            hp.add(s);
        }
        
        int cnt = 0;
        Integer minA;
        Integer minB;
        
        while (true) {
            minA = hp.poll();
            minB = hp.poll();
            if (minA == null || minB == null) {
                return -1;
            }
            if (minA &gt;= K) {
                return cnt;
            }
            
            int newFood = minA + (minB * 2);
            hp.add(newFood);
            cnt += 1;
        }
    }
}
복사<br><br>
<br>정확성 테스트 3개 정도 실패
<br>원인

<br>16, 22, 23 문제는 제공된 scoville이 2개인 경우에 대한 테스트입니다. (<a data-tooltip-position="top" aria-label="https://school.programmers.co.kr/questions/50794" rel="noopener" class="external-link" href="https://school.programmers.co.kr/questions/50794" target="_blank">질문글 참고</a> / <a data-href="42626. 더맵게#테스트 케이스 추가 팁" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/42626.-더맵게.html#테스트_케이스_추가_팁" class="internal-link" target="_self" rel="noopener">42626. 더맵게 &gt; 테스트 케이스 추가 팁</a>)
<br>null check가 먼저 이루어지면서 문제가 생김 → 새로 뽑은 수가 null인데 이미, 조건(K 이상)을 만족했을 때
<br>단순히 null 체크와 조건 체크 순서를 바꾸면 minA가 null일 때 문제가 생김.

<br>수 하나는 무조건 큐에 추가되기 때문에 minA가 null일 리는 없음
<br>처음 주어지는 input도 2개 이상.




<br>/*
목표: 모든 음식의 스코빌 지수 &gt; K;
방법: 스코빌 지수가 가장 낮은 두개의 음식으로 새 음식을 만들기;

- 최소 힙 이용(by 우선순위 큐)
*/

import java.util.*;
class Solution {
    public int solution(int[] scoville, int K) {
        PriorityQueue&lt;Integer&gt; hp = new PriorityQueue&lt;&gt;();
        for (int s: scoville) {
            hp.add(s);
        }
        
        int cnt = 0;
        Integer minA;
        Integer minB;
        
        while (true) {
            // 가장 스코빌 지수가 낮은 음식 2개
            minA = hp.poll();
            minB = hp.poll();
            
            // 조건 체크1 (문제 조건상 항상 minA != null 만족)
            if (minA &gt;= K) {
                return cnt;
            }
            // 조건 체크2
            if (minB == null) {
                return -1;
            }

            // 새로운 음식 추가 및, 시도 횟수 늘리기.
            int newFood = minA + (minB * 2);
            hp.add(newFood);
            cnt += 1;
        }
    }
}
복사<br><br>
<br>기본 테스트 케이스: 문제에서 주어진 예제 테스트 케이스부터 실행해 보세요.
<br>경계값 테스트: 입력 값의 최소, 최대 경계에서의 동작을 확인하세요. 예를 들어, 비밀번호의 길이가 최대(6자리) 또는 최소(1자리)일 때의 동작을 확인해 보세요.
<br>특별한 경우 테스트: 일반적이지 않은 입력값이나 특별한 상황에서의 동작을 확인해 보세요. 예를 들어, DB가 비어있는 경우나, 같은 비밀번호를 가진 여러 회원이 있는 경우 등입니다.
<br>랜덤한 테스트: 여러 다양한 입력 조건에서의 동작을 확인하기 위해 랜덤한 입력값을 사용한 테스트 케이스를 추가해 보세요.
<br>순차적 테스트: 입력값이 특정 순서에 따라 동작을 확인하는 테스트 케이스를 추가해 보세요. 예를 들어, DB에 회원 정보가 아이디 순서나 비밀번호 순서에 따라 정렬된 경우 등입니다.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/42626.-더맵게.html</link><guid isPermaLink="false">1. Study/Coding Test/42626. 더맵게.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 24 May 2024 13:27:58 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[ 
 <br><a data-href="Coding Test" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/coding-test.html" class="internal-link" target="_self" rel="noopener">Coding Test</a>]]></description><link>https://sunha20.github.io/digital-garden/index.html</link><guid isPermaLink="false">index.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Fri, 24 May 2024 03:53:47 GMT</pubDate></item><item><title><![CDATA[1로 만들기]]></title><description><![CDATA[ 
 <br><br>ID: 1463<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1463" target="_blank">https://www.acmicpc.net/problem/1463</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
분류: 다이나믹 프로그래밍<br>
생성 일시: 2023년 8월 13일 오후 11:15<br>
💡 - 이거 진짜 도움됨.<br><a data-tooltip-position="top" aria-label="https://bio-info.tistory.com/159" rel="noopener" class="external-link" href="https://bio-info.tistory.com/159" target="_blank">[백준] 1463 1로 만들기 (DP) - Python / 자세한 설명 / 여러가지 풀이 / 실버1</a><br><br><br><br><br><br>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.<br>
<br>X가 3으로 나누어 떨어지면, 3으로 나눈다.
<br>X가 2로 나누어 떨어지면, 2로 나눈다.
<br>1을 뺀다.
<br>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.<br><br>첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.<br><br>첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.<br><br>2

복사<br><br>1

복사<br><br>10

복사<br><br>3

복사<br><br>10의 경우에 10 → 9 → 3 → 1 로 3번 만에 만들 수 있다.<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cyj101366" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/cyj101366" target="_blank">cyj101366</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jugol" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jugol" target="_blank">jugol</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/dbfldkfdbgml" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/dbfldkfdbgml" target="_blank">dbfldkfdbgml</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/dynamiseus" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/dynamiseus" target="_blank">dynamiseus</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jooa7878" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jooa7878" target="_blank">jooa7878</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/lcr7324" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/lcr7324" target="_blank">lcr7324</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><br>
<br>Python 3: 1.5 초
<br>PyPy3: 0.7 초
<br>Python 2: 1.5 초
<br>PyPy2: 0.7 초
<br><br>
<br>
10

<br>-1(9)

<br>/3
<br>/3


<br>-2(8)

<br>/2
<br>/2
<br>/2


<br>-3(7)
<br>-4(6)

<br>/3
<br>/2


<br>-5(5)
<br>-6(4)

<br>/2
<br>/2


<br>-7


<br>
빼는 수를 하나씩 늘려가면서, 빼고, 각각의 경우에 2,3으로 나누고 나누어 떨어지는 경우 개수를 비교함

<br>
min

<br>자 계속 틀림...
복사<br>
<br>
dp공부 후…

<br>
dp list는 X길이로 만들어야겠지…

<br>
1을 1로 만들려면 → 0

<br>
2를 1로 만들려면 (2) → 1

<br>
3을 1로 만들려면 /3 → 1

<br>
4를 1로 만들려면 /2/2 → 2

<br>
5를 1로 만들려면 →3

<br>
점화식을 어떻게 만들어야할까.

<br>
f(1) = 0

<br>
f(2) = 1

<br>
f(3) = 1

<br>
f(4) = 2

<br>
f(5) = 3

<br>
f(6) = 2 →

<br>
f(7) = 3 → -1, f(6)

<br>
f(8) = 3 → /2, f(4)

<br>
f(9) = 2 → /3, f(3)

<br>
f(10) = → -1, f(9)

<br><br>복사<br><br><br>import sys

def make_one_topdown(x):
    if x == 1:
        return 0
    elif x%3 == 0 and x%2 == 0:
        return 1+ min(make_one_topdown(x//3), make_one_topdown(x//2), make_one_topdown(x-1))
    elif x%3 == 0:
        return 1+ min(make_one_topdown(x//3), make_one_topdown(x-1))
    elif x%2 == 0:
        return 1+ min(make_one_topdown(x//2), make_one_topdown(x-1))
    else:
        return 1+ make_one_topdown(x-1)

if __name__ == "__main__":
    print(make_one_topdown(int(sys.stdin.readline().rstrip())))
복사<br>
<br>생각해보니까. 이 방식은 메모, 재사용의 취지에 딱 들어맞진 않음.
<br>여기에 table을 추가하는 겨..
<br>import sys

X = int(sys.stdin.readline().rstrip())
dp = {1:0}
def make_one_topdown(x):
    if x in dp:
        return dp[x]
    else:
        dp[x] = 1+ min(make_one_topdown(x//3)+x%3, make_one_topdown(x//2)+x%2, make_one_topdown(x-1))
        return dp[x]

print(make_one_topdown(X))
복사<br>
<br>RecursionError: maximum recursion depth exceeded
<br>생각해보면, make_one_topdown(x-1) 필요 없음…
<br>import sys

X = int(sys.stdin.readline().rstrip())
dp = {1:0,2:1, 3:1}
def make_one_topdown(x):
    if x in dp:
        return dp[x]
    else:
        dp[x] = 1+ min(make_one_topdown(x//3)+ x%3, make_one_topdown(x//2)+x%2)
        return dp[x]

print(make_one_topdown(X))
복사<br>
<br>시간이 거의 10배 차이남
<br>Bottom-up 방식은 dp(1)부터 dp(n)까지 전부 구하지만 top-down 방식은 그렇지 않습니다. 실제로 top-down 코드에서 dp(n) 계산이 끝난 후에 arr 전체를 출력해 보면 1~n 전부가 아닌 일부만 계산되어 있음을 확인할 수 있습니다.
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/board/view/122640" rel="noopener" class="external-link" href="https://www.acmicpc.net/board/view/122640" target="_blank">글 읽기 - Top-down Bottom-up 시간 차이에 대한 질문입니다</a>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/1로-만들기.html</link><guid isPermaLink="false">1. Study/Coding Test/1로 만들기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[01타일]]></title><description><![CDATA[ 
 <br>ID: 1904<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1904" target="_blank">https://www.acmicpc.net/problem/1904</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
생성 일시: 2023년 9월 10일 오후 8:37<br><br><br><br><br>지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.<br>어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다. 결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.<br>그러므로 지원이는 타일로 더 이상 크기가&nbsp;N인&nbsp;모든 2진 수열을 만들 수 없게 되었다. 예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.) 또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.<br>우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.<br><br>첫 번째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 1,000,000)<br><br>첫 번째 줄에 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다.<br><br>4

복사<br><br>5

복사<br><br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/mwy3055" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/mwy3055" target="_blank">mwy3055</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/qortmd7777" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/qortmd7777" target="_blank">qortmd7777</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/wider93" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/wider93" target="_blank">wider93</a>
<br><br>
<br>N=1

<br>1


<br>N=2

<br>00
<br>11


<br>N=3

<br>100
<br>001
<br>111


<br>N=4

<br>0000
<br>1100
<br>1001
<br>0011
<br>1111


<br>
<br>복사<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/01타일.html</link><guid isPermaLink="false">1. Study/Coding Test/01타일.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:23:16 GMT</pubDate></item><item><title><![CDATA[1003. 피보나치 함수]]></title><description><![CDATA[ 
 <br>NAV: <a data-href="1. Study/Coding Test.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test" class="internal-link" target="_self" rel="noopener">1. Study/Coding Test.md</a><br><br><br>다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.<br>int fibonacci(int n) {<br>
if (n == 0) {<br>
printf("0");<br>
return 0;<br>
} else if (n == 1) {<br>
printf("1");<br>
return 1;<br>
} else {<br>
return fibonacci(n‐1) + fibonacci(n‐2);<br>
}<br>
}<br>fibonacci(3)을 호출하면 다음과 같은 일이 일어난다.<br>
<br>fibonacci(3)은&nbsp;fibonacci(2)와&nbsp;fibonacci(1)&nbsp;(첫 번째 호출)을 호출한다.
<br>fibonacci(2)는&nbsp;fibonacci(1)&nbsp;(두 번째 호출)과&nbsp;fibonacci(0)을 호출한다.
<br>두 번째 호출한&nbsp;fibonacci(1)은 1을 출력하고 1을 리턴한다.
<br>fibonacci(0)은 0을 출력하고, 0을 리턴한다.
<br>fibonacci(2)는&nbsp;fibonacci(1)과&nbsp;fibonacci(0)의 결과를 얻고, 1을 리턴한다.
<br>첫 번째 호출한&nbsp;fibonacci(1)은 1을 출력하고, 1을 리턴한다.
<br>fibonacci(3)은&nbsp;fibonacci(2)와&nbsp;fibonacci(1)의 결과를 얻고, 2를 리턴한다.
<br>1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때,&nbsp;fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 테스트 케이스의 개수 T가 주어진다.<br>각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.<br><br>각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.<br><br>3<br>
0<br>
1<br>
3<br><br>1 0<br>
0 1<br>
1 2<br><br>2<br>
6<br>
22<br><br>5 8<br>
10946 17711<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/connotation" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/connotation" target="_blank">connotation</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/doju" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/doju" target="_blank">doju</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/wonrok97" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/wonrok97" target="_blank">wonrok97</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cyj101366" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/cyj101366" target="_blank">cyj101366</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><br><br>
<br>
다이나믹 프로그래밍

<br>호출이 아니라 출력의 문제임
<br>(1,0)
<br>2: 1+0 → (1,1)
<br>3: 2+1 → (1,2)
<br>4: 3+2 → (2,3)
<br>5: 4+3 → (3,5)
<br>6: 5+4 → (5,8)
<br>


<br>
down-top 방식으로 구현

<br><br>import sys

def fibonacci():
    N = int(sys.stdin.readline().rstrip())
    dp_0 = [1,0,1]
    dp_1 = [0,1,1]
    while N &gt; 0:
        N -= 1
        num = int(sys.stdin.readline().rstrip())
        if (num &lt; 3):
            print(dp_0[num], dp_1[num])
        else:
            zero = 0
            one = 0
            for i in range(len(dp_0), num+1):
                dp_0.append(dp_0[i - 1] + dp_0[i - 2])
                dp_1.append(dp_1[i - 1] + dp_1[i - 2])
                zero = dp_0[i]
                one = dp_1[i]
            print(zero, one)


if __name__ == "__main__":
    fibonacci()
복사<br>
<br>앞선 순서에서 dp list를 채워 두어 len(dp_0)&gt;num+1 인 경우에, for문이 돌아가지 않고 0 0 이 출력됨.
<br><br>import sys

def fibonacci():
    N = int(sys.stdin.readline().rstrip())
    dp_0 = [1,0,1]
    dp_1 = [0,1,1]
    while N &gt; 0:
        N -= 1
        num = int(sys.stdin.readline().rstrip())
        if (num &lt; len(dp_0)):
            print(dp_0[num], dp_1[num])
        else:
            zero = 0
            one = 0
            for i in range(len(dp_0), num+1):
                dp_0.append(dp_0[i - 1] + dp_0[i - 2])
                dp_1.append(dp_1[i - 1] + dp_1[i - 2])
                zero = dp_0[i]
                one = dp_1[i]
            print(zero, one)


if __name__ == "__main__":
    fibonacci()
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/1003.-피보나치-함수.html</link><guid isPermaLink="false">1. Study/Coding Test/1003. 피보나치 함수.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 26 Mar 2024 11:14:49 GMT</pubDate></item><item><title><![CDATA[1012. 유기농 배추]]></title><description><![CDATA[ 
 <br>NAV: <a data-href="1. Study/Coding Test.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test" class="internal-link" target="_self" rel="noopener">1. Study/Coding Test.md</a><br><br><br>차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고&nbsp;배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에&nbsp;효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아&nbsp;먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.<br>한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.<br><br><br>입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.<br><br>각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.<br><br>2<br>
10 8 17<br>
0 0<br>
1 0<br>
1 1<br>
4 2<br>
4 3<br>
4 5<br>
2 4<br>
3 4<br>
7 4<br>
8 4<br>
9 4<br>
7 5<br>
8 5<br>
9 5<br>
7 6<br>
8 6<br>
9 6<br>
10 10 1<br>
5 5<br><br>5<br>
1<br><br>1<br>
5 3 6<br>
0 2<br>
1 2<br>
2 2<br>
3 2<br>
4 2<br>
4 0<br><br>2<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author2" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/author2" target="_blank">author2</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jinsj1" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jinsj1" target="_blank">jinsj1</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/7" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/7" target="_blank">그래프 이론</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/11" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/11" target="_blank">그래프 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/126" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/126" target="_blank">너비 우선 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/127" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/127" target="_blank">깊이 우선 탐색</a>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/1012.-유기농-배추.html</link><guid isPermaLink="false">1. Study/Coding Test/1012. 유기농 배추.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sun, 14 Apr 2024 12:28:50 GMT</pubDate></item><item><title><![CDATA[1107. 리모컨]]></title><description><![CDATA[ 
 <br>NAV: <a data-href="1. Study/Coding Test.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test" class="internal-link" target="_self" rel="noopener">1. Study/Coding Test.md</a><br><br><br>수빈이는 TV를 보고 있다. 수빈이는 채널을 돌리려고 했지만, 버튼을 너무 세게 누르는 바람에, 일부 숫자 버튼이 고장났다.<br>리모컨에는 버튼이 0부터 9까지 숫자, +와 -가 있다. +를 누르면 현재 보고있는 채널에서 +1된 채널로 이동하고, -를 누르면 -1된 채널로 이동한다. 채널 0에서 -를 누른 경우에는 채널이 변하지 않고, 채널은 무한대 만큼 있다.<br>수빈이가 지금 이동하려고 하는 채널은 N이다. 어떤 버튼이 고장났는지 주어졌을 때, 채널 N으로 이동하기 위해서 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오.<br>수빈이가 지금 보고 있는 채널은 100번이다.<br><br>첫째 줄에 수빈이가 이동하려고 하는 채널 N (0 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 고장난 버튼의 개수 M (0 ≤ M ≤ 10)이 주어진다. 고장난 버튼이 있는 경우에는 셋째 줄에는 고장난 버튼이 주어지며, 같은 버튼이 여러 번 주어지는 경우는 없다.<br><br>첫째 줄에 채널 N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지를 출력한다.<br><br>5457<br>
3<br>
6 7 8<br><br>6<br><br>100<br>
5<br>
0 1 2 3 4<br><br>0<br><br>500000<br>
8<br>
0 2 3 4 6 7 8 9<br><br>11117<br><br>100<br>
3<br>
1 0 5<br><br>0<br><br>14124<br>
0<br><br>5<br><br>1<br>
9<br>
1 2 3 4 5 6 7 8 9<br><br>2<br><br>80000<br>
2<br>
8 9<br><br>2228<br><br>예제 1의 경우 5455++ 또는 5459--<br><br><br>
<br>가장 가까운 곳은 어떻게 고를 것인가?

<br>100에서 +-누르는 수.
<br>못누르는 버튼 찾기
<br>위로 가장 가까운것 찾기
<br>아래로 가자 가까운 것 찾기
<br>비교
<br>최솟감 출력


<br>방법

<br>일단 그냥 반복


<br><br>5676인데<br>
78가 고장남<br>
<br>5 → +1
<br>6 → +1
<br>7 → 불가능! 

<br>up: 9
<br>down: 6


<br>6 → 앞의 영향을 받음

<br>up인경우: 0
<br>down인경우: 9


<br><br>5676인데<br>
789가 고장남<br>
<br>‘’
<br>‘’
<br>7

<br>up → 0 → 2번을 7로…?안됨 8로…? 안됨 9로 안됨… 0으로… → 1을 6으로
<br>down → ‘’


<br>6

<br>up → 0
<br>down: 9


<br><br>4321인데<br>
012가 고장남<br>
<br>4
<br>3
<br>2 

<br>up: 3
<br>down: 1 안됨 → 0 안됨 → 9 :: 2번 2안됨 → 1 안됨 → … 9 :: 1번 3으로…


<br>1

<br>up: 0
<br>down: 9


<br><br>4421인데<br>
012가 고장남<br>
<br>4
<br>3
<br>2 

<br>up: 3
<br>down: 1 안됨 → 0 안됨 → 9 :: 2번 3


<br>1

<br>up: 0
<br>down: 9


<br><br>
<br>이거 너무 복잡함
<br>일단 안전지대를 찾자
<br>+1 되어서 1이 올라가는 경우되는 경우
<br>-1 되어서 0이 되어 9로 내려가는 경우
<br>이 두경우를 표시해두는 거지

<br>flag = “UUDDN” → 위험한 경우


<br><br>
<br>일단 result를 위해 필요한 data

<br>자릿수 + 차이


<br>그냥 아래에서 부터 올라가도 될것같아.

<br>마지막에 그냥 숫자만 바꿔주면 되니까.
<br>그러려면 change point를 아는게 중요하겠네.


<br><br>import sys  
  
def remote_control():  
channel = int(sys.stdin.readline().rstrip())  
trialList = [abs(channel-100), 0,0]  
trialList[1] = list(map(int,str(channel)))  
trialList[2] = trialList[1][:]  
  
brokenNum = int(sys.stdin.readline().rstrip())  
  
if brokenNum == 0:  
print(len(str(channel)))  
exit()  
  
brokenBtns = list(map(int,sys.stdin.readline().split(" ")))  
availableBtns = ""  
for btn in range(10):  
if btn not in brokenBtns:  
availableBtns += str(btn)  
  
trialList[1] = to_upper_ch(trialList[1], availableBtns)  
trialList[2] = to_lower_ch(trialList[2], availableBtns)  
  
trialList[1] = abs(trialList[1] - channel) + len(str(trialList[1]))  
trialList[2] = abs(trialList[2] - channel) + len(str(trialList[2]))  
  
# T: 정상 / F: 고장 / U: 올림 가능한 경우(가장 가까운 괜찮은 버튼 +1) / D: 내림 가능한 경우 (가장 가까운 괜찮은 버튼 -1)print(trialList)  
print(min(trialList))  
def to_upper_ch(upChannel, availableBtns):  
idx = len(upChannel) - 1  
result = 0  
setMinIdx = -1  
while idx &gt;= 0:  
if str(upChannel[idx] % 10) not in availableBtns: # 누를 수 있는 버튼 이 아닌 경우 1씩 올려준다.  
upChannel[idx] += 1  
  
else:  
if upChannel[idx] &gt;= 10: # 자릿수 침범한 경우를 따져야함.  
upChannel[idx] %= 10 # 일의 자릿수만 남기기  
setMinIdx = idx # 이 인덱스 아랫자리부터는 최소 숫자로 변경 (자릿수 올림된 수기 때문에 아래를 최대한 작은 수로 맞춰는 것.)  
  
if idx == 0: # 1 올려주기  
upChannel = [1] + upChannel  
else:  
upChannel[idx - 1] = 1  
idx -= 1  
  
if setMinIdx != -1:  
set_min(upChannel, setMinIdx, int(availableBtns[0])) # 이 아래로는 가장 작은 숫자로 맞춤  
  
for n in upChannel: # 숫자로 합치기  
result = result * 10 + n  
  
return result  
  
  
def to_lower_ch(downChannel, availableBtns):  
idx = len(downChannel) - 1  
result = 0  
setMaxIdx = -1  
while idx &gt;= 0:  
if str(downChannel[idx] % 10) not in availableBtns: # 누를 수 있는 버튼 이 아닌 경우 1씩 빼준다.  
downChannel[idx] -= 1  
  
else:  
if downChannel[idx] &lt; 0: # 자릿수 침범한 경우를 따져야함.  
downChannel[idx] %= 10 # 일의 자릿수만 남기기  
setMaxIdx = idx # 이 인덱스 아랫자리부터는 최소 숫자로 변경 (자릿수 올림된 수기 때문에 아래를 최대한 작은 수로 맞춰는 것.)  
  
if idx == len(downChannel) - 1: # 1 올려주기  
downChannel = downChannel[1:]  
else:  
downChannel[idx - 1] -= 1  
idx -= 1  
  
set_min(downChannel, setMaxIdx, int(availableBtns[-1])) # 이 아래로는 가장 작은 숫자로 맞춤  
  
for n in downChannel: # 숫자로 합치기  
result = result * 10 + n  
  
return result  
  
def set_min(target, idx, num):  
for i in range(idx+1, len(target)):  
target[i] = num  
  
def set_max(target, idx, num):  
for i in range(idx+1, len(target)):  
target[i] = num  
  
if __name__ == "__main__":  
remote_control()
복사<br>
<br>자릿수를 따질 때는 각자리수 list로 다루는 게 편할듯.
<br><br>
<br>모든 숫자 버튼이 고장난 경우 ✅ 2024-04-04
<br>고장난 버튼이 없는 경우 ✅ 2024-04-04

<br>위에 둘다 버튼num 받아서 그게 10일때, 0일때 처


<br>0보다 작은 채널로 계산 할 경우 ✅ 2024-04-04

<br>계산 다하고 음수면 빼기

<br>다시 반례 ✅ 2024-04-04
<br>in: 0 / 2 / 0 1
<br>답: 3
<br>실: 1
<br>문제점: 음수가 나오면 제외하고 최솟값 계산하기로 했는데 로직상 음수가 나올 수 없음

<br>음수가 나오면, 그 자리 빼기 해줌..


<br>해결: 음수가 나올수 있게 → 내림받을 숫자가 더이상 없으면 그 자릿수를 그냥 삭제해버리는데, len이 1이면 -1로 유지하도록 만듬




<br>내림 부분에 수정안한 오류 ✅ 2024-04-04

<br>4321/3/012 에서 down side에 오류남 -1이 나올 수가 없는데
<br>idx가 가장 위의 자리를 가리킬 때를 따져야하는데, 1의 자리를 가리킬 때로, 오류를 수정하지 않음.


<br>수정오류: 자리수 침범이 있을 때, 해당 수를 mod를 통해 제대로된 수로 바꾸어 주어야하는데 그 구문을 빼놓 ✅ 2024-04-04

<br>위랑 같은 반례


<br>반례 1555/8/0 1 3 4 5 6 7 9 ✅ 2024-04-04

<br>setmin에 문제가 있어보임. → 숫자버튼으로 ㅣㅇ동한 경우가 2888 임. 2222여야하는데
<br>setmin, setmax idx 설정 위치 오류
<br>하나라도 숫자가 변하면 아래는 바꿔줘야하고
<br>위에는 지릿구 문제가 생기면 바꿔줘야함
<br>두개를 구분을 못함.
<br>또문제 답은 670인데 실제는 671이 나옴… 1은 어디서 나온거야? ✅ 2024-04-04

<br>1555

<br>up

<br>5→8 → 2
<br>5→8 → 2
<br>5→8 → 2
<br>1→2 *


<br>down

<br>5→2→8
<br>5→2→8
<br>5→2→8
<br>1→x *
<br>




<br>문제 → 자릿수 침범이 일어나면 위에 자릿수도 바뀌기 때문에 set min max idx를 침범을 받은 곳 까지 올려줘야함.

<br>또문제 바꾸었더니 자릿수 에 문제가 생긴듯. (9/5/9 8 7 6 5 → up의 경우 10이 아니라 0이 나옴) ✅ 2024-04-09






<br>또다시 2%로 돌아감

<br>찾은 반례:  199/1/9 → 4인데 14가 나옴.
<br>up의 겨우에 200이 나와야하는데, 110이 나옴? ✅ 2024-04-09

<br>아 위에 자리수에 +1 해줘야하는데 1로만 만들어버림..! +=오타남…


<br>99933/2/3 9 → 73인데 11050이 나옴.

<br>up이 200000이 나와버림..! 100000이 나와야하는데
<br>자리수 침해 해결하고 나서 1을 자리수만 남길 때 list 의 전체 idx가 변경된 경우에 문제가 생김…




]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/1107.-리모컨.html</link><guid isPermaLink="false">1. Study/Coding Test/1107. 리모컨.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 09 Apr 2024 08:40:12 GMT</pubDate></item><item><title><![CDATA[1157. 단어 공부]]></title><description><![CDATA[ 
 <br>NAV: <a data-href="1. Study/Coding Test.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test" class="internal-link" target="_self" rel="noopener">1. Study/Coding Test.md</a><br><br><br>알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.<br><br>첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.<br><br>첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.<br><br>Mississipi<br><br>?<br><br>zZa<br><br>Z<br><br>z<br><br>Z<br><br>baaa<br><br>A<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author5" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/author5" target="_blank">author5</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jejeje8" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jejeje8" target="_blank">jejeje8</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/kimhs" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/kimhs" target="_blank">kimhs</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/rnjs4197" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/rnjs4197" target="_blank">rnjs4197</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><br><br>
<br>굳이 BufferedReader를 쓸 필요가 없음… <a data-href="BufferedReader" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/bufferedreader.html" class="internal-link" target="_self" rel="noopener">BufferedReader</a>
<br>//생략
    public void Solution2_noBuffer() throws IOException {  
        int[] cntList = new int[65+26];  
        byte[] inputByteList = new byte[8192];  
        int max=0;  
        int same=0;  
        InputStream is = System.in;  
        is.read(inputByteList);  
  
  
        for (int i=0; i&lt;inputByteList.length; i++) {  
            byte b = inputByteList[i];  
            System.out.println(b);  
            cntList[b] += 1;  
        }  
  
        for (int i=65; i&lt;cntList.length; i++) {  
            if(cntList[i] &gt; max) {  
                max = i;  
                same = 0;  
            } else if (cntList[i] == max) {  
                same = 1;  
            }  
        }  
  
        if (same == 0) {  
            System.out.println(max);  
        }else {  
            System.out.println("?");  
        }  
    }  
    public static void main(String[] args) throws IOException {  
        new Main().Solution2_noBuffer();  
    }  
}
복사<br>
<br>
byte로 받는 걸로 바꾸다가 생긴 문제점… upper case로만 치는 거 어떻게 할건데?

<br>다른 사람 풀이의 &amp;31이 그 방법인가 싶은데… <a data-tooltip-position="top" aria-label="https://gimkuku0708.tistory.com/19" rel="noopener" class="external-link" href="https://gimkuku0708.tistory.com/19" target="_blank">(C++) 2018 KAKAO BLIND RECRUITMENT[1차] : 뉴스 클러스터링</a> → 3. 알파벳들을 모두 대소문자를 구분없는 숫자로 바꾼다 =&gt; 아스키연산 &amp;31 부분.
<br>A:65 = 0010 0001
<br>a:97= 0110 0001
<br>&amp;31 = 0001 1111 = 1+2+4+8+16 = 31

<br>차이가 있는 32bit 자리는 0으로
<br>쓸데없이 값을 크게하는 64bit자리도으로
<br>나며지는 1이면 1, 0이면 0으로 출력.
<br>즉 → 아래 5bit만 살려주겠다!


<br>&amp;32 = 0100 0000 → 대소문자 바꾸기. 32bit자리를 크고 꺼주기…

<br>아 이건 AND가 아니라 XOR로 해서 대소문자 바꾸기로 써줄 수 있음.
<br>주어진 32bit 자리가 1이면 11이라 0 / 0이면 01이라 1




<br>
그리고 byte list의 capacity말고, size를 반환하는 방법도 문제.

<br>primitive type의 경우에는 length변수만 사용가능한데 이건 capacity를 반환.
<br>처음에는 while문으로 buffer의 값이 0보다 크면, 으로 했는데 잘 작동 안함
<br>for (int i=0;buf[i]&gt;64;i++) 와 같은 방법으로 해결


<br>
출력할때는 |64로 대문자로 만들어주기.

<br><br>:런타임 에러&nbsp;(ArrayIndexOutOfBounds)<br>
<br>input byte개수가 최대 1000000라는 걸 간과
<br><br>:틀]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/1157.-단어-공부.html</link><guid isPermaLink="false">1. Study/Coding Test/1157. 단어 공부.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Wed, 15 May 2024 01:21:04 GMT</pubDate></item><item><title><![CDATA[1309.동물원]]></title><description><![CDATA[ 
 <br>NAV: <a data-href="1. Study/Coding Test.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test" class="internal-link" target="_self" rel="noopener">1. Study/Coding Test.md</a><br><br><br>어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.<br><img alt="" src="https://www.acmicpc.net/upload/201004/dnfl.JPG" referrerpolicy="no-referrer" style="width: 164px; max-width: 100%;"><br>이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.<br>동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.<br><br>첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.<br><br>첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.<br><br>4<br><br>41<br><br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/joon8409" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/joon8409" target="_blank">joon8409</a>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/xhark" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/xhark" target="_blank">xhark</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><br><br>
<br>brute-force로..는 안될 것같음.
<br>다이나믹
<br>와씨 사자를 몇마리 이상 배치해야한다는 말이 없음…
<br>추가되는 경우의 수 → x/오/왼<br><br><br><br><br><br>\3 → xrl<br><br>2 → xr<br><br>2 → xl<br>=&gt; x → 3 / r → 2 / l → 2 (원래 111)<br><br>
<br>dp 사용시, 처음에 입력값들을 예외처리로 미리 빼주는 거 잊지 말기.
<br>아악 나누기 안해줌.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/1309.동물원.html</link><guid isPermaLink="false">1. Study/Coding Test/1309.동물원.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Wed, 15 May 2024 01:54:24 GMT</pubDate><enclosure url="https://www.acmicpc.net/upload/201004/dnfl.JPG" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.acmicpc.net/upload/201004/dnfl.JPG"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[11047. 동전 0]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:실버/4" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실버/4</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener">#코딩테스트</a><br>
<a href="https://sunha20.github.io/digital-garden?query=tag:실버/4" class="tag" target="_blank" rel="noopener">#실버/4</a> <br><br><br>준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.<br>동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)<br>둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai&nbsp;≤ 1,000,000, A1&nbsp;= 1, i&nbsp;≥ 2인 경우에&nbsp;Ai는 Ai-1의 배수)<br><br>첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.<br><br>10 4200<br>
1<br>
5<br>
10<br>
50<br>
100<br>
500<br>
1000<br>
5000<br>
10000<br>
50000<br><br>6<br><br>10 4790<br>
1<br>
5<br>
10<br>
50<br>
100<br>
500<br>
1000<br>
5000<br>
10000<br>
50000<br><br>12<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/ai4youej" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/ai4youej" target="_blank">ai4youej</a>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><br><br>import sys  
  
def coin_0():  
N, total = map(int, sys.stdin.readline().split())  
coin = []  
now = 0  
cnt = 0  
  
for _ in range(N):  
coin.append(int(sys.stdin.readline().rstrip()))  
  
for v in reversed(coin):  
  
while now + v &lt;= total:  
cnt += 1  
now += v  
  
if now == total:  
print(cnt)  
break  
  
  
if __name__ == "__main__":  
coin_0()
복사<br>
<br>생각해보니 굳이 반복문 돌릴 필요 없음, 나누기로 해결 가능
<br><br>import sys

def coin_0():
    N, total = map(int, sys.stdin.readline().split())
    coin = []
    now = 0
    cnt = 0

    for _ in range(N):
        coin.append(int(sys.stdin.readline().rstrip()))

    for v in reversed(coin):
        temp = (total - now) // v
        cnt += temp
        now += v * temp

        if now == total:
            print(cnt)
            break

if __name__ == "__main__":
    coin_0()

복사<br><br>
<br>
종류를 무한으로 쓸 수 있는 건 쉬운데, 종류별로 갯수가 정해져있는 건 까다로움…

<br>
일전에 실패했던 배낭문제(<a data-href="12865. 평범한 배낭" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/12865.-평범한-배낭.html" class="internal-link" target="_self" rel="noopener">12865. 평범한 배낭</a>)와 이문제 (<a data-href="11047. 동전 0" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/11047.-동전-0.html" class="internal-link" target="_self" rel="noopener">11047. 동전 0</a>) 그리고 동전이 배수가 아닌 경우의 차이가 뭘까.

<br>
내생각

<br>


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/11047.-동전-0.html</link><guid isPermaLink="false">1. Study/Coding Test/11047. 동전 0.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Thu, 07 Mar 2024 05:33:26 GMT</pubDate></item><item><title><![CDATA[11279. 최대 힙]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:실버/2" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실버/2</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener">#코딩테스트</a><br>
<a href="https://sunha20.github.io/digital-garden?query=tag:실버/2" class="tag" target="_blank" rel="noopener">#실버/2</a><br><br><br>널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.<br>
<br>배열에 자연수 x를 넣는다.
<br>배열에서 가장 큰 값을 출력하고,&nbsp;그 값을 배열에서 제거한다.
<br>프로그램은 처음에 비어있는 배열에서 시작하게 된다.<br><br>첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 231보다 작다.<br><br>입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.<br><br>13<br>
0<br>
1<br>
2<br>
0<br>
0<br>
3<br>
2<br>
1<br>
0<br>
0<br>
0<br>
0<br>
0<br><br>0<br>
2<br>
1<br>
3<br>
2<br>
1<br>
0<br>
0<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/dantebald" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/dantebald" target="_blank">dantebald</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/spotky1004" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/spotky1004" target="_blank">spotky1004</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/1927" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1927" target="_blank">1927번. 최소 힙</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/11286" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/11286" target="_blank">11286번. 절댓값 힙</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/59" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/59" target="_blank">우선순위 큐</a>
<br><br>
<br>Java 8: 2 초
<br>Java 8 (OpenJDK): 2 초
<br>Java 11: 2 초
<br>Kotlin (JVM): 2 초
<br><br>
<br>오 이거 우선순위 큐 아닌가
<br>어떻게 구현 했었지… 
<br>deque없이 하려면 list에서는 가장 뒤에 걸 지웠을 때 시간복잡도가 작으니(남은 값들 옮길 필요 없음.) 오름차순으로 정렬.
<br>import sys  
  
def max_heap():  
N = int(sys.stdin.readline().rstrip())  
lst = []  
  
while N &gt; 0:  
N -= 1  
x = int(sys.stdin.readline().rstrip())  
  
if x != 0:  
lst.append(x)  
  
else:  
if len(lst) != 0:  
lst.sort()  
print(lst.pop())  
else:  
print(0)  
  
if __name__ == "__main__":  
max_heap()
복사<br>
<br>결과: 시간초과…
<br><br>
<br>
<a data-tooltip-position="top" aria-label="https://yoongrammer.tistory.com/81" rel="noopener" class="external-link" href="https://yoongrammer.tistory.com/81" target="_blank">[자료구조] 우선순위 큐 (Priority Queue) 개념 및 구현</a>

<br>
오 힙으로 구현해야하는데, 트리 다 까먹었는데….

<br>
파이썬 heap관련 모듈: heapq

<br>import sys, heapq  
  
  
def max_heap():  
N = int(sys.stdin.readline().rstrip())  
heap = []  
  
while N &gt; 0:  
N -= 1  
x = int(sys.stdin.readline().rstrip())  
  
if x != 0:  
heapq.heappush(heap, -x)  
  
else:  
if len(heap) != 0:  
print(-heapq.heappop(heap))  
else:  
print(0)  
  
if __name__ == "__main__":  
max_heap()

복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/11279.-최대-힙.html</link><guid isPermaLink="false">1. Study/Coding Test/11279. 최대 힙.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 02 Mar 2024 03:15:50 GMT</pubDate></item><item><title><![CDATA[12865. 평범한 배낭]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:골드/5" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#골드/5</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener">#코딩테스트</a><br>
<a href="https://sunha20.github.io/digital-garden?query=tag:골드/5" class="tag" target="_blank" rel="noopener">#골드/5</a><br><br><br>이 문제는 아주 평범한 배낭에 관한 문제이다.<br>한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.<br>준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.<br><br>첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.<br>입력으로 주어지는 모든 수는 정수이다.<br><br>한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.<br><br>4 7<br>
6 13<br>
4 8<br>
3 6<br>
5 12<br><br>14<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/Acka" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/Acka" target="_blank">Acka</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/kpqi5858" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/kpqi5858" target="_blank">kpqi5858</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/leedongbin" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/leedongbin" target="_blank">leedongbin</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/riroan" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/riroan" target="_blank">riroan</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/skyoliver" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/skyoliver" target="_blank">skyoliver</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/148" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/148" target="_blank">배낭 문제</a>
<br><br>
<br>다이나믹 프로그래밍 문제 → 최적부분구조를 어떻게 증명할것인가… → 안될 것같은데

<br>반례:

<br>(가치,무게) → (1, 1) (2, 1) (3, 1) (4, 1) (5, 4) / 최대 무게 4 인경우
<br>가치 5를 선택하는 것보다, 가치 4321을 선택하는 것이 더 큼.


<br>단순히 무게가 초과하지 않는 한 가치가 높은 것부터 선택한다는 풀이는 잘못됨.


<br>(무게-가치)로 판단을 해볼까? → 안<br>
```python<br>
import sys  
<br>def backpack():<br>
N, K = map(int, sys.stdin.readline().split())  <br>cnt = 0<br>
result = 0<br>
inDict = {}  <br>while N &gt; 0:<br>
N -= 1<br>
w, v = map(int, sys.stdin.readline().split())<br>
if v - w not in inDict:<br>
inDict[v - w] = [w, v]<br>
else:<br>
inDict[v - w]  <br>lst = sorted(inDict.keys(), key=lambda x: -x)  <br>for k, v in inDict.items():<br>
if v[0] &gt; K:<br>
continue  <br>result += v[1]<br>
K -= v[0]  <br>print(result)  <br>if name == "main":<br>
backpack()<br>- 같은 key에 추가… 하려면 복잡..

- 그냥 일단 다 돌려보자. 가능한 조합을 다? 시간 절대 안될 것같은데…
- 
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/12865.-평범한-배낭.html</link><guid isPermaLink="false">1. Study/Coding Test/12865. 평범한 배낭.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 05 Mar 2024 06:14:42 GMT</pubDate></item><item><title><![CDATA[15969. 행복]]></title><description><![CDATA[ 
 <br>NAV: <a data-href="1. Study/Coding Test.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test" class="internal-link" target="_self" rel="noopener">1. Study/Coding Test.md</a><br><br><br>코이 초등학교에 새로 부임하신 교장 선생님은 어린 학생들의 행복감과 학생들의 성적 차이 관계를 알아보기로 했다. 그래서 이전 성적을 조사하여 학생 들의 시험 점수 차이 변화를 알아보려고 한다.<br>예를 들어서 2016년 학생 8명의 점수가 다음과 같다고 하자.<br>27, 35, 92, 75, 42, 53, 29, 87<br>그러면 가장 높은 점수는 92점이고 가장 낮은 점수는 27점이므로 점수의 최대 차이는 65이다. 한편 2017년 학생 8명의 점수가 다음과 같았다.<br>85, 42, 79, 95, 37, 11, 72, 32<br>이때 가장 높은 점수는 95점이고 가장 낮은 점수는 11점이므로 점수의 최대 차이는 84이다.<br>N명 학생들의 점수가 주어졌을 때, 가장 높은 점수와 가장 낮은 점수의 차이를 구하는 프로그램을 작성하시오<br><br>표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 학생 수&nbsp;N이 주어진다. 다음 줄에는&nbsp;N명의 학생 점수가 공백 하나를 사이에 두고 주어진다.<br><br>표준 출력으로 가장 높은 점수와 가장 낮은 점수의 차이를 출력한다.<br><br>모든 서브태스크에서 2 ≤&nbsp;N&nbsp;≤ 1,000이고 입력되는 학생들의 점수는 0 이상 1,000 이하의 정수이다.<br><br>학생 수가 2명인 경우만 존재한다.<br><br>점수가 낮은 점수부터 높은 점수까지 순서대로 주어진다.<br><br>원래의 제약 조건 이외에 아무 제약 조건이 없다.<br><br>5<br>
27 35 92 75 42<br><br>65<br><br>8<br>
85 42 79 95 37 11 72 32<br><br>84<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/55" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/55" target="_blank">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/427" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/427" target="_blank">KOI 2018</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/1894" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/1894" target="_blank">초등부</a>&nbsp;1번<br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/121" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/121" target="_blank">사칙연산</a>
<br><br>
<br>파이썬의 map(int, 어쩌구.split())을 java에서 사용하고 싶음… → <a data-tooltip-position="top" aria-label="https://velog.io/@suyyeon/JAVA-String-%EB%B0%B0%EC%97%B4%EC%9D%84-int-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0" rel="noopener" class="external-link" href="https://velog.io/@suyyeon/JAVA-String-%EB%B0%B0%EC%97%B4%EC%9D%84-int-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0" target="_blank">[JAVA] String 배열을 int 배열로 변환하기</a>
<br>int[] gradeList = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
복사<br><br>import java.io.*;  
import java.util.Arrays;  
  
public class Main {  
    public void Solution() throws IOException {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        int n = Integer.parseInt(br.readLine());  
        int[] gradeList = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();  
        int max = -1;  
        int min = 1001;  
        for(int grade: gradeList) {  
            if (grade &gt; max) {  
                max = grade;  
            }  
            if (grade &lt; min) {  
                min = grade;  
            }  
        }  
        System.out.println(max-min);  
        br.close();  
    }  
    public static void main(String[] args) throws IOException {  
        new Main().Solution();  
    }  
}
복사<br>
<br>이거 parsed int를 각각에서 하면 조금 시간을 줄일 수있지 않을까? → 와안전 조금 주넼ㅋㅋㅋ
<br>public void Solution2_time() throws IOException {  
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
    int n = Integer.parseInt(br.readLine());  
    String[] gradeList = br.readLine().split(" ");  
    int max = -1;  
    int min = 1001;  
    for(String grade: gradeList) {  
        int gradeInt = Integer.parseInt(grade);  
        if (gradeInt &gt; max) {  
            max = gradeInt;  
        }  
        if (gradeInt &lt; min) {  
            min = gradeInt;  
        }  
    }  
    System.out.println(max-min);  
    br.close();  
}
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/15969.-행복.html</link><guid isPermaLink="false">1. Study/Coding Test/15969. 행복.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Wed, 15 May 2024 01:20:09 GMT</pubDate></item><item><title><![CDATA[개인정보 수집 유효기간]]></title><description><![CDATA[ 
 <br><br>Site: 프로그래머스<br>
난이도: Lv 1<br>
다시풀기: No<br>
분류: 2023, Blind Recruitment, kakao<br>
생성 일시: 2023년 3월 10일 오후 4:36<br><br>def solution(today, terms, privacies):
    answer = []

    # terms to Dict
    terms_dict = {}

    for i in terms:
        cate = i.split()[0]
        term = int(i.split()[1])
        terms_dict[cate] = term

    # privacies date processing
    num = 0
    for i in privacies:
        num += 1
        date, cate = map(str, i.split())
        py, pm, pd = map(int, date.split('.'))
        ty, tm, td = map(int, today.split('.'))

        due_month = (pm + terms_dict[cate]) % 12        
        due_year = py + ((pm + terms_dict[cate]) // 12)
        if due_month == 0:
            due_month = 12
            due_year -= 1

        # print((pm + terms_dict[cate]) // 12)
        print(due_month, due_year)

        if due_year &lt; ty:
            answer.append(num)
        elif due_year &gt; ty:
            None           
        else:           
            if due_month &lt; tm:
                answer.append(num)
            elif due_month &gt; tm:
                None           
            else:  
                if pd &lt;= td:
                    answer.append(num)

    return answer
복사<br><br>: 이걸 쓸 수도 있지 않았을까?<br>
<br>datetime.timedelta(days=0,&nbsp;seconds=0,&nbsp;microseconds=0,&nbsp;milliseconds=0,&nbsp;minutes=0,&nbsp;hours=0,&nbsp;weeks=0)

<br>시간계산
<br>years가 없네…
<br>주의: overflow


<br>datetime.fromisoformat(string)

<br>string 객체를 datetime 형식으로 변환


<br><br>def to_days(date):
    year, month, day = map(int, date.split("."))
    return year * 28 * 12 + month * 28 + day

def solution(today, terms, privacies):
    months = {v[0]: int(v[2:]) * 28 for v in terms}
    today = to_days(today)
    expire = [
        i + 1 for i, privacy in enumerate(privacies)
        if to_days(privacy[:-2]) + months[privacy[-1]] &lt;= today
    ]
    return expire
복사<br><br>
<br>자주 쓰는 코드 따로 function으로 빼줘서 간다하게하기
<br>간단하게 사용하는 for문 기억해두기 (꼭?)
# 예시
[i for i in list()]
{j:j for j in list()}
복사

<br>def solution(today, terms, privacies):
    answer = []
    termdict = {}

    for term in terms:
        t = term.split(' ')
        termdict[t[0]] = int(t[1]) * 28

    t = today.split('.')
    d = 28 * 12 * int(t[0]) + 28 * int(t[1]) + int(t[2])

    for p in range(len(privacies)):
        pret = privacies[p].split(' ')
        t = pret[0].split('.')
        nd = 28 * 12 * int(t[0]) + 28 * int(t[1]) + int(t[2])

        if termdict[pret[1]] + nd &lt;= d:
            answer.append(p + 1)

    return answer
복사<br><br>
<br>day가 딱 28일로 통일되어 있으니, ‘년월일’이 아니라 숫자 하나로 통합해서 비교를 한번만 하면되겠네.
<br>위의 코드도 그 방법인데 이게 더 직관적이었음..
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/개인정보-수집-유효기간.html</link><guid isPermaLink="false">1. Study/Coding Test/개인정보 수집 유효기간.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[계단 오르기]]></title><description><![CDATA[ 
 <br><br>ID: 2579<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/2579" target="_blank">https://www.acmicpc.net/problem/2579</a><br>
난이도: 실버 3<br>
다시풀기: Yes<br>
메모: 끝나는거 기준으로 dp 다시 만들어 보기<br>
생성 일시: 2023년 8월 27일 오후 9:01<br><br><br><br><br>계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. &lt;그림 1&gt;과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.<br><a rel="noopener" class="external-link" href="https://upload.acmicpc.net/7177ea45-aa8d-4724-b256-7b84832c9b97/-/preview/" target="_blank">https://upload.acmicpc.net/7177ea45-aa8d-4724-b256-7b84832c9b97/-/preview/</a><br>&lt;그림 1&gt;<br>예를 들어 &lt;그림 2&gt;와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.<br><a rel="noopener" class="external-link" href="https://upload.acmicpc.net/f00b6121-1c25-492e-9bc0-d96377c586b0/-/preview/" target="_blank">https://upload.acmicpc.net/f00b6121-1c25-492e-9bc0-d96377c586b0/-/preview/</a><br>&lt;그림 2&gt;<br>계단 오르는 데는 다음과 같은 규칙이 있다.<br>
<br>계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
<br>연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
<br>마지막 도착 계단은 반드시 밟아야 한다.
<br>따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.<br>각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.<br><br>입력의 첫째 줄에 계단의 개수가 주어진다.<br>둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.<br><br>첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.<br><br>6
10
20
15
25
10
20

복사<br><br>75

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/55" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/55" target="_blank">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/57" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/57" target="_blank">한국정보올림피아드시․도지역본선</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/70" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/70" target="_blank">지역본선 2006</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/367" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/367" target="_blank">초등부</a>&nbsp;4번<br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cjswodmlskfk" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/cjswodmlskfk" target="_blank">cjswodmlskfk</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/eric00513" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/eric00513" target="_blank">eric00513</a>
<br><br>
<br>그냥 다 찾아서 최대값
<br>트리를 만들까? 이진 트리 만들 수 있을 것같은데.

<br>트리 만들고 탐색을 할때,


<br>import sys

class Node:
    def __init__(self, parent, id, val):
        self.parent = parent
        self.id = id
        self.element = val
        self.left = None
        self.right = None

class Tree:
    def __init__(self, id):
        self.root = Node(None, id, num_list[id])
        build_tree(self.root, 0)

def build_tree(node, num):
    id = node.id
    sum = node.element + num

    if id == N:
        val_list.append(sum)
    elif id == N-1:
        if node.parent == None or node.id == node.parent.id + 2:
            node.left = Node(node, id + 1, num_list[id + 1])
            build_tree(node.left, sum)
    else:
        if node.parent == None or node.id == node.parent.id + 2:
            node.left = Node(node, id + 1, num_list[id + 1])
            node.right = Node(node, id + 2, num_list[id + 2])
            build_tree(node.left, sum)
            build_tree(node.right, sum)

        else:
            node.right = Node(node, id + 2, num_list[id + 2])
            build_tree(node.right, sum)

N = int(sys.stdin.readline().rstrip())
num_list = [0]
val_list = []

for i in range(N):
    num_list.append(int(sys.stdin.readline().rstrip()))

if N &gt;= 2:
    stair_route_one = build_tree(Tree(1).root, 0)
    stair_route_two = build_tree(Tree(2).root, 0)
else:
    stair_route_one = build_tree(Tree(1).root, 0)

print(max(val_list))
복사<br>
<br>
재귀로 짰는데, 메모리 초과… dp 문제라네…

<br>
dp 어떻게 해야할까.

<br>2로끝

<br>1,2


<br>3 끝

<br>1,3
<br>2,3


<br>4끝

<br>2,4 → 1,2
<br>3,4 → 1,3


<br>5Rmx

<br>3,5 → 1,3|2,3
<br>4,5 → 2,4




<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/계단-오르기.html</link><guid isPermaLink="false">1. Study/Coding Test/계단 오르기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[괄호]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:실버/4" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실버/4</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener">#코딩테스트</a><br>
<a href="https://sunha20.github.io/digital-garden?query=tag:실버/4" class="tag" target="_blank" rel="noopener">#실버/4</a><br><br><br>괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다.&nbsp;<br>여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.&nbsp;<br><br>입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다.&nbsp;<br><br>출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.&nbsp;<br><br>6<br>
(())())<br>
(((()())()<br>
(()())((()))<br>
((()()(()))(((())))()<br>
()()()()(()()())()<br>
(()((())()(<br><br>NO<br>
NO<br>
YES<br>
NO<br>
YES<br>
NO<br><br>3<br>
((<br>
))<br>
())(()<br><br>NO<br>
NO<br>
NO<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/1" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/1" target="_blank">ICPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/7" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/7" target="_blank">Regionals</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/42" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/42" target="_blank">Asia Pacific</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/211" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/211" target="_blank">Korea</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/256" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/256" target="_blank">Nationwide Internet Competition</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/1081" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/1081" target="_blank">Daejeon Nationalwide Internet Competition 2012</a>&nbsp;G번<br>
<br>데이터를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/marona" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/marona" target="_blank">marona</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/71" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/71" target="_blank">스택</a>
<br><br>Python에서 strip()을 이용하면 문자열에서 특정 문자를 제거할 수 있습니다. Java 등의 다른 언어들도 strip()을 제공하며, 기능은 모두 비슷합니다.<br>Python의 String은 다음 함수를 제공합니다.<br>strip([chars]) : 인자로 전달된 문자를 String의 왼쪽과 오른쪽에서 제거합니다. lstrip([chars]) : 인자로 전달된 문자를 String의 왼쪽에서 제거합니다. rstrip([chars]) : 인자로 전달된 문자를 String의 오른쪽에서 제거합니다. 인자를 전달하지 않을 수도 있으며, 인자를 전달하지 않으면 String에서 공백을 제거합니다.<br><br>()를 공백으로 대체하는 걸 반복하다가 없으면 no 출력하는방식이. 더 빠르네. n + (n-2) + (n-4) + ... + 0 -&gt; n*(1/2)n인데....<br><br>내가 결과적으로 한 방식은, 조금 더 생각해서 합칠 수 있는 걸 합쳐야 했어. 더하고 빼다가, -1이 나오면 멈추는 방식으로.<br><br>while이 for 보다 빠른가봐... (40 vs 44) 꼭 for일 필요 없는거.(그러니까, 리스트 item들 한바퀴돌리면서 사용해야하는 경우 말고, 그냥 숫자만큼 반복은 while이 빠르네...)]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/괄호.html</link><guid isPermaLink="false">1. Study/Coding Test/괄호.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 02 Mar 2024 02:41:54 GMT</pubDate></item><item><title><![CDATA[기본]]></title><description><![CDATA[ 
 <br><br>다시풀기: No<br>
생성 일시: 2023년 4월 11일 오후 1:50<br><br><br><br>복사<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/기본.html</link><guid isPermaLink="false">1. Study/Coding Test/기본.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[나는야 포켓몬 마스터 이다솜]]></title><description><![CDATA[ 
 <br><br>ID: 1620<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1620" target="_blank">https://www.acmicpc.net/problem/1620</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 자료구조, 해시를 사용한 집합과 맵<br>
생성 일시: 2023년 7월 29일 오전 12:40<br><br><br><br><br><img alt="https://www.acmicpc.net/upload/201004/p1.PNG" src="https://www.acmicpc.net/upload/201004/p1.PNG" referrerpolicy="no-referrer"><br>안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으로 가야겠어.<br>(뚜벅 뚜벅)<br>얏! 꼬렛이다. 꼬렛? 귀여운데, 나의 첫 포켓몬으로 딱 어울린데? 내가 잡고 말겠어. 가라! 몬스터볼~<br>(펑!) 헐랭... 왜 안 잡히지?ㅜㅜ 몬스터 볼만 던지면 되는 게 아닌가...ㅜㅠ<br>(터벅터벅)<br>어? 누구지?<br><img alt="https://www.acmicpc.net/upload/201004/p2.PNG" src="https://www.acmicpc.net/upload/201004/p2.PNG" referrerpolicy="no-referrer"><br>오박사 : 나는 태초마을의 포켓몬 박사 오민식 박사라네. 다솜아, 포켓몬을 잡을 때는, 일단 상대 포켓몬의 체력을 적당히 바닥으로 만들어놓고 몬스터 볼을 던져야 한단다. 자, 내 포켓몬 이상해꽃으로 한번 잡아보렴. 포켓몬의 기술을 쓰는 것을 보고 포켓몬을 줄지 안줄지 결정을 하겠네. 자 한번 해보아라. 다솜아.<br>이다솜 : 이상해꽃이라...음.. 꽃이니깐 왠지 햇빛을 받아서 공격을 할 것 같은데... 음... 이상해꽃! 햇빛공격!!!<br>(꼬렛이 이상해꽃에게 공격을 받아 체력이 25 감소했다.) &nbsp;&nbsp; 가라! 몬스터 볼!!! &nbsp;&nbsp; (꼬렛을 잡았습니다.) &nbsp;&nbsp; 야호! 신난다. 꼬렛을 잡았다.<br>오박사 : 오우!! 방금 쓴 공격은 솔라빔이라고 하네.. 어떻게 공격을 한 건가? 솔라빔이란 공격에 대해서 공부를 한 건가?<br>이다솜 : 꽃이니깐 왠지 햇빛을 제대로 받으면 광합성을 해서 음.. 그냥 그럴 것 같아서요 ☞☜<br>오박사 : 다른 아이들은 넝쿨채찍이나, 나뭇잎 공격을 하는데, 다솜이는 역시 뭔가 다르구나. 그럼 나와 함께 연구소로 가자꾸나. 내가 포켓몬을 한 마리 줄 테니, 너의 꿈을 펼쳐보아라. 꿈은 이루어진단다.<br>이다솜 : 네! 오박사님, 고마워요.ㅜㅜ<br>오박사 : 가자. 나의 연구소는 너의 옆집의 아랫집이란다. 같이 가도록하자. 지금 포켓몬을 주마.<br>이다솜 : 네. 야호!!<br>'<br><img alt="https://www.acmicpc.net/upload/201004/p3.PNG" src="https://www.acmicpc.net/upload/201004/p3.PNG" referrerpolicy="no-referrer"><br>오영식 : 어? 오박사님 얘는 누구인가요?<br><img alt="https://www.acmicpc.net/upload/201004/p4.PNG" src="https://www.acmicpc.net/upload/201004/p4.PNG" referrerpolicy="no-referrer"><br>오박사 : 얘는 너의 라이벌이 될 친구 이다솜이라고 하네. 자, 포켓몬을 한 마리 골라보도록 해봐라 다솜아. 레이디퍼스트 네가 먼저 골라봐라.<br>이다솜 : 저는 생각해둔 포켓몬이 있어요. 피카츄 골라도 될까요?<br>오박사 : 그래 여기 피카츄가 한 마리 있단다. 피카츄를 가져가거라.<br>오영식 : 그럼 저는 이브이를 가져가겠어요. 그럼 나중에 보자 이다솜.<br>이다솜 : 그럼 꼬렛을 다시 잡으러 가야겠다. 영식아, 그리고 민식박사님 빠잉!<br><img alt="https://www.acmicpc.net/upload/201004/p5.PNG" src="https://www.acmicpc.net/upload/201004/p5.PNG" referrerpolicy="no-referrer"><br>이다솜 : 피카츄 공격!<br><img alt="https://www.acmicpc.net/upload/201004/p6.PNG" src="https://www.acmicpc.net/upload/201004/p6.PNG" referrerpolicy="no-referrer"><br>가라 몬스터 볼!<br><img alt="https://www.acmicpc.net/upload/201004/p7.PNG" src="https://www.acmicpc.net/upload/201004/p7.PNG" referrerpolicy="no-referrer"><br>이다솜 : 야호! 신난다. 꼬렛을 잡았다!!!!!<br>이다솜 : 그럼! 일단 사천왕을 이기고 오겠어!<br><img alt="https://www.acmicpc.net/upload/201004/p8.PNG" src="https://www.acmicpc.net/upload/201004/p8.PNG" referrerpolicy="no-referrer"><br>이다솜 : 여기가 사천왕과 대결하려면 가야하는 곳인가..<br><img alt="https://www.acmicpc.net/upload/201004/p9.PNG" src="https://www.acmicpc.net/upload/201004/p9.PNG" referrerpolicy="no-referrer"><br>경비원 : 사천왕과 대결을 하려면, 마을의 체육관 리더를 이겨서 배지를 8개를 모아야 한다네... 배지를 모아서 오도록 하게<br>이다솜 : 잉ㅠㅜ... 그럼 배지부터 모아야 하는구나ㅠㅜㅠㅜ 나쁘당 그냥 좀 봐주지..<br>&lt;1 년 후&gt;<br>그동안의 줄거리 : 이다솜은 일단 상록 숲의 체육관 리더에게 도전을 했다. 하지만 상록숲 체육관의 리더는 실종된 상태. 따라서 회색마을부터 도전하기로 했다. 체육관의 리더를 이기면서, 로켓단을 해체시키기도 하고, 여러 가지 사건도 있었다. 결국 전설의 포켓몬도 잡고, 이제 사천왕을 이기려고 도전하기로 했다. 사천왕은 모두 가볍게 이기고, 이제 마지막 라이벌 오!영!식! 이다.<br><img alt="https://www.acmicpc.net/upload/201004/pa.PNG" src="https://www.acmicpc.net/upload/201004/pa.PNG" referrerpolicy="no-referrer"><br>오영식 : 훗. 1년 전의 그 이다솜이 사천왕을 이기고 현재 포켓몬 마스터인 나에게 덤벼? 어디 한번 덤벼보시지.<br>이다솜 : 헐랭... 나를 우습게보네.... 한번 두고 보시지! 그럼 대결이닷!<br><img alt="https://www.acmicpc.net/upload/201004/pb.PNG" src="https://www.acmicpc.net/upload/201004/pb.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pc.PNG" src="https://www.acmicpc.net/upload/201004/pc.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pd.PNG" src="https://www.acmicpc.net/upload/201004/pd.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pe.PNG" src="https://www.acmicpc.net/upload/201004/pe.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pf.PNG" src="https://www.acmicpc.net/upload/201004/pf.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pg.PNG" src="https://www.acmicpc.net/upload/201004/pg.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/ph.PNG" src="https://www.acmicpc.net/upload/201004/ph.PNG" referrerpolicy="no-referrer"><br><img alt="https://www.acmicpc.net/upload/201004/pi.PNG" src="https://www.acmicpc.net/upload/201004/pi.PNG" referrerpolicy="no-referrer"><br>이다솜 : 휴... 이겼다.<br>오영식 : 내가 지다니 분하다. ㅜㅜ<br>오박사 : 그럼 다솜아 이제 진정한 포켓몬 마스터가 되기 위해 도감을 완성시키도록 하여라. 일단 네가 현재 가지고 있는 포켓몬 도감에서 포켓몬의 이름을 보면 포켓몬의 번호를 말하거나, 포켓몬의 번호를 보면 포켓몬의 이름을 말하는 연습을 하도록 하여라. 나의 시험을 통과하면, 내가 새로 만든 도감을 주도록 하겠네.<br><br>첫째 줄에는 도감에 수록되어 있는 포켓몬의 개수 N이랑 내가 맞춰야 하는 문제의 개수 M이 주어져. N과 M은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수인데, 자연수가 뭔지는 알지? 모르면 물어봐도 괜찮아. 나는 언제든지 질문에 답해줄 준비가 되어있어.<br>둘째 줄부터 N개의 줄에 포켓몬의 번호가 1번인 포켓몬부터 N번에 해당하는 포켓몬까지 한 줄에 하나씩 입력으로 들어와. 포켓몬의 이름은 모두 영어로만 이루어져있고, 또, 음... 첫 글자만 대문자이고, 나머지 문자는 소문자로만 이루어져 있어. 아참! 일부 포켓몬은 마지막 문자만 대문자일 수도 있어. 포켓몬 이름의 최대 길이는 20, 최소 길이는 2야. 그 다음 줄부터 총 M개의 줄에 내가 맞춰야하는 문제가 입력으로 들어와. 문제가 알파벳으로만 들어오면 포켓몬 번호를 말해야 하고, 숫자로만 들어오면, 포켓몬 번호에 해당하는 문자를 출력해야해. 입력으로 들어오는 숫자는 반드시 1보다 크거나 같고, N보다 작거나 같고, 입력으로 들어오는 문자는 반드시 도감에 있는 포켓몬의 이름만 주어져. 그럼 화이팅!!!<br><br>첫째 줄부터 차례대로 M개의 줄에 각각의 문제에 대한 답을 말해줬으면 좋겠어!!!. 입력으로 숫자가 들어왔다면 그 숫자에 해당하는 포켓몬의 이름을, 문자가 들어왔으면 그 포켓몬의 이름에 해당하는 번호를 출력하면 돼. 그럼 땡큐~<br><img alt="https://www.acmicpc.net/upload/201004/pn.PNG" src="https://www.acmicpc.net/upload/201004/pn.PNG" referrerpolicy="no-referrer"><br>이게 오박사님이 나에게 새로 주시려고 하는 도감이야. 너무 가지고 싶다ㅠㅜ. 꼭 만점을 받아줬으면 좋겠어!! 파이팅!!!<br><br>26 5
Bulbasaur
Ivysaur
Venusaur
Charmander
Charmeleon
Charizard
Squirtle
Wartortle
Blastoise
Caterpie
Metapod
Butterfree
Weedle
Kakuna
Beedrill
Pidgey
Pidgeotto
Pidgeot
Rattata
Raticate
Spearow
Fearow
Ekans
Arbok
Pikachu
Raichu
25
Raichu
3
Pidgey
Kakuna

복사<br><br>Pikachu
26
Venusaur
16
14

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/frogyou2330" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/frogyou2330" target="_blank">frogyou2330</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/136" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/136" target="_blank">해시를 사용한 집합과 맵</a>
<br><br>
<br>단어랑 숫자를 전부 생각해야해
<br>tag를 보면, dictionary를 사용해야하는 듯

<br>key를 알파벳 첫자로 하는 경우.


<br>근데 내가 생각한대로면 그냥, 데이터를 2군데에 저장하는 건데.
<br>
<br>list → index가 숫자 그대로 / dictionary → 첫글자를 key로 ⇒ 최대 2만개.
<br>100으로 나눴을 때, 나머지를 index로 하는 list에 dictionary값 저장

<br>이거를 N을 기준으로 해보자.
<br>N의 절반을 기준으로 나누기.


<br>첫글자 ascii code를 index로 하는 list에, key가 숫자인 dictionary값 (혹은 index가 숫자인 list)저장

<br>이건 worst로, 다 같은 알파벳으로 시작하면,,, key(숫자)로 접근할때는 O(n)이지만, value를 기준으로 하면 다 돌아야함.. 숫자로 시작할 때보다(mode 쓰면 분포가 고름)더 에바.


<br>
<br>그러니까. 숫자로 들어왔을 때, 문자를 출력해야하고
<br>문자로 들어왔을 때, 숫자를 출력해야한다고.
<br>첫번째는 간단해, 그냥 숫자를 index로 해서 list를 만들면 되니까.
<br>두번째는 ascii를 index로 하는 list에 문자:숫자형태의 dictionary만들기. 아니지 굳이 그럴 필요 없이 그냥 dictionary만 쓰면 됨.
<br><br>import sys

def solution():
    N, M = map(int, sys.stdin.readline().rstrip().split())
    mod_num = N//2
    eng_list = {}
    num_list = [0]*(N+1)

    for num in range(N):
        name = sys.stdin.readline().rstrip()
        idx = num + 1
        num_list[idx] = name
        eng_list[name] = idx

    for _ in range(M):
        question = sys.stdin.readline().rstrip()
        if ord('A') &lt;= ord(question[0]) &lt;= ord('Z'):
            print(eng_list[question])
        else:
            print(num_list[int(question)])

if __name__ == "__main__":
    solution()
복사<br><br>import sys

def solution():
  lines = sys.stdin.read().splitlines()

  N, M = map(int, lines[0].split())

  encyclopedia = {
    name: str(index + 1)
    for index, name in enumerate(lines[1:N + 1])
  }

  print("\n".join(encyclopedia[exam] if exam.isalpha() else lines[int(exam)]
                  for exam in lines[N + 1:]))

solution()
복사<br>아 이게 바로 splitlines()로 input 다 받아서 바로 num_list로 만들어버렸네]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/나는야-포켓몬-마스터-이다솜.html</link><guid isPermaLink="false">1. Study/Coding Test/나는야 포켓몬 마스터 이다솜.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate><enclosure url="https://www.acmicpc.net/upload/201004/p1.PNG" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.acmicpc.net/upload/201004/p1.PNG"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[나이순 정렬]]></title><description><![CDATA[ 
 <br><br>ID: 10814<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/10814" target="_blank">https://www.acmicpc.net/problem/10814</a><br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 정렬<br>
생성 일시: 2023년 4월 12일 오후 1:05<br><br><br><br><br>온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.<br><br>첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000)<br>둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.<br><br>첫째 줄부터 총 N개의 줄에 걸쳐 온라인 저지 회원을 나이 순, 나이가 같으면 가입한 순으로 한 줄에 한 명씩 나이와 이름을 공백으로 구분해 출력한다.<br><br>3
21 Junkyu
21 Dohyun
20 Sunyoung

복사<br><br>20 Sunyoung
21 Junkyu
21 Dohyun

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><br>
<br>
<br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    result = ""
    
    lst = []

    while N&gt;0:
        N-=1
        age, name = sys.stdin.readline().split()
        lst.append([age, " "+name+"\n"])
    
    lst.sort(key=lambda x:x[0])
    for i in lst:
        result += "".join(i)

    print(result[:-1])
if __name__ == "__main__":
    solution()
복사<br><br>
<br>data_list.sort(key=lambda x : len(x))

<br>x의 길이를 기준으로 오름차순으로 정렬해주세요.


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/나이순-정렬.html</link><guid isPermaLink="false">1. Study/Coding Test/나이순 정렬.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[다이나믹프로그래밍(DP)]]></title><description><![CDATA[ 
 <br><br>ID: 0<br>
URL: <a rel="noopener" class="external-link" href="https://hongjw1938.tistory.com/47" target="_blank">https://hongjw1938.tistory.com/47</a><br>
다시풀기: No<br>
분류: 다이나믹 프로그래밍<br>
생성 일시: 2023년 8월 18일 오후 3:59<br>
참고: BFS<br><br><br>
<br>하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것
<br>큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용 = 기억하며 풀기
<br>일반적인 재귀(Naive Recursion) 방식 또한 DP와 매우 유사
<br><br><br>
<br>동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능
<br>이진 탐색(<a data-tooltip-position="top" aria-label="https://hongjw1938.tistory.com/40?category=884192" rel="noopener" class="external-link" href="https://hongjw1938.tistory.com/40?category=884192" target="_blank">참고</a>)와&nbsp;피보나치 수열의 경우를 비교해 보자.

<br>이진 탐색은 특정 데이터를 정렬된 배열 내에서 그 위치를 찾기 때문에 그 위치를 찾은 후 바로 반환할 뿐 그것을 재사용하는 과정을 거치지 않는다. 반면, 피보나치 수열은 f(n) = f(n-1) + f(n-2) 인데, 아래와 같은 트리 구조로 함수가 호출되게 된다.
<br>f(3), f(2), f(1)과 같이 동일한 부분 문제가 중복


<br><br>
<br>부분 문제에서 구한 최적 결과가 전체 문제에서도 동일하게 적용되어 결과가 변하지 않을 때 DP를 사용할 수 있게 된다.
<br><br><br>이름에서 보이듯이,&nbsp;아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식이다.<br>메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고 dp[n]을 목표 상태라고 하자. Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.<br><br>이는 dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해&nbsp;위에서 부터 바로 호출을 시작하여 dp[0]의 상태까지 내려간 다음 해당&nbsp;결과 값을 재귀를 통해 전이시켜 재활용하는 방식이다.<br>피보나치의 예시처럼, f(n) = f(n-2) + f(n-1)의 과정에서 함수 호출 트리의 과정에서 보이듯, n=5일 때, f(3), f(2)의 동일한 계산이 반복적으로 나오게 된다.<br>이 때, 이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 그래서 가장 최근의 상태 값을 메모해 두었다고 하여&nbsp;Memoization&nbsp;이라고 부른다.<br>"Untitled"이(가) 생성되지 않았습니다. 클릭하여 생성합니다.%20d88c8563b44f47958703582cec841bfb/Untitled.png)<br><br>Q. Divide and Conquer(분할 정복)와 차이점은?<br>분할 정복과&nbsp;동적 프로그래밍은&nbsp;주어진 문제를 작게 쪼개서 하위 문제로 해결하고 연계적으로 큰 문제를 해결한다는 점은 같다.<br>차이점은, 분할 정복은 분할된 하위 문제가 동일하게 중복이 일어나지 않는 경우에 쓰며, 동일한 중복이 일어나면 동적 프로그래밍을 쓴다는 것이다.<br><br>
<br>피보나치 구현에 재귀를 활용했다면 시간복잡도는&nbsp;O(2^n)이지만, 동적 계획법을 활용하면 O(N)으로 해결할 수 있다.
<br>## Bottom-up
def dp_fibonacci(x):
    dp = [0,1] + ([0]*(x-1))

    for i in range(2, len(dp)):
        dp[i] = dp[i-1] + dp[i-2]

    print(dp[x])
    print(dp)

dp_fibonacci(100)
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/다이나믹프로그래밍(dp).html</link><guid isPermaLink="false">1. Study/Coding Test/다이나믹프로그래밍(DP).md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:26:53 GMT</pubDate></item><item><title><![CDATA[단어정렬]]></title><description><![CDATA[ 
 <br><br>ID: 1181<br>
Site: 백준<br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 문자열, 정렬<br>
생성 일시: 2023년 4월 11일 오후 1:52<br><br><br>
<br>중복 제거 → set(순서 없음, 중복없음.)을 사용하려 했으나, 순서 없음이 헷갈릴 것 같아서 다른 방법 생각.
<br>사전식 배열 → 그냥 글자끼리 compare해도 가능 ⇒ 그런데 이방법은 길이와 관계가 없음.
<br>그러면 입력 받으면서 길이로 나누고(2d array? dict?)
<br>그 안에서 비교를 하자.
<br><br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    lst = [[] for _ in range(50)]

    while N &gt; 0:
        N-=1
        word = sys.stdin.readline().rstrip()        
        lst[len(word)-1].append(word)
        
    for i in lst:
        i.sort()
        for j in i:
            print(j)

if __name__ == "__main__":
    solution()
복사<br>
<br>중복제거를 하지 않았어…
<br>다 compare하는 방식으로 돌리기에는 코드가 복잡하고
<br>넣을때마다 있는지 없는지 확인하기에는 음…
<br>오! set을 쓰면 되겠다.
<br><br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    lst = [set() for _ in range(50)]

    while N &gt; 0:
        N-=1
        word = sys.stdin.readline().rstrip()        
        lst[len(word)-1].add(word)
        
    for i in lst:
        k = list(i)
        k.sort()
        for j in k:
            print(j)

if __name__ == "__main__":
    solution()
복사<br>
<br>더 줄일 수 있는데,,, 50,60대로…
<br>아…! set도 sort가능이네? 순서 없음인데?

<br>대신 set.sort()는 안됨


<br>똑같은디….
<br>아…! print를 반복하는 것도 실행시간에 영향을 줄 수 있음..
<br><br>
<br>set(순서없음, 중복 없음)은 append가 아니라, add를 쓴다.
<br>set도 sort 할 수 있다.

<br>대신 i.sort()는 list 전용이다. → 원본값을 수정함으로 빠름
<br>sorted()는 다 사용 가능


<br>+) set은 mutable, tuple은 수정이 어려움. → 그냥 ()는 tuple이다.
<br>여러번의 print()보다 join을 사용한 한번의 print() 더 빠르다.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/단어정렬.html</link><guid isPermaLink="false">1. Study/Coding Test/단어정렬.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[덩치]]></title><description><![CDATA[ 
 <br><br>ID: 7568<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/7568" target="_blank">https://www.acmicpc.net/problem/7568</a><br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 구현, 브루트포스 알고리즘<br>
생성 일시: 2023년 4월 12일 오전 11:10<br><br><br><br><br>우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다. 두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x &gt; p 그리고 y &gt; q 이라면 우리는 A의 덩치가 B의 덩치보다 "더 크다"고 말한다. 예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다. 예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, "덩치"로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.<br>N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 "큰 덩치"의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다. 이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.<br><br>위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다. 그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.<br><br>첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.<br><br>여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.<br><br>
<br>2 ≤ N ≤ 50
<br>10 ≤ x, y ≤ 200
<br><br>5
55 185
58 183
88 186
60 175
46 155

복사<br><br>2 2 1 2 5

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/55" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/55" target="_blank">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/57" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/57" target="_blank">한국정보올림피아드시․도지역본선</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/214" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/214" target="_blank">지역본선 2013</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/912" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/912" target="_blank">초등부</a>&nbsp;2번<br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/apjw6112" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/apjw6112" target="_blank">apjw6112</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/eric00513" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/eric00513" target="_blank">eric00513</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/genius0412" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/genius0412" target="_blank">genius0412</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jung2381187" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jung2381187" target="_blank">jung2381187</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/seecimi" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/seecimi" target="_blank">seecimi</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/rea9lizer" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/rea9lizer" target="_blank">rea9lizer</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/thebjko" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/thebjko" target="_blank">thebjko</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>
<br>그냥 brute-force로 해보지 뭐.
<br>튜플을 사용해도 되겠구나!
<br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    cnt = N
    result = []
    lst = []

    # input 받아서 키, 몸무게 list 생성
    while cnt &gt;0:
        cnt-=1
        x, y = map(int,sys.stdin.readline().rstrip().split(" "))
        lst.append((x,y))
    
    # 등수 구하기

    for i in lst:
        rank = 1
        for j in lst:
            if i[0] &lt; j[0] and i[1] &lt; j[1]:
                rank += 1
        result.append(str(rank))
        cnt += 1
    print(" ".join(result))

if __name__ == "__main__":
    solution()
복사<br><br>
<br>join은 list의 요소가 str이어야함.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/덩치.html</link><guid isPermaLink="false">1. Study/Coding Test/덩치.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[듣보잡]]></title><description><![CDATA[ 
 <br><br>ID: 1764<br>
Site: 백준<br>
URL: acmicpc.net/problem/1764<br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 문자열, 자료구조, 정렬, 해시를 사용한 집합과 맵<br>
생성 일시: 2023년 8월 3일 오후 11:51<br><br><br><br><br>김진영이 듣도 못한 사람의 명단과, 보도 못한 사람의 명단이 주어질 때, 듣도 보도 못한 사람의 명단을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 듣도 못한 사람의 수 N, 보도 못한 사람의 수 M이 주어진다. 이어서 둘째 줄부터 N개의 줄에 걸쳐 듣도 못한 사람의 이름과, N+2째 줄부터 보도 못한 사람의 이름이 순서대로 주어진다. 이름은 띄어쓰기 없이 알파벳 소문자로만 이루어지며, 그 길이는 20 이하이다. N, M은 500,000 이하의 자연수이다.<br>듣도 못한 사람의 명단에는 중복되는 이름이 없으며, 보도 못한 사람의 명단도 마찬가지이다.<br><br>듣보잡의 수와 그 명단을 사전순으로 출력한다.<br><br>3 4
ohhenrie
charlie
baesangwook
obama
baesangwook
ohhenrie
clinton

복사<br><br>2
baesangwook
ohhenrie

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author5" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/author5" target="_blank">author5</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/136" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/136" target="_blank">해시를 사용한 집합과 맵</a>
<br><br>
<br>앞에 피카츄 문제랑 비슷
<br><br>import sys

def solution():
    N, M = map(int,sys.stdin.readline().rstrip().split())
    see_dict = {}
    result_list = []

    for _ in range(N):
        name = sys.stdin.readline().rstrip()
        see_dict[name] = 1

    for _ in range(M):
        qes = sys.stdin.readline().rstrip()
        if see_dict.get(qes) == 1:
            result_list.append(qes)

    result_list.sort()
    print(len(result_list))
    print("\n".join(result_list))

if __name__ == "__main__":
    solution()
복사<br><br>import sys
n, m = map(int, input().split())
nameList = sys.stdin.read().splitlines()
hearset = set(nameList[:n])
seeset = set(nameList[n:])
ret = list(hearset &amp; seeset)
ret.sort()
print(len(ret))
for i in ret:
    print(i)
복사<br>
<br>교집합 기호 그냥 사용하는 방법도 있네.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/듣보잡.html</link><guid isPermaLink="false">1. Study/Coding Test/듣보잡.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[랜선 자르기]]></title><description><![CDATA[ 
 <br><br>ID: 1654<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1654" target="_blank">https://www.acmicpc.net/problem/1654</a><br>
난이도: 실버 2<br>
다시풀기: Yes<br>
분류: 매개 변수 탐색, 이분탐색<br>
생성 일시: 2023년 4월 27일 오후 2:15<br><br><br><br><br>집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이&nbsp;캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.<br>이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는&nbsp;버려야 한다. (이미 자른 랜선은 붙일 수 없다.)<br>편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 2^31-1보다 작거나 같은 자연수이다.<br><br>첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.<br><br>4 11
802
743
457
539

복사<br><br>200

복사<br><br>802cm 랜선에서 4개, 743cm 랜선에서 3개, 457cm 랜선에서 2개, 539cm 랜선에서 2개를 잘라내 모두 11개를 만들 수 있다.<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/plzrun" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/plzrun" target="_blank">plzrun</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/skydreamer21" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/skydreamer21" target="_blank">skydreamer21</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/twicedtna" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/twicedtna" target="_blank">twicedtna</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/helloworld123" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/helloworld123" target="_blank">helloworld123</a>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/iriszero" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/iriszero" target="_blank">iriszero</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/12" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/12" target="_blank">이분 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/170" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/170" target="_blank">매개 변수 탐색</a>
<br><br>복사<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/랜선-자르기.html</link><guid isPermaLink="false">1. Study/Coding Test/랜선 자르기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[로프]]></title><description><![CDATA[ 
 <br><br>ID: 2217<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/2217" target="_blank">https://www.acmicpc.net/problem/2217</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 그리디 알고리즘, 수학, 정렬<br>
생성 일시: 2023년 8월 7일 오후 11:25<br><br>
💡 2217-1 파일 계속 틀려서… 딴 코드 참고한건데.<br><br><br><br><br>N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.<br>하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.<br>각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.<br><br>첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.<br><br>첫째 줄에 답을 출력한다.<br><br>2
10
15

복사<br><br>20

복사<br><br>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/bububu111" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/bububu111" target="_blank">bububu111</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/kdk8361" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/kdk8361" target="_blank">kdk8361</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/roy752" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/roy752" target="_blank">roy752</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><br>
<br>받아서
<br>sort해서
<br>자기보다 큰 rope 다 사용하는 걸로 해서 값 계산해서
<br>max값 찾아서
<br>근데 시간이 좀 김…
<br>복사<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/로프.html</link><guid isPermaLink="false">1. Study/Coding Test/로프.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[마인크래프트]]></title><description><![CDATA[ 
 <br><br>ID: 18111<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/18111" target="_blank">https://www.acmicpc.net/problem/18111</a><br>
난이도: 실버 2<br>
다시풀기: Yes<br>
분류: 구현, 브루트포스 알고리즘<br>
생성 일시: 2023년 7월 24일 오후 3:18<br><br><br><br><br>팀 레드시프트는&nbsp;대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 ×&nbsp;1 ×&nbsp;1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.<br>목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’&nbsp;작업을 해야 한다.<br>lvalue는 세로&nbsp;N, 가로&nbsp;M&nbsp;크기의 집터를 골랐다. 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 우리는 다음과 같은 두 종류의 작업을 할 수 있다.<br>
<br>좌표 (i,&nbsp;j)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.
<br>인벤토리에서 블록 하나를 꺼내어 좌표 (i,&nbsp;j)의 가장 위에 있는 블록 위에 놓는다.
<br>1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다. ‘땅 고르기’&nbsp;작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.<br>단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다. 또한, 작업을 시작할 때 인벤토리에는&nbsp;B개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.<br><br>첫째 줄에&nbsp;N, M,&nbsp;B가 주어진다. (1&nbsp;≤&nbsp;M,&nbsp;N&nbsp;≤ 500, 0 ≤&nbsp;B&nbsp;≤&nbsp;6.4 × 107)<br>둘째 줄부터&nbsp;N개의 줄에 각각&nbsp;M개의 정수로 땅의 높이가 주어진다. (i&nbsp;+ 2)번째 줄의&nbsp;(j&nbsp;+ 1)번째 수는 좌표 (i,&nbsp;j)에서의 땅의 높이를 나타낸다. 땅의 높이는 256보다 작거나 같은 자연수 또는 0이다.<br><br>첫째 줄에 땅을 고르는 데 걸리는 시간과 땅의 높이를 출력하시오. 답이 여러 개 있다면 그중에서 땅의 높이가 가장 높은 것을 출력하시오.<br><br>3 4 99
0 0 0 0
0 0 0 0
0 0 0 1

복사<br><br>2 0

복사<br>맨 오른쪽 아래의 블록을 제거하면 모두 높이가 0으로 고른 상태가 된다. 따라서 블럭을 한 번 제거하는 시간 2초가 소요된다.<br><br>3 4 1
64 64 64 64
64 64 64 64
64 64 64 63

복사<br><br>1 64

복사<br><a rel="noopener" class="external-link" href="https://upload.acmicpc.net/50e6d9c5-2294-4bb5-826b-bb0fd3bc67f7/-/preview/" target="_blank">https://upload.acmicpc.net/50e6d9c5-2294-4bb5-826b-bb0fd3bc67f7/-/preview/</a><br>인벤토리에 블록이 하나 있기 때문에, 맨 오른쪽 아래에 블록을 하나 채우면 된다.<br><br>3 4 0
64 64 64 64
64 64 64 64
64 64 64 63

복사<br><br>22 63

복사<br>인벤토리가 비어 있기 때문에, 맨 오른쪽 아래를 제외한 모든 좌표에서 블록을 하나씩 제거해야 한다.<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/5" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/5" target="_blank">University</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/83" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/83" target="_blank">서강대학교</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/693" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/693" target="_blank">2019 Sogang Programming Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/2128" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/2128" target="_blank">Champion</a>&nbsp;B번<br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/hp3265" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/hp3265" target="_blank">hp3265</a>
<br>문제를 검수한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/shiftpsh" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/shiftpsh" target="_blank">shiftpsh</a>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/lvalue" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/lvalue" target="_blank">lvalue</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>복사<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/마인크래프트.html</link><guid isPermaLink="false">1. Study/Coding Test/마인크래프트.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[바이러스]]></title><description><![CDATA[ 
 <br><br>ID: 2606<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/2606" target="_blank">https://www.acmicpc.net/problem/2606</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
분류: 그래프 이론, 그래프 탐색, 깊이 우선 탐색, 너비 우선 탐색<br>
생성 일시: 2023년 8월 19일 오후 7:24<br><br><br><br><br>신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.<br>예를 들어 7대의 컴퓨터가 &lt;그림 1&gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.<br><img alt="https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png" src="https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png" referrerpolicy="no-referrer"><br>어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하인 양의 정수이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.<br><br>1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.<br><br>7
6
1 2
2 3
1 5
5 2
5 6
4 7

복사<br><br>4

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/55" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/55" target="_blank">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/57" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/57" target="_blank">한국정보올림피아드시․도지역본선</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/74" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/74" target="_blank">지역본선 2004</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/379" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/379" target="_blank">초등부</a>&nbsp;3번<br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/chansol" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/chansol" target="_blank">chansol</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/znxkqkfpdyalgnfl" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/znxkqkfpdyalgnfl" target="_blank">znxkqkfpdyalgnfl</a>
<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jsa3824" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jsa3824" target="_blank">jsa3824</a>
<br><br>
<br>우왕 그래프다…
<br>그래프 공부….
<br>복사<br><br>import sys

def get_input(num):
    matrix = [[0] * num for _ in range(num)]
    N = int(sys.stdin.readline().rstrip())
    for _ in range(N):
        i,j = map(int, sys.stdin.readline().split())
        matrix[i-1][j-1] = 1
        matrix[j-1][i-1] = 1
    return matrix

def check_virus(G, num):
    for i in range(len(G[num])):
        if G[num][i] == 1:
            if computer[i] != 1:
                computer[i] = 1
                check_virus(G, i)
    return None

num = int(sys.stdin.readline().rstrip())
computer = [0]*num
computer[0] = 1
check_virus(get_input(num),0)
print(sum(computer)-1)
복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/바이러스.html</link><guid isPermaLink="false">1. Study/Coding Test/바이러스.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate><enclosure url="https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[보물]]></title><description><![CDATA[ 
 <br><br>ID: 1026<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1026" target="_blank">https://www.acmicpc.net/problem/1026</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 그리디 알고리즘, 수학, 정렬<br>
생성 일시: 2023년 4월 20일 오전 11:53<br><br><br><br><br>옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.<br>길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.<br>S = A[0] × B[0] + ... + A[N-1] × B[N-1]<br>S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.<br>S의 최솟값을 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에 N이 주어진다. 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.<br><br>첫째 줄에 S의 최솟값을 출력한다.<br><br>5
1 1 1 6 0
2 7 8 3 1

복사<br><br>18

복사<br><br>3
1 1 3
10 30 20

복사<br><br>80

복사<br><br>9
5 15 100 31 39 0 0 3 26
11 12 13 2 3 4 5 9 1

복사<br><br>528

복사<br><br>예제 1의 경우 A를 {1, 1, 0, 1, 6}과 같이 재배열하면 된다.<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><br>
<br>
B를 {val: [index]}해서 내림차순 정렬.

<br>
오름차순 정렬된 a와 매칭

<br>
A[0]가지고 B한바퀴 돌려서, 제일 큰수 index에 넣고.

<br>
그 다음으로 큰수 넣고

<br>
다시다시

<br>
받아서, a값 정렬해서 a값 하나 잡고, 가장 큰 수장 곱해서 더하고, 다음 a값과 그다음 큰 수를 곱해서 더하고 반복.

<br><br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())
    
    A = list(map(int, sys.stdin.readline().rstrip().split(" ")))
    B = list(map(int, sys.stdin.readline().rstrip().split(" ")))
    A.sort()

    result = 0

    for i in A:
        max = 0
        idx = -1
        for j in range(len(B)):
            if B[j] &gt; 100:
                continue
            if B[j] &gt;= max:
                max = B[j]
                idx = j
        result += (max*i)
        B[idx] = 101
    print(result)

if __name__ == "__main__":
   solution()
복사<br>
<br>예제는 다 되는데,,, 반례를 찾아야함.
<br>참조값이 없거나 부적적한 값…일때.
<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/보물.html</link><guid isPermaLink="false">1. Study/Coding Test/보물.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[본]]></title><description><![CDATA[ 
 <br><br>ID: 1676<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1676" target="_blank">https://www.acmicpc.net/problem/1676</a><br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 수학<br>
생성 일시: 2023년 7월 21일 오후 8:44<br><br><br><br><br>N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500)<br><br>첫째 줄에 구한 0의 개수를 출력한다.<br><br>10

복사<br><br>2

복사<br><br>3

복사<br><br>0

복사<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/111111111111" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/111111111111" target="_blank">111111111111</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/his130" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/his130" target="_blank">his130</a>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author6" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/author6" target="_blank">author6</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><br>
<br>
팩토리얼..

<br>
0이 나오려면, 2와5

<br>
2는 항상 5전에 몇번 나올것같음 2의 배수가 훨씬 많으니까, 5의 배수의 개수로 판단.

<br>
앗,,! 5의 제곱,,,,

<br>5, 25,125


<br><br>
<br>0은 0임…
<br>import sys

num = int(sys.stdin.readline())

if num == 0:
    result = 1
else:
    result = 0
    while num &gt; 0:
        num = num // 5
        result += num

if __name__ == "__main__":
    print(result)
복사<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/본.html</link><guid isPermaLink="false">1. Study/Coding Test/본.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[비밀번호 만들기]]></title><description><![CDATA[ 
 <br><br>ID: 17218<br>
난이도: 골드2<br>
다시풀기: Yes<br>
생성 일시: 2023년 8월 12일 오후 7:08<br><br>
💡 Lcs 알고리즘<br><br><br><br><br>최근 들어 개인정보 유출에 대한 뉴스를 많이 본&nbsp;수형이는 한 사이트의 비밀번호가 유출&nbsp;되더라도 다른 사이트에서 똑같은 비밀번호로&nbsp;접속할 수 없도록&nbsp;사이트마다 비밀번호를 다르게 설정하기로 다짐했다. 많이 고민한 결과 수형이는 눈을 감고 키보드를 막 쳐서 나온 두 문자열에서 공통으로 존재하는 가장 긴 부분 문자열을 비밀번호로 하기로 하였다. 수형이가 눈을 감고 만든 두 문자열이 주어졌을 때 비밀번호를 만드는 프로그램을 만들어보자.<br><br>첫째 줄과 둘째 줄에 수형이가 눈을 감고 만든 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 길이는 최대&nbsp;40자이다. 빈 문자열은 주어지지 않는다.&nbsp;가장 긴 부분 문자열은 반드시 하나만 존재한다.<br><br>첫 번째 줄에 입력으로 주어진 두 문자열로 만든&nbsp;비밀번호를 출력한다.<br><br>AUTABBEHNSA
BCUAMEFKAJNA
복사<br><br>UAENA

복사<br>AUTABBEHNSA<br>BCUAMEFKAJNA<br><br>SETAPPLE
EATMANY

복사<br><br>ETA

복사<br>SETAPPLE<br>EATMANY<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/5" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/5" target="_blank">University</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/418" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/418" target="_blank">한양대학교 ERICA 캠퍼스</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/791" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/791" target="_blank">2019 HEPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/2032" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/2032" target="_blank">MAVEN League</a>&nbsp;E번<br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/TheKinGoD" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/TheKinGoD" target="_blank">TheKinGoD</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><br>
<br>
f(x, start(, end)) ⇒ start~end 사이에 가장 앞에 있는 x의 위치

<br>
result =

<br>
변수 재사용.

<br>flag → start나 end


<br>
그리고 flag로 한번 사용되었던 애로부터 시작하는 건 안써도 됨.

<br>
뒤에서부터 한다고 생각해볼까.

<br>
result = “”

<br>
word1의 첫 알파벳을 word2[0:]에서 찾음

<br>여러개일 수 있으니까, 찾을 때마다 옆으로 넘김


<br>
word1의 두번째 알파벳을 word2[flag:]에서 찾음

<br>
반복

<br>
뒤에서 부터 해보면

<br>
f(word[-1], 0) = word1의 마지막 알파벳을 word2 (뒤에서부터)찾음

<br>
word1의 -2 위치 알파벳을 word2[:flag]찾음

<br>f(word[-2]) =


<br>복사<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/비밀번호-만들기.html</link><guid isPermaLink="false">1. Study/Coding Test/비밀번호 만들기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[색종이]]></title><description><![CDATA[ 
 <br><br>ID: 2563<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/2563" target="_blank">https://www.acmicpc.net/problem/2563</a><br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 구현<br>
생성 일시: 2023년 4월 20일 오전 10:38<br><br><br><br><br>가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.<br><a rel="noopener" class="external-link" href="https://upload.acmicpc.net/6000c956-1b07-4913-83c3-72eda18fa1d1/-/preview/" target="_blank">https://upload.acmicpc.net/6000c956-1b07-4913-83c3-72eda18fa1d1/-/preview/</a><br>예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다.<br><br>첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다<br><br>첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다.<br><br>3
3 7
15 7
5 2

복사<br><br>260
복사<br><br>
<br>
그냥 2d list만들어서 색칠하면 안되나ㅋㅋㅋㅋ

<br>
아니면, N*100 - (겹치는 부분.)

<br>복사<br><br>
<br>list 곱하기

<br>곱하기 연산은 리스트를 곱한 숫자만큼 반복시켜서 새로운 리스트를 생성합니다.
<br>곱하기 연산자는 특정 값으로 전체를 채우고 싶을 때 사용할 수 있습니다.


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/색종이.html</link><guid isPermaLink="false">1. Study/Coding Test/색종이.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[설탕 배달]]></title><description><![CDATA[ 
 <br><br>ID: 2839<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/2839" target="_blank">https://www.acmicpc.net/problem/2839</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 그리디 알고리즘, 다이나믹 프로그래밍, 수학<br>
생성 일시: 2023년 4월 16일 오후 11:12<br><br><br><br><br>상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.<br>상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.<br>상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)<br><br>상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.<br><br>18

복사<br><br>4

복사<br><br>4

복사<br><br>-1

복사<br><br>6

복사<br><br>2

복사<br><br>9

복사<br><br>3

복사<br><br>11

복사<br><br>3

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/45" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/45" target="_blank">Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/17" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/17" target="_blank">Croatian Open Competition in Informatics</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/20" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/20" target="_blank">COCI 2010/2011</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/81" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/81" target="_blank">Contest #7</a>&nbsp;1번<br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/hyunynim" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/hyunynim" target="_blank">hyunynim</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/25" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/25" target="_blank">다이나믹 프로그래밍</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><br>
<br>N = 3a+5b
<br><br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    
    result = 0
    flag = 0
    
    while True:
        if N % 3 == 0:
            flag = N
        
        if N &gt;= 5:
            N -= 5
            result += 1
        else:
            if flag == 0:
                result = -1
            else:
                result -= (flag - N)//5
                result += flag//3
            break
            
    print(result)    

if __name__ == "__main__":
    solution()
복사<br>
<br>
5로만 계속 빼면서

<br>
그 순간 순간 마다 3으로 나눠 떨어지는 시점을 flag에 저장해 놓음(제일 작은 수로)

<br>
만약에 5로 계속 빼다가 딱 맞게 떨어지지 않으면,

<br>
flag로 돌아가서 (result에서 그만큼 뺌)

<br>
3kg짜리 배달하는 만큼 더해서 print.

<br>
틀림: 5로만 구성된 경우에 문제가 생김…

<br>import sys

def solution():
    # 첫줄 input값 받기
    N = int(sys.stdin.readline().rstrip())
    
    result = 0
    flag = 0
    
    while True:
        if N % 3 == 0:
            flag = N
        
        if N &gt;= 5:
            N -= 5
            result += 1
        elif N == 0:
            break
        else:
            if flag == 0:
                result = -1
            else:
                result -= (flag - N)//5
                result += flag//3
            break
            
    print(result)    

if __name__ == "__main__":
    solution()
복사<br><br>
<br>아, 5로 나누어떨어질 때까지 3씩 빼주면, flag를 세울 필요가 없구나.
<br>훨씬 간단하네.
<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/설탕-배달.html</link><guid isPermaLink="false">1. Study/Coding Test/설탕 배달.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[소수 구하기]]></title><description><![CDATA[ 
 <br><br>ID: 1929<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1929" target="_blank">https://www.acmicpc.net/problem/1929</a><br>
난이도: 실버 3<br>
다시풀기: Yes<br>
분류: 소수 판정, 수학, 에라토스테네스의 체, 정수론<br>
생성 일시: 2023년 4월 27일 오후 12:31<br><br>
<br>홀수리스트는 문제가 생김. → 왜 생기는가.
<br>시간을 줄이는 방법. 지금 입력에 따라 리스트 최대 길이 제한을 두는 것까지함
<br><br><br><br>M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000)&nbsp;M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.<br><br>한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.<br><br>3 16

복사<br><br>3
5
7
11
13

복사<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jinjean0123" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jinjean0123" target="_blank">jinjean0123</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/yongjun042" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/yongjun042" target="_blank">yongjun042</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/95" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/95" target="_blank">정수론</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/9" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/9" target="_blank">소수 판정</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/67" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/67" target="_blank">에라토스테네스의 체</a>
<br><br>
<br>이 문제의 채점 우선 순위는 2이다.
<br><br>
<br>
그냥 소수 다 구해 놓고 범위에 맞는 것만 출력…

<br>
다 구하기에는 좀 많음… 줄일 수 있을 듯..

<br>
범위의 수가, 10이면, 2,3,4,5의 배수는 무조건 있을 듯.(범위의 반까지.)

<br>
큰수의 절반이 제일 큰, 소수 후보겠지.

<br><br>import sys

def solution():
    M, N = map(int,sys.stdin.readline().rstrip().split())
    lst = [True] * (1000000 + 1)
    lst[0] = 0
    lst[1] = 0
    
    for i in range(2, int(1000000**(0.5)) +1):
        if lst[i]:
            for j in range(i*2,len(lst),i):
                lst[j] = False
    
    for n in range(M,N+1):
        if lst[n]:
            print(n)
        
if __name__ == "__main__":
    solution()
복사<br>
<br>
앞에는 1이 true라 소수 취급 되어서 틀림.

<br>
홀수만 포함된 list를 만들 수는 없나?

<br>
2의 배수는 미리 빠지는 list로 만들기

<br><br>import sys

def solution():
    M, N = map(int,sys.stdin.readline().rstrip().split())
    lst = ([False]+[True]) * (((N+1)//2)+1)
    lst[1] = False

    for i in range(3, int(N**(0.5)) +1):
        if lst[i]:
            for j in range(i*3,N+1,i*2):
                lst[j] = False
    
    for n in range(M,N+1):
        if lst[n]:
            print(n)

if __name__ == "__main__":
    solution()ㅇ
복사<br>
<br>ㅇ
<br>으악 2를 false로 처리해버렸네….
<br><br>
<br>에라토스테네스의 체
  <a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4" rel="noopener" class="external-link" href="https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4" target="_blank">에라토스테네스의 체</a><br>

<br>0,1 보다 True False가 빠르네?
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/소수-구하기.html</link><guid isPermaLink="false">1. Study/Coding Test/소수 구하기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[수 찾기]]></title><description><![CDATA[ 
 <br><br>ID: 1920<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1920" target="_blank">https://www.acmicpc.net/problem/1920</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 이분탐색, 자료구조, 정렬<br>
생성 일시: 2023년 4월 17일 오후 7:36<br><br>binary search 제대로 구현해보<br><br><br><br>N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.<br><br>첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231&nbsp;보다 크거나 같고 231보다 작다.<br><br>M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.<br><br>5
4 1 5 2 3
5
1 3 7 9 5

복사<br><br>1
1
0
0
1

복사<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/BaaaaaaaaaaarkingDog" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/BaaaaaaaaaaarkingDog" target="_blank">BaaaaaaaaaaarkingDog</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/bupjae" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/bupjae" target="_blank">bupjae</a>
<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/tncks0121" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/tncks0121" target="_blank">tncks0121</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/12" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/12" target="_blank">이분 탐색</a>
<br><br>
<br>입력받으면서 정렬.

<br>정수의 범위(-2^31≤ n &lt;2^31)가 정수의 개수(100000)보다 많이 크기때문에, indexing방식으로 list에 삽입 하는 것은 비효율 적이다.
<br>다 받아서 병합정렬하자.


<br>M도 입력 받으면서 정렬
<br>다음 탐색에서는 현재 M보다 큰 N에서부터 탐색시작하면 됨.
<br><br>import sys

def merge_sort(lst):

    if len(lst) == 1:
        return lst
    else:
        mid = (len(lst) // 2)
        a_lst = merge_sort(lst[:mid])
        b_lst = merge_sort(lst[mid:])
        merge_lst = []

        while True:
            if len(a_lst) == 0:
                merge_lst += b_lst
                break
            elif len(b_lst) ==0:
                merge_lst += a_lst
                break
            
            else:
                if a_lst[0] &lt; b_lst[0]:
                    merge_lst.append(a_lst.pop(0))
                else:
                    merge_lst.append(b_lst.pop(0))
        
        return merge_lst

def searching(base, check, M):
    i = 0
    while i != M:
        for j in range(len(base)):
            if check[i] == base[j]:
                base = base[j+1:]
                print(1)
                break
            elif check[i] &lt; base[j]:
                base = base[j-1:]
                print(0)
                break
        if len(base) == 0:
            for i in range(M-i-1):
                print(0)
            break
        i+=1
        

def solution():
    N = int(sys.stdin.readline().rstrip())
    N_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split())))
    M = int(sys.stdin.readline().rstrip())
    M_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split())))

    searching(N_lst, M_lst, M)

if __name__ == "__main__":
    solution()
복사<br>
<br>바보다… 출력하는 순서가… 이게 아니잖아…ㅠ
<br>출력 순서를 정렬해 버림. 그럼 후자를 정렬안하고 하는 방법을 찾아야하는데, 그런 바이너리 서치가 최선이네.
<br><br>import sys

def merge_sort(lst):

    if len(lst) == 1:
        return lst
    else:
        mid = (len(lst) // 2)
        a_lst = merge_sort(lst[:mid])
        b_lst = merge_sort(lst[mid:])
        merge_lst = []

        while True:
            if len(a_lst) == 0:
                merge_lst += b_lst
                break
            elif len(b_lst) ==0:
                merge_lst += a_lst
                break
            
            else:
                if a_lst[0] &lt; b_lst[0]:
                    merge_lst.append(a_lst.pop(0))
                else:
                    merge_lst.append(b_lst.pop(0))
        
        return merge_lst

def searching(base, check):
    start = 0
    end = len(base)-1
    while True:
        mid = start + (end-start)//2

        if end &lt; start:
            print(0)
            break

        if check == base[mid]:
            print(1)
            break        
        elif check &lt; base[mid]:
            end = mid
        else:
            start = mid+1
        

            
def solution():
    N = int(sys.stdin.readline().rstrip())
    N_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split())))
    M = int(sys.stdin.readline().rstrip())
    M_lst = list(map(int, sys.stdin.readline().rstrip().split()))

    for i in M_lst:
        searching(N_lst, i)

if __name__ == "__main__":
    solution()
복사<br>
<br>break point가 잘못된듯 합니다…
<br><br>import sys

def merge_sort(lst):

    if len(lst) == 1:
        return lst
    else:
        mid = (len(lst) // 2)
        a_lst = merge_sort(lst[:mid])
        b_lst = merge_sort(lst[mid:])
        merge_lst = []

        while True:
            if len(a_lst) == 0:
                merge_lst += b_lst
                break
            elif len(b_lst) ==0:
                merge_lst += a_lst
                break
            
            else:
                if a_lst[0] &lt; b_lst[0]:
                    merge_lst.append(a_lst.pop(0))
                else:
                    merge_lst.append(b_lst.pop(0))
        
        return merge_lst

def searching(base, check):
    start = 0
    end = len(base)-1
    while True:
        mid = start + (end-start)//2

        if check == base[mid]:
            print(1)
            break    

        if end &lt;= start:
            print(0)
            break

        if check &lt; base[mid]:
            end = mid
        else:
            start = mid+1
        
            
def solution():
    N = int(sys.stdin.readline().rstrip())
    N_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split())))
    M = int(sys.stdin.readline().rstrip())
    M_lst = list(map(int, sys.stdin.readline().rstrip().split()))

    for i in M_lst:
        searching(N_lst, i)

if __name__ == "__main__":
    solution()
복사<br><br>input()
a = set(input().split())
input()
answer = '\n'.join('1' if x in a else '0' for x in input().split())
print(answer, end='')
복사<br>
<br>그냥 in 써도 돼는거 실화냐?
<br>하….
<br>앞으로는

<br>다 구현
<br>파이썬 기능이용해서 간단하게 구현 

  둘 다 해보자.<br>

<br><br>
<br>입력받는 string list를 바로 int list로 바꾸는 방법
<br>N_lst = list(map(int, sys.stdin.readline().rstrip().split()))
복사<br>
<br>
// : 몫 → 내림

<br>
binary search 할 때

<br>base list를 바꾸는 게 아니라, start, end index로 다뤄줘야해.
<br>end index는 그 끝까지 도달할 경우를 고려해서 len(list)“-1”로 해야함
<br>mid 값은 그냥 나누면 끝이 아니라 그값은 start에 더해줘야해.


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/수-찾기.html</link><guid isPermaLink="false">1. Study/Coding Test/수 찾기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[수들의 합2]]></title><description><![CDATA[ 
 <br><br>ID: 2003<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/2003" target="_blank">https://www.acmicpc.net/problem/2003</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 누적 합, 두 포인터, 브루트포스 알고리즘<br>
생성 일시: 2023년 8월 5일 오전 3:09<br><br><br><br><br>N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i] + A[i+1] + … + A[j-1] + A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N(1 ≤ N ≤ 10,000), M(1 ≤ M ≤ 300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.<br><br>첫째 줄에 경우의 수를 출력한다.<br><br>4 2
1 1 1 1

복사<br><br>3

복사<br><br>10 5
1 2 3 4 2 5 3 1 1 2

복사<br><br>3

복사<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/isku" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/isku" target="_blank">isku</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/vvipconcert" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/vvipconcert" target="_blank">vvipconcert</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/139" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/139" target="_blank">누적 합</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/80" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/80" target="_blank">두 포인터</a>
<br><br>
<br>test_cast list를 두고 adding case를 다 저장하면서 진행
<br>새 숫자가 나오면 그 숫자가 i가 되는 case를 list에 추가(현재 합 0)
<br>존재하는 case에 새 숫자를 다 더함.
<br>M과의 비교를 통해 test case list 처리
<br>import sys

def sum_of_num():
    N, M = map(int, sys.stdin.readline().split())
    sequence = sys.stdin.readline().rstrip().split()
    test_case = []
    result_case = 0

    for num in sequence:
        num = int(num)
        if num &gt; M:
            test_case.clear()
            continue

        test_case.append(0)

        cut = 0
        for idx in reversed(range(len(test_case))):
            test_case[idx] += num
            if test_case[idx] == M:
                result_case += 1
                cut = idx + 1
            elif test_case[idx] &gt; M:
                cut = idx + 1

        test_case = test_case[cut:]

    print(result_case)

if __name__ == "__main__":
    sum_of_num()
복사<br>
<br>
근데 시간 초과…

<br>
그려면 한 숫자에 고정하고서(그러니까 start point를 고정하고서) 찾고, 다음 start point로 넘어가는 식으로..

<br><br>복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/수들의-합2.html</link><guid isPermaLink="false">1. Study/Coding Test/수들의 합2.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[숫자 카드 2]]></title><description><![CDATA[ 
 <br><br>ID: 10816<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/10816" target="_blank">https://www.acmicpc.net/problem/10816</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 이분탐색, 자료구조, 정렬, 해시를 사용한 집합과 맵<br>
생성 일시: 2023년 4월 20일 오후 9:23<br><br><br><br><br>숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이&nbsp;주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.<br>셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.<br><br>첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.<br><br>10
6 3 2 10 10 10 -10 -10 7 3
8
10 9 -5 2 3 4 5 -10

복사<br><br>3 0 0 1 2 0 0 2

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/cko301" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/cko301" target="_blank">cko301</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/mwy3055" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/mwy3055" target="_blank">mwy3055</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/wkd48632" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/wkd48632" target="_blank">wkd48632</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/emppu" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/emppu" target="_blank">emppu</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/97" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/97" target="_blank">정렬</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/12" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/12" target="_blank">이분 탐색</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/136" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/136" target="_blank">해시를 사용한 집합과 맵</a>
<br><br>
<br>max 값을 찾아서, 나머지를 index로 하면, list 크기 줄일 수 있어서 좋은데,,,
<br>이게, 음수가 있어서 헷갈리네.
<br>그러면 나머지 구하고 양수에는 +max 한 index에 저장하기로 하자.
<br>그런데 결과 담긴 list를 한바퀴 돌리는게 아니라, 그냥 접근하는 거니까. 굳이 크기를 줄일 필요 없지 않나?
<br>
<br>import sys

def solution():
    lst = [0]*20000000
    N = int(sys.stdin.readline().rstrip())
    N_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    M = int(sys.stdin.readline().rstrip())
    M_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    i,j = 0,0
    result = []
    
    while i &lt; N:
        num = N_lst[i]
        lst[num+10000000-1] += 1
        i+=1
    

    while j &lt; M:
        num = M_lst[j]
        result.append(str(lst[num+10000000-1]))
        j+=1

    print(" ".join(result))

if __name__ == "__main__":
    solution()
복사<br>
<br>시간 너무 많이 걸리는듯 합니다…
<br>한번에 받겠다, max min 찾아서 하지 뭐.
<br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    N_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    M = int(sys.stdin.readline().rstrip())
    M_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    i,j = 0,0
    result = []
    maximum = max(N_lst)
    minimum = min(N_lst)
    length = maximum - minimum
    lst = [0]*length
    plus = length//2

    while i &lt; N:
        num = N_lst[i]
        lst[num+plus-1] += 1
        i+=1
    

    while j &lt; M:
        num = M_lst[j]
        result.append(str(lst[num+plus-1]))
        j+=1

    print(" ".join(result))

if __name__ == "__main__":
    solution()
복사<br>ㅇ<br>
<br>신기하게 이러니까 양끝 값이 이상해졌어…! 짱신기… 왜지?
<br>생각해보니까, 반으로 하면, index가 음수인 경우가 생겨서 이상해지겠다…
<br>rㅡ리고 length는 항상 +1 해주기
<br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    N_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    M = int(sys.stdin.readline().rstrip())
    M_lst = list(map(int, sys.stdin.readline().rstrip().split()))
    i,j = 0,0
    result = []
    maximum = max(N_lst)**2
    minimum = min(N_lst)**2
    half = int(max(maximum,minimum)**1/2)
    length = half * 2 + 1
    lst = [0]*length

    while i &lt; N:
        num = N_lst[i]
        lst[num+half-1] += 1
        i+=1
    

    while j &lt; M:
        num = M_lst[j]
        result.append(str(lst[num+half-1]))
        j+=1

    print(" ".join(result))

if __name__ == "__main__":
    solution()뮤ㅇ

복사<br>
<br>ㅇ
<br>abs로 안하려고 제곱했더니, 메모리 초과ㅋㅋㅋㅋㅋ
<br><br>
<br>join 할거면 str으로 저장해줘야된다고!!!!!!
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/숫자-카드-2.html</link><guid isPermaLink="false">1. Study/Coding Test/숫자 카드 2.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[스위치 켜고 끄기]]></title><description><![CDATA[ 
 <br><br>ID: 1244<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1244" target="_blank">https://www.acmicpc.net/problem/1244</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
생성 일시: 2023년 5월 3일 오전 9:16<br><br><br><br><br>1부터 연속적으로 번호가 붙어있는 스위치들이 있다. 스위치는 켜져 있거나 꺼져있는 상태이다. &lt;그림 1&gt;에 스위치 8개의 상태가 표시되어 있다. ‘1’은 스위치가 켜져 있음을, ‘0’은 꺼져 있음을 나타낸다. 그리고 학생 몇 명을 뽑아서, 학생들에게 1 이상이고 스위치 개수 이하인 자연수를 하나씩 나누어주었다. 학생들은 자신의 성별과 받은 수에 따라 아래와 같은 방식으로 스위치를 조작하게 된다.<br>남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다. &lt;그림 1&gt;과 같은 상태에서 남학생이 3을 받았다면, 이 학생은 &lt;그림 2&gt;와 같이 3번, 6번 스위치의 상태를 바꾼다.<br>여학생은 자기가 받은 수와 같은 번호가 붙은 스위치를 중심으로 좌우가 대칭이면서 가장 많은 스위치를 포함하는 구간을 찾아서, 그 구간에 속한 스위치의 상태를 모두 바꾼다. 이때 구간에 속한 스위치 개수는 항상 홀수가 된다.<br><br>&lt;그림 1&gt;<br>예를 들어 &lt;그림 2&gt;에서 여학생이 3을 받았다면, 3번 스위치를 중심으로 2번, 4번 스위치의 상태가 같고 1번, 5번 스위치의 상태가 같으므로, &lt;그림 3&gt;과 같이 1번부터 5번까지 스위치의 상태를 모두 바꾼다. 만약 &lt;그림 2&gt;에서 여학생이 4를 받았다면, 3번, 5번 스위치의 상태가 서로 다르므로 4번 스위치의 상태만 바꾼다.<br><br>&lt;그림 2&gt;<br><br>&lt;그림 3&gt;<br>입력으로 스위치들의 처음 상태가 주어지고, 각 학생의 성별과 받은 수가 주어진다. 학생들은 입력되는 순서대로 자기의 성별과 받은 수에 따라 스위치의 상태를 바꾸었을 때, 스위치들의 마지막 상태를 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에는 스위치 개수가 주어진다. 스위치 개수는 100 이하인 양의 정수이다. 둘째 줄에는 각 스위치의 상태가 주어진다. 켜져 있으면 1, 꺼져있으면 0이라고 표시하고 사이에 빈칸이 하나씩 있다. 셋째 줄에는 학생수가 주어진다. 학생수는 100 이하인 양의 정수이다. 넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수가 주어진다. 남학생은 1로, 여학생은 2로 표시하고, 학생이 받은 수는 스위치 개수 이하인 양의 정수이다. 학생의 성별과 받은 수 사이에 빈칸이 하나씩 있다.<br><br>스위치의 상태를 1번 스위치에서 시작하여 마지막 스위치까지 한 줄에 20개씩 출력한다. 예를 들어 21번 스위치가 있다면 이 스위치의 상태는 둘째 줄 맨 앞에 출력한다. 켜진 스위치는 1, 꺼진 스위치는 0으로 표시하고, 스위치 상태 사이에 빈칸을 하나씩 둔다.<br><br>8
0 1 0 1 0 0 0 1
2
1 3
2 3

복사<br><br>1 0 0 0 1 1 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/2" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/2" target="_blank">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/55" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/55" target="_blank">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/78" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/78" target="_blank">KOI 2000</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/391" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/391" target="_blank">초등부</a>&nbsp;2번<br><br>
<br>출력 형식 때문에 6번째에 맞췄다…
<br>import sys

def solution():
    # 입력
    N = int(sys.stdin.readline().rstrip())
    switches = [*map(int, sys.stdin.readline().rstrip().split())]
    people = int(sys.stdin.readline().rstrip())
    cnt = 0

    #연산
    while cnt &lt; people:
        sex, num = map(int, sys.stdin.readline().rstrip().split())
        # 남
        if sex == 1:
            idx = num-1
            while idx &lt; len(switches):
                switches[idx] = switches[idx]*(-1) + 1
                idx += num
        # 여
        elif sex == 2:
            full_length = min(num, N-(num-1))
            idx = num-1
            switches[idx] = switches[idx]*(-1) + 1
            for i in range(1, full_length):
                if switches[idx+i] != switches[idx-i]:
                    break
                switches[idx+i] = switches[idx+i]*(-1) + 1
                switches[idx-i] = switches[idx-i]*(-1) + 1
        cnt +=1
    
    # 출력
    for j in range(0, N, 20):
        print(*switches[j:j+20*(j+1)])
    

if __name__ == "__main__":
    solution()
복사<br><br>
<br>
2) 한 줄의 여러 정수 입력받기 - 리스트로
li = [*map(int,input().split())]
복사

<br>input().split()은 사용자로부터 받은 입력을 공백을 구분자로 나누어 리스트로 바꾸는 기능입니다. 여기에 map함수를 통해, 각 원소를 int형으로 바꿔주게 됩니다. 즉, input().split()이 반환하는 건 리스트이고,&nbsp;map(int, 리스트)를 통해 리스트의 각 원소를 정수로 바꿔주는 것입니다. 앞에&nbsp;*(에스터리크)는&nbsp;unpacking기능으로,&nbsp;[*map객체]를 하면 map객체가 unpacking 되고, []에 의해 리스트화 됩니다. 즉, map에 의해 각 원소가 정수로 바뀐 것을 다시 리스트로 바꿔주는 것입니다
<br>출처: <a rel="noopener" class="external-link" href="https://bio-info.tistory.com/157" target="_blank">https://bio-info.tistory.com/157</a>


<br>
bitwise 연산
# 비트 연산자(Bitwise Operators)
a = 0b10101010
b = 0b01110011

print('a = ',  a, ":", bin(a))
print('b = ',  b, ":", bin(b))
print('a &amp; b = ',  a &amp; b, ":", bin(a &amp; b))
print('a | b = ',  a | b, ":", bin(a | b))
print('a ^ b = ',  a ^ b, ":", bin(a ^ b))
print('~a = ',  ~a, ":", bin(~a))

a = 0b1
print('a = ', a)
a = a &lt;&lt; 1    # * 2
print('a = ', a)
a = a &lt;&lt; 1    # * 2
print('a = ', a)
a = a &lt;&lt; 3    # * 2**3
print('a = ', a)

a = a &gt;&gt; 1    # / 2
print('a = ', a)
a = a &gt;&gt; 1    # / 2
print('a = ', a)
a = a &gt;&gt; 2    # / 2**2
print('a = ', a)

복사

<br>실행 결과
a =  170 : 0b10101010
b =  115 : 0b1110011
a &amp; b =  34 : 0b100010
a | b =  251 : 0b11111011
a ^ b =  217 : 0b11011001
~a =  -171 : -0b10101011

a =  1
a =  2
a =  4
a =  32

a =  16
a =  8
a = 2
복사



<br>
int()는 버림 연산

<br>
biswise 안 쓰고, 0,1 변환
lst[i]*(-1) + 1
복사

<br>
input으로 int list만들때,
switches = list(map(int, sys.stdin.readline().rstrip().split()))
switches = [*map(int, sys.stdin.readline().rstrip().split())]
복사

<br>둘 중 후자가 더 빠름


<br>
깔끔하게 출력하기

<br>문자열 만들어서 띄어쓰기 넣고 하는 것보다, 그냥 띄어쓰기면 이게 훨씬 깔끔.
<br>특정구간마다 줄바꿈이 필요하면 range step으로 설정해주기.

for j in range(0, len(switches), 20):
        print(*switches[j:j+20*(j+1)])
복사

]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/스위치-켜고-끄기.html</link><guid isPermaLink="false">1. Study/Coding Test/스위치 켜고 끄기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[영화감독 숌]]></title><description><![CDATA[ 
 <br><br>ID: 1436<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1436" target="_blank">https://www.acmicpc.net/problem/1436</a><br>
난이도: 실버 5<br>
다시풀기: Yes<br>
분류: 브루트포스 알고리즘<br>
생성 일시: 2023년 4월 11일 오후 2:21<br><br>“brute-force말고 최적화 해서 풀어보기”<br><br><br>666은 종말을 나타내는 수라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다. 하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.<br>종말의 수란 어떤 수에 6이 적어도 3개 이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 수는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 이다. 따라서, 숌은 첫 번째 영화의 제목은 "세상의 종말 666", 두 번째 영화의 제목은 "세상의 종말 1666"와 같이 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 수) 와 같다.<br>숌이 만든 N번째 영화의 제목에 들어간 수를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.<br><br>첫째 줄에 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.<br><br>첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.<br><br>2
복사<br><br>1666
복사<br><br>3
복사<br><br>2666
복사<br><br>6

복사<br><br>5666

복사<br><br>187

복사<br><br>66666

복사<br><br>500

복사<br><br>166699

복사<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/mwy3055" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/mwy3055" target="_blank">mwy3055</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>
<br>666을 숫자 6으로 치환해서,,,?
<br>그러면 진짜 그냥 6인데 그것도 666으로 변환시킬 우려가 생김.
<br>써보자

<br>0,1,2,3,4,5 (+) 666
<br>666 (+) 0,1,2,3,4,5
<br>6666
<br>7,8,9 (+) 666


<br>special 6
<br>
<br>6` == 666
<br>16` == 1000 +666 = 666+(n-1)*1000
<br>26` == 2000 + 666 = 666+(n-1)*1000
<br>36` == 3000 + 666 = 666+(n-1)*1000
<br>46` == 4000 + 666 = 666+(n-1)*1000
<br>56`== 5000 + 666 = 666+(n-1)*1000

<br>0≤(n-7)≤9


<br>6`0 == 66610 = 66610 + n-7
<br>6`1  == 66610 +1 = 66610 + n-7
<br>6`2  == 66610 +2 = 66610 + n-7
<br>6`3 == 66610+3 = 66610 + n-7
<br>6`4 == 66610+4 = 66610 + n-7
<br>6`5 == 66610+5 = 66610 + n-7
<br>6`6  == 66610+6 = 66610 + n-7
<br>6`7 == 66610+7 = 66610 + n-7
<br>6`8 == 66610+8 = 66610 + n-7
<br>6`9 == 66610+9 = 66610 + n-7
<br>106` == 10000 + 666
<br>116` == 11000 + 666
<br>126` == 12000 + 666
<br>136` == 13000 + 666
<br>146` == 14000 + 666
<br>156` == 15000 + 666
<br>16`0 == 666*10 + 10000
<br>16`1 == 666*10 + 10001
<br>16`2 == 666*10 + 10002
<br>16`3 == 666*10 + 10003
<br>
<br>6을 하나만 6으로 부풀리는 식으로 해보자.
<br>
<br>6` == 6
<br>16` == 10+6
<br>26` == 10
<br>36` == 3000 + 666 = 666+(n-1)*1000
<br>46` == 4000 + 666 = 666+(n-1)*1000
<br>56`== 5000 + 666 = 666+(n-1)*1000

<br>0≤(n-7)≤9


<br>6`0 == 66610 = 66610 + n-7
<br>6`1  == 66610 +1 = 66610 + n-7
<br>6`2  == 66610 +2 = 66610 + n-7
<br>6`3 == 66610+3 = 66610 + n-7
<br>6`4 == 66610+4 = 66610 + n-7
<br>6`5 == 66610+5 = 66610 + n-7
<br>6`6  == 66610+6 = 66610 + n-7
<br>6`7 == 66610+7 = 66610 + n-7
<br>6`8 == 66610+8 = 66610 + n-7
<br>6`9 == 66610+9 = 66610 + n-7
<br>106` == 10000 + 666
<br>116` == 11000 + 666
<br>126` == 12000 + 666
<br>136` == 13000 + 666
<br>146` == 14000 + 666
<br>156` == 15000 + 666
<br>16`0 == 666*10 + 10000
<br>16`1 == 666*10 + 10001
<br>16`2 == 666*10 + 10002
<br>16`3 == 666*10 + 10003
<br>
<br>6빼고 생각해보자
<br>
<br>

<br>

<br>666




<br>1- + 666
<br>2- + 666
<br>3- + 666
<br>4- + 666
<br>5- + 666
<br>

<br>

<br>666*10




<br>-1 + 666*10
<br>-2 + 666*10
<br>-3 + 666*10
<br>-4 + 666*10
<br>-5 + 666*10
<br>-6 + 666*10
<br>-7 + 666*10
<br>-8 + 666*10
<br>-9 + 666*10
<br>7-
<br>8-
<br>9-

<br>


<br>10-
<br>11-
<br>12-
<br>13-
<br>14-
<br>15-
<br>1-0
<br>1-1
<br>1-2
<br>1-3
<br>1-4
<br>1-5
<br>1-6
<br>1-7
<br>1-8
<br>1-9
<br>17-
<br>18-
<br>19-
<br>20-
<br>→ 16 진수 식으로<br>
<br>아님 재귀함수… 앞의 값 뒤의값?
<br>6을만나면 퍼진다…?

<br>01,2,3,4,5,(6→ 0123456789, 7,8,9
<br>10,11,12,13,14,15,1(6→0,1,2,3,4,5,6,7,8,9) 7,8,9
<br>20
<br>30
<br>40
<br>50
<br>60,61,62,63,64,65,(→00, 01,02,03,04,05,06,07,08,09)


<br><br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    num = 0
    cnt = 0

    while True:
        num += 1
        if '666' in str(num):
           cnt += 1
        if cnt == N:
            break

    print(num)

if __name__ == "__main__":
    solution()
복사<br>
<br>결국 brute-force로 품…
<br>근데 최적화를 해야한다면?
<br>공식을 찾고 싶었는데 그러지 못해서 질문계시판의 도움을 받기로 했다.
<br>1. 1이상 10^18미만의 정수 중에 문자열에 12가 포함된 수의 개수를 구하시오.

2. 1이상 10^18미만의 정수 중에 '종말의 수'의 개수를 구하시오.

--------------------------------------

먼저 위 두 문제를 풀어보시기 바랍니다.

***

앞에 6이 추가되기 전에는 종말의 수가 아니었는데 추가돼서 새롭게 종말의 수가 된 종말의 수를 생각해보죠.
복사<br>
<br>(1≤N&lt;10**18)
<br>
<br>
k자리수에서 12포함

<br>1 자리수일때 0개
<br>2의 자리수일때 1개
<br>3의 자리수일때 9+10개
<br>4의 자리수일때 910(# __12)+910(# 12) + 10*10(# 12__)개
<br>5의 자리수일때 91010 + 91010 + 91010

⇒ 12의 자리를 구하는 경우의 수 → k_C_2
⇒ 나머지 빈 자리를 채우는 경우의 수 → 9*10(k-3) or 10(k-2)

<br><br>
<br>
<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/영화감독-숌.html</link><guid isPermaLink="false">1. Study/Coding Test/영화감독 숌.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[요세푸스 문제]]></title><description><![CDATA[ 
 <br><br>ID: 1158<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1158" target="_blank">https://www.acmicpc.net/problem/1158</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 구현, 자료구조, 큐<br>
생성 일시: 2023년 5월 2일 오후 9:26<br><br><br><br><br>요세푸스 문제는 다음과 같다.<br>1번부터 N번까지 N명의 사람이 원을 이루면서&nbsp;앉아있고, 양의 정수 K(≤ N)가&nbsp;주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &lt;3, 6, 2, 7, 5, 1, 4&gt;이다.<br>N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)<br><br>예제와 같이 요세푸스 순열을 출력한다.<br><br>7 3

복사<br><br>&lt;3, 6, 2, 7, 5, 1, 4&gt;

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/author5" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/author5" target="_blank">author5</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/72" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/72" target="_blank">큐</a>
<br><br>
<br>비슷한 문제 푼 기억이 있는데,,,
<br>deque를 쓸지 그냥 list로 구현할지…
<br>둘다 한번 해보자
<br>
<br>list로 구현
<br>
<br>엥. 잠시만 list를 쓸 필요도 없는데?
<br><br>import sys, collections

def solution():
    N, K = map(int, sys.stdin.readline().rstrip().split())

    i = K
    que = collections.deque([x for x in range(1, N+1)])
    result_que = collections.deque([])
    while len(que) &gt; 0:
        que.append(que.popleft())
        que.append(que.popleft())
        result_que.append(str(que.popleft()))
    
    print("&lt;" + ", ".join(result_que) + "&gt;")

if __name__ == "__main__":
    solution()
복사<br>
<br>예제만 적용가능하게 만들어 놨음. K입력값에 따라 변하게 만들어야함.
<br><br>import sys, collections

def solution():
    N, K = map(int, sys.stdin.readline().rstrip().split())

    que = collections.deque([x for x in range(1, N+1)])
    result_que = collections.deque([])
    while len(que) &gt; 0:
        for _ in range(K-1):
            que.append(que.popleft())
        result_que.append(str(que.popleft()))
    
    print("&lt;" + ", ".join(result_que) + "&gt;")

if __name__ == "__main__":
    solution()
복사<br>
<br>
만약 N=K면, 시간 복잡도는 O(N^2)

<br>
marge sort를 가져다 써볼까?

<br>나누고 합치고 나누고 합치고의 반복
<br>7 3일 경우

<br>12(3) 45(6) 7로 나누고
<br>71245이됨



import sys

def marge_pop(lst, i, cnt, r):
    
    result = []
    for _ in range(cnt):
        result += lst[:i-1]
        r.append(str(lst[i-1]))
        lst = lst[i:]
        
    if len(lst)&gt;0:
        result = lst + result
    
    return result,r

def solution():
    N, K = map(int, sys.stdin.readline().rstrip().split())

    lst = [x for x in range(1,N+1)]
    result = []

    while len(lst) &gt; 0:
        cnt =  len(lst) // K
        lst, result = marge_pop(lst, K, cnt, result)
    
    print("&lt;"+", ".join(result)+"&gt;")

if __name__ == "__main__":
    solution()
복사

<br>마지막에 남겨지는 애들을 print할 방도가 없

import sys

def marge_pop(lst, i, cnt, r):
    
    result = []
    
    if cnt == 0:
        i = i%len(lst)
        cnt = 1
    
    for _ in range(cnt):
        result += lst[:i-1]
        r.append(str(lst[i-1]))
        lst = lst[i:]
        
    if len(lst)&gt;0:
        result = lst + result
    
    return result,r

def solution():
    N, K = map(int, sys.stdin.readline().rstrip().split())

    lst = [x for x in range(1,N+1)]
    result = []

    while len(lst) &gt; 0:
        cnt =  len(lst) // K
        lst, result = marge_pop(lst, K, cnt, result)
    
    print("&lt;"+", ".join(result)+"&gt;")

if __name__ == "__main__":
    solution()
복사

<br>해보긴 했는데 2개 남았을때 까지는 어케 됐는데, 이제는 안됨.
<br>예제 몇개  더 생성
10 9
&lt;9, 8, 10, 2, 5, 3, 4, 1, 6, 7&gt;

10 1
&lt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt;

15 7
&lt;7, 14, 6, 15, 9, 3, 13, 11, 10, 12, 2, 8, 1, 4, 5&gt;

15 4
&lt;4, 8, 12, 1, 6, 11, 2, 9, 15, 10, 5, 3, 7, 14, 13&gt;

15 3
&lt;3, 6, 9, 12, 15, 4, 8, 13, 2, 10, 1, 11, 7, 14, 5&gt;
복사



<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/요세푸스-문제.html</link><guid isPermaLink="false">1. Study/Coding Test/요세푸스 문제.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[요세푸스 문제 0]]></title><description><![CDATA[ 
 <br><br>ID: 11866<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/11866" target="_blank">https://www.acmicpc.net/problem/11866</a><br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 구현, 자료구조, 큐<br>
생성 일시: 2023년 4월 13일 오후 4:24<br><br><br><br><br>요세푸스 문제는 다음과 같다.<br>1번부터 N번까지 N명의 사람이 원을 이루면서&nbsp;앉아있고, 양의 정수 K(≤ N)가&nbsp;주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &lt;3, 6, 2, 7, 5, 1, 4&gt;이다.<br>N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N과 K가&nbsp;빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 1,000)<br><br>예제와 같이 요세푸스 순열을 출력한다.<br><br>
## 예제 출력 1

복사<br>&lt;3, 6, 2, 7, 5, 1, 4&gt;<br>
## 출처

- 문제를 만든 사람:&nbsp;[baekjoon](https://www.acmicpc.net/user/baekjoon)

## 알고리즘 분류

- [구현](https://www.acmicpc.net/problem/tag/102)
- [자료 구조](https://www.acmicpc.net/problem/tag/175)
- [큐](https://www.acmicpc.net/problem/tag/72)

## Before: 생각

- 이게 대체 왜 큐인가… 하는 생각에 linked list에 더 집중해버림…
    - linking을 interval간격으로 하려니 너무 복잡하더라…
    - 뺐다 넣고를 반복하면(print하는 건 삭제한채로 계속 새로 집어넣음.) 그러며는 따로 index 계산할 필요 없이 그냥 interval만큼 더해주면 됨.

```python
import sys

def solution():
    N, flag = map(int, sys.stdin.readline().rstrip().split())

    lst = [x for x in range(1, N+1)]
    length = N
    cnt = 0
    result ="&lt;"

    while length &gt;0:
        if cnt == flag-1:
            result += str(lst.pop(0)) + ", "
            cnt = 0
            length -= 1
        else:
            x = lst.pop(0)
            lst.append(x)
            cnt += 1

    print(result[:-2] +"&gt;")

if __name__ == "__main__":
    solution()
복사<br>
<br>나는 120초인데,,,, 32초까지 줄일 수 있음…

<br>여기는 계속 추가하는 방식이 아님.
<br>index는 interval - 1만큼씩 커짐. 왜냐면 pop으로 항상 지워주니까
<br>index가 길이보다 클 때, 현재 길이로 나눈 나머지로 바꿔줌


<br>import sys

def solution():
    N, gap = map(int, sys.stdin.readline().rstrip().split())

    lst = [x for x in range(1, N+1)]
    idx = gap-1
    result ="&lt;"

    while lst:
        if idx &gt;= len(lst):
            idx %= len(lst)
        result += str(lst.pop(idx))+", "
        idx += gap-1

    print(result[:-2] +"&gt;")

if __name__ == "__main__":
    solution()
복사<br><br>
<br>
que

<br>FIFO
<br>stack과 반
<br>환형 큐[<a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/w/index.php?title=%ED%81%90_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)&amp;action=edit&amp;section=4" rel="noopener" class="external-link" href="https://ko.wikipedia.org/w/index.php?title=%ED%81%90_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)&amp;action=edit&amp;section=4" target="_blank">편집</a>]
  선형 큐의 문제점(배열로 큐를 선언할시 큐의 삭제와 생성이 계속 일어났을때, 마지막 배열에 도달후 실제로는 데이터공간이 남아있지만 오버플로우가 발생)을 보완한 것이 환형 큐이다. front가 큐의 끝에 닿으면 큐의 맨 앞으로 자료를 보내어 원형으로 연결 하는 방식이다.원형 큐라고도 한다.<br>



<br>
while [list] → list가 다 빌 때 까지 loop 돌림.

<br>
pop이나 remove 잊지말기. 왜 값을 0으로 만드는 것밖에 생각을 못했을까?

<br>
print(a,b,c, sep = ”;”) → abc를 공백으로 나누는 대신, ;로 나눠줌.

]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/요세푸스-문제-0.html</link><guid isPermaLink="false">1. Study/Coding Test/요세푸스 문제 0.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 13:15:14 GMT</pubDate></item><item><title><![CDATA[제목 없음]]></title><description><![CDATA[ 
 <br><br>다시풀기: No<br>
생성 일시: 2023년 3월 10일 오후 4:36<br>### 실패
def converting(cap, list):
    sum = 0
    flag = 0
    flaglist = []
    
    for i in range(len(list)-1, -1, -1):
        sum += list[i]
        
        if sum &gt; flag:
            flag += cap
            flaglist.append(i+1)
            
            
    return flaglist
        

def compare(list1, list2, len):
    result_list = []
    for i in range(len):
        result_list.append(max(list1[i], list2[i]))
    return result_list
    

def solution(cap, n, deliveries, pickups):
    
    d_flag = converting(cap, deliveries)
    p_flag = converting(cap, pickups)
    flag = []
    
    print(d_flag, p_flag)
    
    d_len = len(d_flag)
    p_len = len(p_flag)
    
    if d_len == p_len:
        flag = compare(d_flag, p_flag, d_len)
    elif d_len &gt; p_len:
        alone = d_len - p_len
        d_alone = d_flag[:-alone]
        flag = compare(d_alone, p_flag, p_len) + d_flag[:alone]
    else:
        alone = p_len - d_len
        p_alone = -p_flag[:-alone]
        flag = compare(p_alone, d_flag, d_len) + p_flag[:alone]
        
        
        
    
    answer = sum(flag)*2
    return answer
복사<br>
<br>flag를 2번 이상 씩 뛰어넘는 경우가 있으니까…
<br>### 성
def truck(lst, cap, home):
    result = []
    box_sum = 0
    pin = 0
    turn = 0
    
    while home &gt; 0:
        if box_sum &lt; pin + 1 &lt;= box_sum + lst[home-1]:
            result.append(home)
            pin += cap
            # print('pin', pin)
        else:
            box_sum += lst[home-1]
            home -= 1
            turn += 1
            # print('home', home)
    
    return result

def compare(max_list, min_list):
    result = 0
    max_len = len(max_list)
    min_len = len(min_list)
    
    for i in range(max_len):
        if i == min_len -1:
            result += sum(max_list[min_len-1:])
            break
        result += max(max_list[i], min_list[i])
    
    return result
 
    
def solution(cap, n, deliveries, pickups):
    d_list = truck(deliveries, cap, n)
    p_list = truck(pickups, cap, n)
    

    if len(d_list) &gt;= len(p_list):
        answer = compare(d_list, p_list)
    else:
        answer = compare(p_list, d_list)

    return answer*2
복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/제목-없음.html</link><guid isPermaLink="false">1. Study/Coding Test/제목 없음.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[좌표 정렬]]></title><description><![CDATA[ 
 <br><br>ID: 11650<br>
Site: 백준<br>
난이도: 실버 5<br>
다시풀기: No<br>
분류: 정렬<br>
생성 일시: 2023년 4월 12일 오후 8:34<br><br><br><br>import sys

def solution():
    N = int(sys.stdin.readline().rstrip())
    
    lst = []

    while N&gt;0:
        N-=1
        x, y = map(int, sys.stdin.readline().split())
        lst.append((x,y))
    
    lst.sort()
    for i in range(len(lst)):
        lst[i] = str(lst[i][0])+" "+str(lst[i][1])
    
    print("\n".join(lst))

if __name__ == "__main__":
    solution()
복사<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/좌표-정렬.html</link><guid isPermaLink="false">1. Study/Coding Test/좌표 정렬.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[집합]]></title><description><![CDATA[ 
 <br><br>ID: 11723<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/11723" target="_blank">https://www.acmicpc.net/problem/11723</a><br>
난이도: 실버 5<br>
다시풀기: Yes<br>
분류: 구현, 비트마스킹<br>
생성 일시: 2023년 4월 20일 오전 11:06<br><br>비트마스킹으로 다시 풀어보기.<br><br><br><br>비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.<br>
<br>add x: S에 x를 추가한다. (1&nbsp;≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.
<br>remove&nbsp;x: S에서 x를 제거한다. (1&nbsp;≤ x ≤ 20)&nbsp;S에 x가 없는 경우에는 연산을 무시한다.
<br>check x: S에 x가 있으면 1을, 없으면 0을 출력한다.&nbsp;(1 ≤ x ≤ 20)
<br>toggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1&nbsp;≤ x ≤ 20)
<br>all: S를 {1, 2, ..., 20} 으로 바꾼다.
<br>empty: S를 공집합으로 바꾼다.
<br><br>첫째 줄에 수행해야 하는 연산의 수 M (1 ≤ M ≤ 3,000,000)이 주어진다.<br>둘째 줄부터 M개의 줄에 수행해야 하는 연산이 한 줄에 하나씩 주어진다.<br><br>check&nbsp;연산이 주어질때마다, 결과를 출력한다.<br><br>26
add 1
add 2
check 1
check 2
check 3
remove 2
check 1
check 2
toggle 3
check 1
check 2
check 3
check 4
all
check 10
check 20
toggle 10
remove 20
check 10
check 20
empty
check 1
toggle 1
check 1
toggle 1
check 1

복사<br><br>1
1
0
1
0
1
0
1
0
1
1
0
0
0
1
0

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/houma757" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/houma757" target="_blank">houma757</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/pichulia" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/pichulia" target="_blank">pichulia</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/14" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/14" target="_blank">비트마스킹</a>
<br><br>
<br>Java 8: 448 MB
<br>Java 8 (OpenJDK): 448 MB
<br>Java 11: 448 MB
<br>Kotlin (JVM): 448 MB
<br>C#: 64 MB
<br>Java 15: 448 MB
<br>F#: 64 MB
<br>Visual Basic: 64 MB
<br><br>복사<br><br>
<br>비트마스킹
  <a data-tooltip-position="top" aria-label="https://travelbeeee.tistory.com/451" rel="noopener" class="external-link" href="https://travelbeeee.tistory.com/451" target="_blank">[알고리즘] 비트마스킹(bitmasking) 이란</a>

<br>not 0, not 1하면 true false나


<br>파이썬은 왜 느릴까.
  <a data-tooltip-position="top" aria-label="https://y-joo.tistory.com/12" rel="noopener" class="external-link" href="https://y-joo.tistory.com/12" target="_blank">파이썬은 왜 느릴까? ( + 시간초과를 해결할 수 있는 몇몇 기술들)</a>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/집합.html</link><guid isPermaLink="false">1. Study/Coding Test/집합.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[체스판 다시 칠하기]]></title><description><![CDATA[ 
 <br><br>ID: 1018<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1018" target="_blank">https://www.acmicpc.net/problem/1018</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 브루트포스 알고리즘<br>
생성 일시: 2023년 4월 14일 오후 9:25<br><br>다시 풀 때  참고: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/source/54384536" target="_blank">https://www.acmicpc.net/source/54384536</a> (시간 줄이기)<br><br><br><br>지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.<br>체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.<br>보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.<br><br>첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.<br><br>8 8
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBBBWBW
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBWBWBW

복사<br><br>1

복사<br><br>10 13
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
BBBBBBBBWBWBW
BBBBBBBBBWBWB
WWWWWWWWWWBWB
WWWWWWWWWWBWB

복사<br><br>12

복사<br><br>8 8
BWBWBWBW
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBWBWBW
WBWBWBWB

복사<br><br>0

복사<br><br>9 23
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBB
BBBBBBBBBBBBBBBBBBBBBBW

복사<br><br>31

복사<br><br>10 10
BBBBBBBBBB
BBWBWBWBWB
BWBWBWBWBB
BBWBWBWBWB
BWBWBWBWBB
BBWBWBWBWB
BWBWBWBWBB
BBWBWBWBWB
BWBWBWBWBB
BBBBBBBBBB

복사<br><br>0

복사<br><br>8 8
WBWBWBWB
BWBWBWBW
WBWBWBWB
BWBBBWBW
WBWBWBWB
BWBWBWBW
WBWBWWWB
BWBWBWBW

복사<br><br>2

복사<br><br>11 12
BWWBWWBWWBWW
BWWBWBBWWBWW
WBWWBWBBWWBW
BWWBWBBWWBWW
WBWWBWBBWWBW
BWWBWBBWWBWW
WBWWBWBBWWBW
BWWBWBWWWBWW
WBWWBWBBWWBW
BWWBWBBWWBWW
WBWWBWBBWWBW

복사<br><br>15

복사<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br>문제를 다시 작성한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>
<br>
짝수줄 홀수줄 나눠서 생각 가능…

<br>
같은 수가 작은 홀수번 나오는 게 좋음…?

<br>
2,2,4,4인 경우도 있잖아…

<br>
홀수번 검사 짝수번 검사…

<br>
검사 반복 횟수는, m-8, n-8 2번 b시작 w시작

<br>
새 행렬 2개 하나만 들어서, 여기서 무슨 색으로 시작했을때, 얼마 칠해야하는 지 저장.

<br>
<br>input받아서 list 생성
<br>N-7, M-7 의 2중 반복문 생성
<br>0(M-7) 반복문에서, 0~7(N-7)까지
<br>1(M-7) 반복문에서 0~7(N-7)까지…?
<br>앞부분 도움: <a rel="noopener" class="external-link" href="https://ittrue.tistory.com/60" target="_blank">https://ittrue.tistory.com/60</a><br>
<br>row index + col index를 합친값을 %2 하면, 번갈아가면서 나오는 체스판 식의 값을 얻을 수 있음…
<br>W로 시작과 B로 시작은 저로 정반대이기 때문에, 하나만 검색하고, 칠해야할 min, max값만 저장해두고, 64-max 해서 둘 중에 min값을 구하면 됨.
<br>import sys

def solution():
    N,M = map(int, sys.stdin.readline().rstrip().split(" "))
    lst = []
    minimum = 64
    maximum = 0

    for i in range(N):
        row = sys.stdin.readline().rstrip()
        lst.append(row)

    for row in range(N-7):
        for col in range(M-7):
            now = 0

            for i in range(row,row+8):               
                for j in range(col,col+8):
                    if (i+j)%2:
                        label = "W"
                    else:
                        label = "B"
                    
                    if lst[i][j] != label:
                         now += 1
            
            if now &lt; minimum:
                minimum = now
            if now &gt; maximum:
                maximum = now
    
    print(min(minimum, (64-maximum)))

if __name__ == "__main__":
    solution()
복사<br><br>
<br>정 안 되면, for문은 4개씩이나 겹쳐도 됨….
<br>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/체스판-다시-칠하기.html</link><guid isPermaLink="false">1. Study/Coding Test/체스판 다시 칠하기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[카드2]]></title><description><![CDATA[ 
 <br><br>ID: 2164<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/2164" target="_blank">https://www.acmicpc.net/problem/2164</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 자료구조, 큐<br>
생성 일시: 2023년 4월 20일 오후 4:58<br><br>n,m = int(input()), 1
while m&lt;n: # O(logn)
    m *= 2
print(2*n-m)
복사<br>내가 못하다 만 거 같은데, 제대로 이해해보기.<br><br><br><br>N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.<br>이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.<br>예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.<br>N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.<br><br>첫째 줄에 남게 되는 카드의 번호를 출력한다.<br><br>6

복사<br><br>4

복사<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/72" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/72" target="_blank">큐</a>
<br><br>
<br>그냥 queue 써서 문제에 나온대로 쭉 쓰면 쉽게 풀려서 왜이렇게 쉽지? 했는데…
<br><br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())
    queue = [i+1 for i in range(N)]
    while len(queue) &gt; 1:
        queue.pop(0)
        card = queue.pop(0)
        queue.append(card)
        N -= 1
    print(queue[0])

if __name__ == "__main__":
    solution()
복사<br>
<br>
pop이 많이 걸리나?

<br>
연산을 합칠 방법을 찾아봐야겠다…

<br>
첫 턴에 홀수만 빠지고

<br>
마지막이 짝수였으면 또다시 이전 start 바로 다음 수,

<br>
마지막이 홀수였으면 또다시 이전 start 다음다음다음 수...?

<br>
그러면 돌때마다 1/2씩 줄어드니까. logn

<br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())

    end = N
    start = 1
    spare = 0

    # 첫 turn 끝난 카드 list
    queue = [2*i for i in range(N//2)]

    while len(queue) &gt; 0:

        if end % 2 == 0:
            start += 
        else:
            spare = start+1
            start += 2
        end = start + len(queue) - 1

        queue = [for i in range(start, end+1)]

if __name__ == "__main__":
    solution()ㅇ
복사<br>
<br>
어려워서 pass

<br>
pop 시간복잡도가 많이 걸린다고 해서. pop을 쓰지 않기로 함.

<br>
메모리는 많이 쓰겠지만, 그냥 계솔 추가하고 pointer를 옮겨가는 방식으로

<br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())
    queue = [i+1 for i in range(N)]
    point = 0
    while N &gt; 1:
        queue[point] = 0
        card = queue[point + 1]
        queue.append(card)
        N -= 1
        point += 2
    print(queue[point])

if __name__ == "__main__":
    solution()
복사<br>
<br>근데 생각해보면 첫턴에 홀수 빼고 시작하는 것 정도는 추가할 수 있을 것같아서. 시도.
<br>어려웠던건, N이 짝수냐 홀수냐에 따라서 시작 숫자가 달라지는데 그거 생각하는 게 어려웠음. 5랑 4로 예시들어가면서 했다ㅋㅋㅋ
<br>N 값 조정해주는 걸 생각했어야했는데, 잊고 있어서 시행착오 몇번
<br><br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())
    queue = [2*(i+1) for i in range(N//2)]
    point = 0
    
    if N%2 == 1:
        card = queue[point]
        queue.append(card)
        point = 1

    N //= 2 
    while N &gt; 1:
        card = queue[point + 1]
        queue.append(card)
        N -= 1
        point += 2
    print(queue[point])

if __name__ == "__main__":
    solution
복사<br>
<br>ㅇ
<br>인덱스 에러가, if N%2부분에서 나더라
<br>생각해보니 N이 1이면, N//2는 0이되는데 그러면 []가 만들어지고,  queue[0(=point)]의 값은 없음…
<br>그래서 이부분만 뗴어내서 print(1)해주는 걸로 처리함.
<br><br>import sys        
            
def solution():   
    N = int(sys.stdin.readline().rstrip())
    queue = [2*(i+1) for i in range(N//2)]
    point = 0
    
    if N == 1:
        return 1

    if N%2 == 1:
        card = queue[point]
        queue.append(card)
        point = 1

    N //= 2 
    while N &gt; 1:
        card = queue[point + 1]
        queue.append(card)
        N -= 1
        point += 2
    return queue[point]

if __name__ == "__main__":
    print(solution())
복사<br><br>
<br>pop은 변수를 빼고 한칸씩 옮기기 때문에 O(n)의 시간복잡도가 걸림. → 대신 collections 모듈의 deque을 사용하여 popleft()메소드를 사용하는 걸 추천함
<br>앞으로는 증명법 이용해서 풀어보는 것도 좋을것 같다… 이산구조 열심히 해야지.
<br>입력으로 1 이상 1,000,000 이하의 정수 N이 주어진다면 N=1, N=2 등의 최소 케이스가 잘 나오는지 확인하는 것이 좋습니다.
<br>N=1,000,000 같은 최대 케이스를 넣었을 때 주어진 시간 제한 안에 답이 나오는지도 확인해 볼 수 있습니다.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/카드2.html</link><guid isPermaLink="false">1. Study/Coding Test/카드2.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[코테 질문 모음]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener">#코딩테스트</a><br>
<br><br><br>
<br>
종류를 무한으로 쓸 수 있는 건 쉬운데, 종류별로 갯수가 정해져있는 건 까다로움…

<br>
일전에 실패했던 배낭문제(<a data-href="12865. 평범한 배낭" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/12865.-평범한-배낭.html" class="internal-link" target="_self" rel="noopener">12865. 평범한 배낭</a>)와 이문제 (<a data-href="11047. 동전 0" href="https://sunha20.github.io/digital-garden/1.-study/coding-test/11047.-동전-0.html" class="internal-link" target="_self" rel="noopener">11047. 동전 0</a>) 그리고 동전이 배수가 아닌 경우의 차이가 뭘까.

<br>
내생각

<br>


<br>
<br>동전문제 싹 풀어보자…
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/코테-질문-모음.html</link><guid isPermaLink="false">1. Study/Coding Test/코테 질문 모음.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:29:06 GMT</pubDate></item><item><title><![CDATA[큐]]></title><description><![CDATA[ 
 <br><br>ID: 10845<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/10845" target="_blank">https://www.acmicpc.net/problem/10845</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 자료구조, 큐<br>
생성 일시: 2023년 4월 27일 오전 9:22<br><br><br><br><br>정수를 저장하는 큐를&nbsp;구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.<br>명령은 총 여섯 가지이다.<br>
<br>push X: 정수 X를 큐에 넣는 연산이다.
<br>pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
<br>size: 큐에 들어있는 정수의 개수를 출력한다.
<br>empty: 큐가&nbsp;비어있으면 1, 아니면 0을 출력한다.
<br>front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
<br>back:&nbsp;큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
<br><br>첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.<br><br>출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.<br><br>15
push 1
push 2
front
back
size
empty
pop
pop
pop
size
empty
pop
push 3
empty
front

복사<br><br>1
2
2
0
1
2
-1
0
1
-1
0
3

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/compro0317" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/compro0317" target="_blank">compro0317</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/deunlee" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/deunlee" target="_blank">deunlee</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/175" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/175" target="_blank">자료 구조</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/72" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/72" target="_blank">큐</a>
<br><br>
<br>collection.deque 사용해보기
<br><br>import sys
from collections import deque
    
def solution():
    N = int(sys.stdin.readline().rstrip())
    que = deque([])

    while N&gt;0:
        N-=1
        temp = sys.stdin.readline().rstrip()

        if temp[:4] == "push":
            x = int(temp[5:])
            temp = "push"    
        
        try:
            match temp:
                case "push":
                    que.append(x)
                case "pop":
                        print(que.popleft())
                case "size":
                    print(len(que))
                case "empty":
                    if len(que) == 0:
                        print(1)
                    else:
                        print(0)
                case "front":
                    print(que[0])
                case "back":
                    print(que[-1])
        except IndexError:
            print(-1)

if __name__ == "__main__":
    solution()
복사<br>
<br>ㅇ
<br>
<br><br>
<br>collemctions.deque

<br>생성

<br>a = collections.deque([])


<br>이터레이션, 피클링,&nbsp;len(d),&nbsp;reversed(d),&nbsp;copy.copy(d)&nbsp;,copy.deepcopy(d),&nbsp;[in](https://docs.python.org/ko/3/reference/expressions.html#in)&nbsp;연산자를 사용한 멤버십 검사 및 첫 번째 요소를 액세스하는&nbsp;d[0]과 같은 서브 스크립트 참조를 지원합니다. 인덱스를 사용하는 액세스는 양쪽 끝에서는 O(1) 이지만 중간에서는 O(n) 으로 느려집니다. 빠른 무작위 액세스를 위해서는 대신 리스트를 사용하십시오.

  <a data-tooltip-position="top" aria-label="https://docs.python.org/ko/3/library/collections.html#collections.deque" rel="noopener" class="external-link" href="https://docs.python.org/ko/3/library/collections.html#collections.deque" target="_blank">collections — 컨테이너 데이터형</a><br>

<br>python에 switch-case문이 없는 이유
  <a data-tooltip-position="top" aria-label="https://okeybox.tistory.com/395" rel="noopener" class="external-link" href="https://okeybox.tistory.com/395" target="_blank">[Python] 파이썬에 switch-case 문이 없는 이유. 그리고 with Python 3.10 match-case</a><br>

<br>lambda
  → 매개변수 : 표현식
  다음은 두 수를 더하는 함수입니다.
&gt;&gt;&gt;defhap(x, y):
...return x + y
...
&gt;&gt;&gt; hap(10, 20)
30

복사
  이것을 람다 형식으로는 어떻게 표현할까요?
&gt;&gt;&gt; (lambda x,y: x + y)(10, 20)
30
복사
  <a data-tooltip-position="top" aria-label="https://wikidocs.net/64" rel="noopener" class="external-link" href="https://wikidocs.net/64" target="_blank">3.5 람다(lambda)</a>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/큐.html</link><guid isPermaLink="false">1. Study/Coding Test/큐.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[터렛]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> <a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:실버/3" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#실버/3</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener">#코딩테스트</a><br>
<a href="https://sunha20.github.io/digital-garden?query=tag:실버/3" class="tag" target="_blank" rel="noopener">#실버/3</a><br><br><br>조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승환의 사진이다.<br><img src="https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg" referrerpolicy="no-referrer"><br>이석원은 조규현과 백승환에게 상대편 마린(류재명)의 위치를 계산하라는 명령을 내렸다. 조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.<br>조규현의 좌표&nbsp;(�1,�1)와 백승환의 좌표&nbsp;(�2,�2)가 주어지고, 조규현이 계산한 류재명과의 거리&nbsp;�1과 백승환이 계산한 류재명과의 거리&nbsp;�2가 주어졌을 때, 류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에 테스트 케이스의 개수&nbsp;�가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.<br>한 줄에 공백으로 구분 된 여섯 정수&nbsp;�1,&nbsp;�1,&nbsp;�1,&nbsp;�2,&nbsp;�2,&nbsp;�2가 주어진다.<br><br>각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는&nbsp;−1&nbsp;출력한다.<br><br>
<br> −10000≤�1,�1,�2,�2≤10000 
<br> 1≤�1,�2≤10000 
<br><br>3<br>
0 0 13 40 0 37<br>
0 0 3 0 7 4<br>
1 1 1 1 1 5<br><br>2<br>
1<br>
0<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baemin0103" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baemin0103" target="_blank">baemin0103</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/koyh1200" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/koyh1200" target="_blank">koyh1200</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/dksdks3737" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/dksdks3737" target="_blank">dksdks3737</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/doju" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/doju" target="_blank">doju</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/124" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/124" target="_blank">수학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/100" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/100" target="_blank">기하학</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/137" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/137" target="_blank">많은 조건 분기</a>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/터렛.html</link><guid isPermaLink="false">1. Study/Coding Test/터렛.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Sat, 02 Mar 2024 02:40:50 GMT</pubDate><enclosure url="https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[통계학]]></title><description><![CDATA[ 
 <br><br>ID: 2108<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/2108" target="_blank">https://www.acmicpc.net/problem/2108</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
생성 일시: 2023년 7월 26일 오후 11:48<br><br><br><br><br>수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자.<br>
<br>산술평균 : N개의 수들의 합을 N으로 나눈 값
<br>중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값
<br>최빈값 : N개의 수들 중 가장 많이 나타나는 값
<br>범위 : N개의 수들 중 최댓값과 최솟값의 차이
<br>N개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 단, N은 홀수이다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다.<br><br>첫째 줄에는 산술평균을 출력한다. 소수점 이하 첫째 자리에서 반올림한 값을 출력한다.<br>둘째 줄에는 중앙값을 출력한다.<br>셋째 줄에는 최빈값을 출력한다. 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.<br>넷째 줄에는 범위를 출력한다.<br><br>5
1
3
8
-2
2

복사<br><br>2
2
1
10

복사<br><br>1
4000

복사<br><br>4000
4000
4000
0

복사<br><br>5
-1
-2
-3
-1
-2

복사<br><br>-2
-2
-1
2

복사<br><br>3
0
0
-1

복사<br><br>0
0
0
1

복사<br>(0 + 0 + (-1)) / 3 =&nbsp;-0.333333... 이고 이를 첫째 자리에서 반올림하면 0이다. -0으로 출력하면 안된다.<br><br>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/bjh3502" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/bjh3502" target="_blank">bjh3502</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/bsyun0571" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/bsyun0571" target="_blank">bsyun0571</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jungyh1509" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jungyh1509" target="_blank">jungyh1509</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/kongum" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/kongum" target="_blank">kongum</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/palilo" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/palilo" target="_blank">palilo</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/YunGoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/YunGoon" target="_blank">YunGoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/skynet" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/skynet" target="_blank">skynet</a>
<br><br>
<br>아 음수 받는 걸 생각못함.. idxf로 최빈값 찾기불가
<br>복사<br>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/통계학.html</link><guid isPermaLink="false">1. Study/Coding Test/통계학.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[트리]]></title><description><![CDATA[ 
 <br><br>ID: 0<br>
Site: 알고리즘<br>
다시풀기: No<br>
분류: 너비 우선 탐색, 트리<br>
생성 일시: 2023년 8월 19일 오후 4:51<br><br><br>
<br>Tree: set of node → node have a parent-child relationship

<br>In order for a tree to form, It needs root.


<br>Root

<br>node is the essential component.
<br>has no parent


<br>Understanding to use the tree when we write recursive code

<br>tree can be of only one node(root) with empyt subtree
<br>or even empty


<br>Use to store the information that have inherent relationships.
<br>ordered tree means hierarchical and linear relationships among the children of each node
<br><br>
<br>nodes(vertax), edges
<br>root
<br>child, parent, sibiling(same level)
<br>descendant, ancestor → 판단 기준: reachable
<br>exteranal nodes(leave), internal nodes → 판단 기준: have child
<br>sub tree
<br>degree of a node: number of its children
<br>path:

<br>set of edges that connect two node
<br>tyer exists a unique path between any pair of nodes


<br>level: length of unique path from the root to node
<br>height of a tree: maximum level of a node
<br><br>
<br>ordered tree
<br>every node has at most two children (left child, right child)
<br>type

<br>proper: all nodes have exactly zero of two children ←→ improper


<br>example

<br>dicision tree
<br>arithmetic expression


<br><br>
<br>n = # of nodes
<br>n_e = # of external nodes
<br>n_i = # of intermal nodes
<br>h = height of tree
<br>
<br>
<br>
<br>
<br><br>
<br>general tree → linked structure

<br>node haves

<br>element
<br>parent
<br>sequence of children




<br><br><br>
<br>node haves

<br>element
<br>parent
<br>left child
<br>right child


<br>time complexity

<br>add, delete (except find): O(1)
<br>height: O(n) → check all node to find maximum depth.


<br><br>
<br>position

<br>assign an index to each node based on level: level numbering
<br>index(root) = 0
<br>index(left child) = 2(index(parant node)) + 1
<br>index(right child) = 2(index(parant node)) + 2


<br>advantage

<br>position p can be expressed by single integer
<br>parent,left, and right of p can all be arithmetically computed


<br>disadvantage

<br>size of array depend on max f(p) → can have a lot of empty node (ex) right-child-only tree)
<br>Updating(add, delete) a node is cannot be done efficiently.

<br>O(n) → 중간에 빼거나 넣는 경우 자리를 다 옮겨줘야함.




<br><br><br>
<br>depth-first
<br>visit node before its descendants. → 조상부터 방문
<br>(recusive) visit → move to next node(child, sibiling)

<br>visit → child chcek → visit → child child check → x → child sibiling


<br>order: root → left → right
<br><br>
<br>depth-first
<br>visit node before its ancestor. → 후손부터 방문
<br>(recusive) move to next node(child, sibiling) → visit

<br>child chcek → child child check → x → child visit → child sibiling child check → x → visit → child sibiling sibiling x → parent visit.


<br>order : left → right → root
<br><br>
<br>non-recursive
<br>visit all the nodes in each level before checking the nodes at the next level
<br>implement to use queue → when the node is popped, the children of the node is appended.
<br>노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택<br>
<a rel="noopener" class="external-link" href="https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html" target="_blank">https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html</a>
<br><br>
<br>left chect → visit → root → right
<br>if left → if left → if left → visit → root visit → right visit → left visit → rot visit
<br>order: left → root → right
<br>def inorder(v)
	if left(v) != null:
		print("(")
		inorder(left(v))
	print(v.element)
	if right(v) != null:
		inorder(right(v))

복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/트리.html</link><guid isPermaLink="false">1. Study/Coding Test/트리.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[프린터 큐]]></title><description><![CDATA[ 
 <br><br>ID: 1966<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1966" target="_blank">https://www.acmicpc.net/problem/1966</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
분류: 구현, 시뮬레이션, 자료구조, 큐<br>
생성 일시: 2023년 9월 14일 오후 12:04<br><br><br><br><br>여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.<br>
<br>현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.
<br>나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.
<br>예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.<br>여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.<br><br>첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.<br>테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M &lt; N)이 주어진다. 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.<br><br>각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.<br><br>3
1 0
5
4 2
1 2 3 4
6 0
1 1 9 1 1 1

복사<br><br>1
2
5

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/1" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/1" target="_blank">ICPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/7" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/7" target="_blank">Regionals</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/10" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/10" target="_blank">Europe</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/15" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/15" target="_blank">Northwestern European Regional Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/55" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/55" target="_blank">NWERC 2006</a>&nbsp;F번<br>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/doju" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/doju" target="_blank">doju</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/iiwwnnaa" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/iiwwnnaa" target="_blank">iiwwnnaa</a>,&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br>원래 진짜 문제에 나온대로 pop하고 append하는 식으로 했는데 너무 과해,,,,
<br>그냥 화살표를 옮기는 방식으로 하자.
<br><br>import sys

def printque():
    N = int(sys.stdin.readline().rstrip())

    for i in range(N):
        num, idx = map(int, sys.stdin.readline().split())
        que = list(map(int, sys.stdin.readline().split()))
        result(que, idx)

def result(que, target):
    cnt = 0
    flag = 0
    M = max(que)

    while True:
        if que[flag] == M and que[flag] != -1:
            cnt += 1
            if target == flag:
                print(cnt)
                break
            que[flag] = -1
            M = max(que)

        flag = (flag+1)% len(que)

    return

if __name__ == "__main__":
    printque()
복사<br><br>복사]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/프린터-큐.html</link><guid isPermaLink="false">1. Study/Coding Test/프린터 큐.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[한수]]></title><description><![CDATA[<a class="tag" href="https://sunha20.github.io/digital-garden/?query=tag:코딩테스트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#코딩테스트</a> 
 <br><a href="https://sunha20.github.io/digital-garden?query=tag:코딩테스트" class="tag" target="_blank" rel="noopener">#코딩테스트</a><br><br>ID: 1065<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1065" target="_blank">https://www.acmicpc.net/problem/1065</a><br>
난이도: 실버 4<br>
다시풀기: Yes<br>
분류: 브루트포스 알고리즘<br>
생성 일시: 2023년 5월 2일 오전 10:24<br><br>
💡 다른 풀이 이해하기<br><br><br><br><br>어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.<br><br>첫째 줄에 1,000보다 작거나 같은 자연수 N이 주어진다.<br><br>첫째 줄에 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력한다.<br><br>110

복사<br><br>99

복사<br><br>1

복사<br><br>1

복사<br><br>210

복사<br><br>105

복사<br><br>1000

복사<br><br>144

복사<br><br>500

복사<br><br>119

복사<br><br>
<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/bdh3313" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/bdh3313" target="_blank">bdh3313</a>
<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/djm03178" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/djm03178" target="_blank">djm03178</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jh05013" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jh05013" target="_blank">jh05013</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>
<br>입력 자릿수가 2보다 같거나 작으면 그대로 출력하면됨
<br>2보다 크면, 두가지 선택지가 있는데

<br>하나는 다 구해서, 속하는 것까지 잘라내기
<br>나머지 하나는 규칙성을 가지고 구하기. → 어려우니까 일단 위에걸로.


<br><br>import sys

def solution():
    x = int(sys.stdin.readline().rstrip())
    # x = int(x_str)

    if x &lt;= 99:
        return(x)
    
    n = 100
    result = 99

    while n &lt;= x:
        a_0 = n % 10
        a_1 = (n//10) % 10
        d = a_1 - a_0

        result += 1
        n_len = len(str(n))

        for i in range(2,n_len):
            a_0 = a_1
            a_1 = (n//(10**i)) % 10

            if d != a_1 - a_0:
                result -= 1 
                break
        n += 1

    return result  

if __name__ == "__main__":
    print(solution())
복사<br><br>
<br>훨씬 빠른 풀이가 있었음
<br>이해해보기
<br>def func(a):
    if(a&lt;100):
        return a
    else:
        x = 99
        for i in range(100,a+1):
            
            if(int(i/100)+i%10==2*(int(i/10)%10)):
                x = x+1
        return x

x = int(input())
print(func(x))
복사<br><br>
<br>보다 규칙성과 확장성을 가진 코드로 만들어 보기로함
<br>import sys

def solution():
    x = int(sys.stdin.readline().rstrip())

    # x: 두자리 이하의 양의정수
    if x &lt;= 99:
        return(x)
    
    # x가 abc(d)일 때 a(b-1)9(9)까지 탐색
    n = 10
    result = 99
    i = 1
    
    while n &lt; x//(10**i):
        d = ((n%10) - (n//10))*i
        a_1 = n%10
        
        if a_1+d &gt;= 0 and a_1+d&lt;=9:
            result+=1
        
        n += 1
        # 자릿수 변화
        if n == 100:
            n = 10
            i += 1

    # ab--일때 탐색
    a_1 = n%10
    d = ((n%10) - (n//10))*i
    if a_1+d &gt;= 0 and a_1+d&lt;=9:
        x_ = n
        for j in range(1,i+1):
            d = ((n%10) - (n//10))*j        
            x_ = x_*(10*j) + (d+a_1)

        if x_ &lt;= x:
            result += 1
    return result  

if __name__ == "__main__":
    print(solution())
복사<br>
<br>원래는 자릿수 변환이 i =2 였는데, 더 많은 자릿수에서 작동할 수 있도록 i+=로 변경
<br>확실히 위 아래 코드를 비교했을 때, 후자가 빠름

<br>input = 1000000

<br>전자: 5.945936679840088
<br>후자: 3.5561044216156006


<br>input = 10000000

<br>전자: 23.153870820999146
<br>후자: 2.911761999130249




<br>시간복잡도

<br>전자: x*x의 자릿수-3
<br>후자: (while) (n)99*x의자릿수-2 + 자릿수.
<br>x의 자릿수를 x에 대한 식으로 표현가능하다고 본다면,
<br>전자는 O(x^2) / 후자는 O(x)


<br><br>
<br>python 시간 복잡도를 측정하는 방법
import time
start = time.time()

...

print("time :", time.time() - start)
복사

]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/한수.html</link><guid isPermaLink="false">1. Study/Coding Test/한수.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:06:03 GMT</pubDate></item><item><title><![CDATA[ATM]]></title><description><![CDATA[ 
 <br><br>ID: 11399<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/11399" target="_blank">https://www.acmicpc.net/problem/11399</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 그리디 알고리즘, 정렬<br>
생성 일시: 2023년 8월 7일 오후 10:21<br><br>
💡 **input을 int의 list로 받을 때 깔끔하게 쓰는 법**<br>P = list(map(int,sys.stdin.readline().split()))
복사<br><br><br><br><br>인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번&nbsp;사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.<br>사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1&nbsp;= 3, P2&nbsp;= 1, P3&nbsp;= 4, P4&nbsp;= 3, P5&nbsp;= 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.<br>줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.<br>줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi&nbsp;≤ 1,000)<br><br>첫째 줄에&nbsp;각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.<br><br>5
3 1 4 3 2

복사<br><br>32

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/hakgb11" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/hakgb11" target="_blank">hakgb11</a>
<br><br>복사<br><br>import sys

def atm():
    N = int(sys.stdin.readline().rstrip())
    P = list(map(int,sys.stdin.readline().split()))
    time = 0

    P.sort()

    for i in range(N):
        time += P[i]*(N-i)

    print(time)

if __name__ == "__main__":
    atm()
복사<br><br>P = list(map(int,sys.stdin.readline().split()))
복사<br>
<br>input을 int의 list로 받을 때 깔끔하게 쓰는 법
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/atm.html</link><guid isPermaLink="false">1. Study/Coding Test/ATM.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[BufferedReader]]></title><description><![CDATA[ 
 <br>NAV: <a data-href="1. Study/Coding Test.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test" class="internal-link" target="_self" rel="noopener">1. Study/Coding Test.md</a><br><a data-tooltip-position="top" aria-label="https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90" rel="noopener" class="external-link" href="https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90" target="_blank">BufferedReader를 알고 쓰자</a><br>
<a data-tooltip-position="top" aria-label="https://nullnull.tistory.com/23" rel="noopener" class="external-link" href="https://nullnull.tistory.com/23" target="_blank">JAVA 노드 스트림 &amp; 보조 스트림</a><br>+)<br>
Java에서 데이터를 읽고 쓰는 방법에는 여러 가지가 있습니다. 그 중에서도&nbsp;Buffer,&nbsp;노드 스트림(Node Stream), 그리고&nbsp;보조 스트림(Auxiliary Stream)에 대해 설명하겠습니다.<br>
<br><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank"><strong></strong>: Buffer는 데이터가 전송될 때 일시적으로 저장되는 메모리 영역입니다</a>Buffer<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.&nbsp;<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">Buffer는 속도가 빠른 장치에서 들어오는 모든 데이터를 잠시 저장해놓고 버퍼가 꽉 차거나, 특정 커맨드를 입력받았을 때 일괄적으로 내보내고, 버퍼를 초기화시킵니다</a><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.&nbsp;<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">이렇게 하면 속도가 느린 장치에서 일을 여러번 하지 않도록 속도가 빠른 장치에서 미리미리 처리해두고 "버퍼"라는 임시 공간에 보관해두었다가 한번에 넘겨주는 것입니다</a><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.
<br><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank"><strong></strong>: 노드 스트림은 스트림의 주축을 이루는 요소입니다</a>노드 스트림(Node Stream)<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.&nbsp;<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">노드 스트림은 데이터 타입 (Char 또는 Byte), 방향 (Input 또는 Output), 노드 타입 (File 또는 키보드 등등)에 따라 결정됩니다</a><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.
<br><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank"><strong></strong>: 보조 스트림은 노드 스트림을 통해 들어오거나, 나가는 데이터를 처리하는 것을 도와주는 일종의 플러그인입니다</a>보조 스트림(Auxiliary Stream)<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.&nbsp;<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">보조 스트림은 노드 스트림에 연결되어 기능을 추가하거나 향상시킵니다</a><a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a>.&nbsp;<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">예를 들어,&nbsp;<code></code>와&nbsp;<code></code>은 보조 스트림의 예로, 이들은 노드 스트림에 버퍼링 기능을 추가하여 입출력 효율을 높입니다</a>BufferedReaderBufferedInputStream<a data-tooltip-position="top" aria-label="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" rel="noopener" class="external-link" href="https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache" target="_blank">1</a><a data-tooltip-position="top" aria-label="https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90" rel="noopener" class="external-link" href="https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90" target="_blank">2</a>.
<br>이 세 가지 개념은 Java의 입출력 시스템을 이해하는 데 중요한 역할을 합니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊<br>Scanner&nbsp;클래스는 Java에서 제공하는&nbsp;보조 스트림(Auxiliary Stream)&nbsp;중 하나입니다.&nbsp;Scanner는 기본적으로 입력 스트림을 받아서 다양한 타입의 데이터를 읽을 수 있는 메소드를 제공합니다. 이는&nbsp;InputStream,&nbsp;File,&nbsp;String&nbsp;등 다양한 소스로부터 데이터를 읽을 수 있게 해주는 기능을 추가하는 역할을 하므로, 보조 스트림에 속합니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊<br>InputStreamReader는 Java에서 제공하는&nbsp;노드 스트림(Node Stream)&nbsp;중 하나입니다.&nbsp;InputStreamReader는 바이트 스트림을 문자 스트림으로 변환하는 데 사용됩니다. 이 클래스는&nbsp;System.in과 같은&nbsp;InputStream을&nbsp;Reader로 변환하여, 문자 단위로 읽을 수 있게 해줍니다. 따라서,&nbsp;InputStreamReader는 데이터의 원본(노드)에서 직접 데이터를 읽어오는 역할을 하므로 노드 스트림에 속합니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊<br>System.in과 같은&nbsp;InputStream은 Java에서 제공하는&nbsp;노드 스트림(Node Stream)&nbsp;중 하나입니다.&nbsp;InputStream은 바이트 단위로 데이터를 읽어오는 스트림입니다. 이는 데이터의 원본(노드)에서 직접 데이터를 읽어오는 역할을 하므로 노드 스트림에 속합니다.&nbsp;System.in은 표준 입력 스트림으로, 주로 키보드 입력을 받기 위해 사용됩니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊<br>+) <a data-tooltip-position="top" aria-label="https://www.acmicpc.net/board/view/9744" rel="noopener" class="external-link" href="https://www.acmicpc.net/board/view/9744" target="_blank">글 읽기 - BufferedReader를 어떻게 사용해야 할지 모르겠습니다.</a><br>
일반적으로 BufferedReader 를 통해 입력받을때 유의하셔야 할 점이 몇가지 있습니다.&nbsp;<br>1. 기본적으로 BufferedReader는 한 줄을 통째로 입력받는 방법으로 주로 쓰입니다.<br>2. readLine() 메서드는 값을 읽어올 때, String값으로 개행문자(엔터값)를 포함해&nbsp;한줄을 전부 읽어오는 방식입니다.<br>&nbsp;- 비슷한 예로 Scanner메서드 중 nextLine()도 스트링 값과 개행문자(엔터값)을 같이 읽어옵니다.(반면 next()는 개행문자는 제외하고 스트링 값만 읽어옵니다.)<br>&nbsp;- 예제의 입력 예제를 보면 각 문장이 모두 개행문자(엔터)로 구별되있는것을 확인하실 수 있습니다. 따라서 이 문제에서&nbsp;개행문자를 입력받는것은 필수입니다!<br>3. read() 메서드는 값을 읽어올 때, int값으로 변형하여 읽어오는 방식입니다.&nbsp;<br>&nbsp;- 예를들어 input.txt에 저장된&nbsp;1이라는 숫자를 read()를 통해 읽어오면&nbsp;&nbsp;int형 숫자 1을 읽어오는 것이 아닌, txt형식으로 저장된 ASCII 형식의 문자값 '1'을 읽어오는 것이므로 결국 int값으론 49를 읽어오는 것이 됩니다.&nbsp;<br>&nbsp;- 이를 해결하려면&nbsp;int a = br.read() - 48; br.readLine();&nbsp;을 하여 ASCII 값에서 뻴셈을 이용한 뒤&nbsp;엔터 값을 읽어오거나,&nbsp;int a = Integer.parseInt(br.readLine());&nbsp;를 통해 엔터값을 포함해 한줄을 통째로 입력받은 뒤 해당 스트링값을 int로 형변환 해주는 방법이 있습니다. (저같은 경우에는 주로 후자의 방법을 사용합니다)]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/bufferedreader.html</link><guid isPermaLink="false">1. Study/Coding Test/BufferedReader.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Wed, 15 May 2024 00:33:11 GMT</pubDate></item><item><title><![CDATA[DNA]]></title><description><![CDATA[ 
 <br><br>ID: 1969<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/1969" target="_blank">https://www.acmicpc.net/problem/1969</a><br>
난이도: 실버 4<br>
다시풀기: No<br>
분류: 구현, 그리디 알고리즘, 문자열, 브루트포스 알고리즘<br>
생성 일시: 2023년 8월 4일 오전 12:41<br>
💡 ******************Deep Copy******************<br>count = [{'A':0, 'T':0, 'G':0, 'C':0}]*M
# Deep Copy

count = [{'A':0, 'T':0, 'G':0, 'C':0} for _ in range(M)]
# Shallow Copy
복사<br>**lambda reverse**<br>ch_list = sorted(ch.items(), key=lambda x:x[1])
# 오름차순

ch_list = sorted(ch.items(), key=lambda x:-x[1])
# 내림차순
복사<br><br><br><br><br><br>DNA란 어떤 유전물질을 구성하는 분자이다. 이 DNA는 서로 다른 4가지의 뉴클레오티드로 이루어져 있다(Adenine, Thymine, Guanine, Cytosine). 우리는 어떤 DNA의 물질을 표현할 때, 이 DNA를 이루는 뉴클레오티드의 첫글자를 따서 표현한다. 만약에 Thymine-Adenine-Adenine-Cytosine-Thymine-Guanine-Cytosine-Cytosine-Guanine-Adenine-Thymine로 이루어진 DNA가 있다고 하면, “TAACTGCCGAT”로 표현할 수 있다. 그리고 Hamming Distance란 길이가 같은 두 DNA가 있을 때, 각 위치의 뉴클오티드 문자가 다른 것의 개수이다. 만약에 “AGCAT"와 ”GGAAT"는 첫 번째 글자와 세 번째 글자가 다르므로 Hamming Distance는 2이다.<br>우리가 할 일은 다음과 같다. N개의 길이 M인 DNA s1, s2, ..., sn가 주어져 있을 때 Hamming Distance의 합이 가장 작은 DNA s를 구하는 것이다. 즉, s와 s1의 Hamming Distance + s와 s2의 Hamming Distance + s와 s3의 Hamming Distance ... 의 합이 최소가 된다는 의미이다.<br><br>첫 줄에 DNA의 수 N과 문자열의 길이 M이 주어진다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 DNA가 주어진다. N은 1,000보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다.<br><br>첫째 줄에 Hamming Distance의 합이 가장 작은 DNA 를 출력하고, 둘째 줄에는 그 Hamming Distance의 합을 출력하시오. 그러한 DNA가 여러 개 있을 때에는 사전순으로 가장 앞서는 것을 출력한다.<br><br>5 8
TATGATAC
TAAGCTAC
AAAGATCC
TGAGATAC
TAAGATGT

복사<br><br>TAAGATAC
7

복사<br><br>4 10
ACGTACGTAC
CCGTACGTAG
GCGTACGTAT
TCGTACGTAA

복사<br><br>ACGTACGTAA
6

복사<br><br>6 10
ATGTTACCAT
AAGTTACGAT
AACAAAGCAA
AAGTTACCTT
AAGTTACCAA
TACTTACCAA

복사<br><br>AAGTTACCAA
12

복사<br><br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/1" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/1" target="_blank">ICPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/7" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/7" target="_blank">Regionals</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/42" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/42" target="_blank">Asia Pacific</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/211" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/211" target="_blank">Korea</a>&nbsp;&gt;&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/category/detail/1066" rel="noopener" class="external-link" href="https://www.acmicpc.net/category/detail/1066" target="_blank">Asia Regional - Seoul 2006</a>&nbsp;B번<br>
<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/jsa3824" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/jsa3824" target="_blank">jsa3824</a>
<br>잘못된 번역을 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/previc1" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/previc1" target="_blank">previc1</a>
<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/sohnjunior" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/sohnjunior" target="_blank">sohnjunior</a>
<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/tncks0121" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/tncks0121" target="_blank">tncks0121</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/102" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/102" target="_blank">구현</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/158" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/158" target="_blank">문자열</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/33" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/33" target="_blank">그리디 알고리즘</a>
<br><a data-tooltip-position="top" aria-label="https://www.acmicpc.net/problem/tag/125" rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/tag/125" target="_blank">브루트포스 알고리즘</a>
<br><br>
<br>
그 자리의 것들만 비교

<br>
4가지 종류 반복

<br>
그냥 최빈값들로다가…

<br>
dict 써서,

<br>
deep copy

<br>count = [{'A':0, 'T':0, 'G':0, 'C':0}]*M
# Deep Copy

count = [{'A':0, 'T':0, 'G':0, 'C':0} for _ in range(M)]
# Shallow Copy
복사<br>
<br>lambda reverse(오름 → 내림)
<br>ch_list = sorted(ch.items(), key=lambda x:x[1])
# 오름차순

ch_list = sorted(ch.items(), key=lambda x:-x[1])
# 내림차순
복사<br><br>import sys

def solution():
    N,M = map(int, sys.stdin.readline().rstrip().split())
    count = [{'A':0, 'C':0, 'G':0, 'T':0} for _ in range(M)]
    result = ""
    sum = 0

    for i in range(N):
        line = sys.stdin.readline().rstrip()
        for j in range(M):
            if count[j].get(line[j]) == None:
                count[j][line[j]] = 1
            else:
                count[j][line[j]] += 1

    for ch in count:
        ch_list = sorted(ch.items(), key=lambda x:-x[1])
        result += ch_list[0][0]
        sum += (ch_list[1][1] + ch_list[2][1] + ch_list[3][1])
        print(ch_list)

    print(result)
    print(sum)

if __name__ =="__main__":
    solution()
복사<br><br><br>@pubhan35

def find_min_dna():
    neucleotide, haming_distance, final_dna = 'ACGT', 0, ''
    element = {alp: 0 for alp in neucleotide}
    for j in range(M):
        each_cnt, each_key = 0, ''
        for i in range(N):
            element[dna_list[i][j]] += 1
        for key in neucleotide:
            if element[key] &gt; each_cnt:
                each_cnt, each_key = element[key], key
            element[key] = 0
        final_dna += each_key
        haming_distance += (N - each_cnt)
        
    print(final_dna, haming_distance, sep='\n')

import sys
new_input = sys.stdin.readline
N, M = map(int, new_input().split())
dna_list = [new_input().rstrip() for _ in range(N)]
find_min_dna()
복사<br>
<br>변수명 깔끔.

<br>알파벳은 alp로…


<br>2차원 data 접근

<br>나는 row → colum순으로 접근만 가능하다고 착각하고 있었는데,
<br>위에 코드 처럼 col을 고정하고 row를 돌리는 것도 간단하게 가능.

<br>그렇게 해서 한 col 끝나면 바로 그 줄에 대한 결과 뽑아내고..




]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/dna.html</link><guid isPermaLink="false">1. Study/Coding Test/DNA.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[HELP: 반례 찾기]]></title><description><![CDATA[ 
 <br><br>ID: 0<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/blog/view/70" target="_blank">https://www.acmicpc.net/blog/view/70</a><br>
다시풀기: No<br>
분류: help<br>
생성 일시: 2023년 4월 20일 오후 5:55<br>
<br>가장 중요한 것은 직접 데이터를 만들어서 넣어 보는 것입니다.&nbsp;<a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/14405" target="_blank">https://www.acmicpc.net/problem/14405</a>&nbsp;를 예로 들어 봅시다. 그러면 이런 입력들을 넣어 볼 수 있습니다.
<br>pi 하나만 넣으면? ka? chu? 한 글자만 넣으면? p? k? c? i? a? r?
<br>pika는 YES가 나와야 합니다. 이걸 조금 변형하면? pik? pia? pka? piak? pkia? ipka? kipa? pikaa? pikka? piika? ppika?
<br>kapi도 YES가 나와야 합니다. 이걸 조금 변형하면? kap? kai? api? kaip? kpai? kapii? kaapi?
<br>주어진 예제를 조금 변형하면? pikap? pikpi? pipikach? pipikaphu?
<br>그냥 정말로 아무거나 넣으면? abcd? pipichukachuka? pichaku? ppap? pikach?
<br>입력으로 1 이상 1,000,000 이하의 정수 N이 주어진다면 N=1, N=2 등의 최소 케이스가 잘 나오는지 확인하는 것이 좋습니다.&nbsp;이런 입력이 특이 케이스가 되는 문제들이 종종 있고, 굳이 특이 케이스가 아니더라도 우리의 코드가 최소 케이스에서 틀릴 가능성은 얼마든지 있습니다. 위에서 언급한 "피카츄" 문제의 경우 p, k 등의 한 글자짜리 입력이 여기에 해당되겠죠.
<br>N=1,000,000 같은 최대 케이스를 넣었을 때 주어진 시간 제한 안에 답이 나오는지도 확인해 볼 수 있습니다. 답이 맞는지 확인하는 건 어떨까요? 문제에 따라 답을 손으로 알아내기 힘들 수도 있는데, 적어도 말이 되는 값은 나와야겠죠? 출력이 무조건 0 이상일 수밖에 없는 문제에서 음수가 나오면 뭔가 잘못되었다는 뜻입니다.
<br>매우 간단한 풀이가 있는데 시간복잡도가 너무 커서 못 쓰고, 그 대신 더 효율적인 풀이를 생각해야 하는 문제가 있습니다. 이런 문제는 다음 방법으로도 반례를 찾을 수 있습니다. 매우 간단한 풀이이면 구현하기 쉬워서 틀릴 가능성이 낮다는 점을 이용한 방법입니다.
<br>매우 간단한 풀이를 작성한다.
<br>랜덤으로 데이터를 만든다.
<br>간단한 풀이와 틀린 풀이가 내놓는 답이 일치하는지 검사한다.
<br>2-3번을 반복...
<br><a data-tooltip-position="top" aria-label="http://www.secmem.org/blog/2020/09/19/rte/" rel="noopener" class="external-link" href="http://www.secmem.org/blog/2020/09/19/rte/" target="_blank">PS에서의 런타임 에러와 디버깅 (링크)</a>
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/help-반례-찾기.html</link><guid isPermaLink="false">1. Study/Coding Test/HELP 반례 찾기.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:28:43 GMT</pubDate></item><item><title><![CDATA[HELP: 알고리즘]]></title><description><![CDATA[ 
 <br><br>ID: 0<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/blog/view/70" target="_blank">https://www.acmicpc.net/blog/view/70</a><br>
다시풀기: No<br>
분류: help<br>
생성 일시: 2023년 4월 20일 오후 5:56<br>
<br>배열 기반의 리스트 (C++&nbsp;vector, string,&nbsp;Java&nbsp;ArrayList, String,&nbsp;Python&nbsp;list, str, ...)의 중간에 뭔가를 끼워넣거나 빼는 건 O(N)입니다.
<br>퀵소트를 직접 구현하면 O(N^2)이 걸리는 데이터를 손쉽게 만들 수 있습니다. 그냥 내장된 정렬 함수를 쓰세요. 정렬을 직접 구현하는 것을 연습하시고자 한다면, 피벗을 랜덤으로 잡은 퀵소트를 구현하거나 힙소트, 머지소트 등 다른 O(nlogn) 정렬 알고리즘을 구현하는 방법이 있습니다.
<br>격자에서 탐색할 때 범위 체크를 반드시 합시다.
<br>DP를 할 때에는 메모이제이션을 합시다. 안 그러면 DP가 아닙니다.
<br>DFS는 절대로 최단거리를 구해 주지 않습니다.&nbsp;물론 메모이제이션 없이 모든 경로를 탐색하는 DFS는 최단거리를 구해 주겠지만, 시간 초과가 날 것입니다.
  <img alt="https://imgur.com/6griKbJ.png" src="https://imgur.com/6griKbJ.png" referrerpolicy="no-referrer"><br>

<br>BFS는 큐에서 뺀 다음이 아닌, 큐에 넣을 때 방문 체크를 해야 중복 방문이 일어나지 않습니다.&nbsp;BFS 문제에서 시간 초과나 메모리 초과가 나면 이것부터 의심해 보시면 됩니다.
  <img alt="https://imgur.com/TKsmWih.png" src="https://imgur.com/TKsmWih.png" referrerpolicy="no-referrer"><br>

<br>BFS를 할 때 큐의 크기가 제한되어 있도록 구현했다면, 그 크기는 적어도 방문할 수 있는 정점의 총 개수보다는 크게 합시다.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/help-알고리즘.html</link><guid isPermaLink="false">1. Study/Coding Test/HELP 알고리즘.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:28:18 GMT</pubDate><enclosure url="https://imgur.com/6griKbJ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://imgur.com/6griKbJ.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Help: Python과 Pypy]]></title><description><![CDATA[ 
 <br><br>ID: 0<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/blog/view/70" target="_blank">https://www.acmicpc.net/blog/view/70</a><br>
다시풀기: No<br>
분류: help<br>
생성 일시: 2023년 4월 20일 오후 5:58<br>
<br>BOJ는 numpy 등 외장모듈을 지원하지 않습니다.&nbsp;(사실 모든 언어가 그렇습니다.)
<br>풀이가 분명히 맞고 시간복잡도도 충분히 작은데 시간 초과가 난다면 언어를 Pypy로 설정하고 제출하면 됩니다. 파이썬은 원래 편리성과 속도를 맞바꾼 언어이기 때문에, 맞아야 될 풀이가 시간 초과더라도 이상할 게 전혀 없습니다.
<br>두 수를 입력받고 나서 비교할 때는 반드시 int로 변환을 합시다.&nbsp;문자열의 비교는 사전 순 비교이기 때문에, 3은 10보다 작지만 "3"은 "10"보다 큽니다.
<br>is 키워드는 두 대상의 값이 같은지가 아니라 완전히 같은 대상을 가리키는지를 비교합니다. BOJ에서 이걸 쓸 일은 거의 없습니다.&nbsp;같은 "hello"더라도 따로 정의하면 다른 대상이 됩니다. 이걸 쓰면 디버깅하기도 힘든 게, -5 이상 255 이하의 int는 미리 만들어 놓고 정의할 때마다 가져다 쓰기 때문에, 딱 그 범위까지는 is와 ==가 똑같은 동작을 합니다. 그래서 손으로 반례를 찾으려고 하면 찾아지지 않습니다.
<br>list.pop(0), list.index, list.insert, list.count, x in list, list[:-1]&nbsp;등은 다 O(N)입니다. 이외에도 O(N)이 걸리는 list 연산이 굉장히 많습니다. (len(list)는 O(1))  <a rel="noopener" class="external-link" href="https://wiki.python.org/moin/TimeComplexity" target="_blank">https://wiki.python.org/moin/TimeComplexity</a>
<br>위의 이유로,&nbsp;list를 큐 또는 덱으로 사용하면 절대, 절대, 절대, 절대, 절대 안 됩니다!! 반드시&nbsp;collections.deque를 써야 합니다.
<br>아니요,&nbsp;queue.Queue도 안 됩니다. 이건 멀티스레딩을 위해 만들어진 큐이고 매우 느립니다.
<br>파이썬의 재귀 깊이는 기본적으로 최대 1,000입니다.&nbsp;sys.setrecursionlimit으로 이 깊이를 조절할 수 있습니다.
<br>두 개의 int를 나누면 float이 됩니다.&nbsp;int(a/b)&nbsp;말고&nbsp;a//b를 쓰는 것이 훨씬 안전합니다.&nbsp;맨 위의 "부동소수점 자료형은 나타내는 수의 범위가 넓지만 ..."을 읽어보세요.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/help-python과-pypy.html</link><guid isPermaLink="false">1. Study/Coding Test/Help Python과 Pypy.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:27:11 GMT</pubDate></item><item><title><![CDATA[java 기본]]></title><description><![CDATA[ 
 <br>NAV: <a data-href="1. Study/Coding Test.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test" class="internal-link" target="_self" rel="noopener">1. Study/Coding Test.md</a><br><a data-tooltip-position="top" aria-label="https://nahwasa.com/entry/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B1%EC%A4%80-%ED%92%80-%EB%95%8C%EC%9D%98-%ED%8C%81-%EB%B0%8F-%EC%A3%BC%EC%9D%98%EC%A0%90-boj-java" rel="noopener" class="external-link" href="https://nahwasa.com/entry/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B1%EC%A4%80-%ED%92%80-%EB%95%8C%EC%9D%98-%ED%8C%81-%EB%B0%8F-%EC%A3%BC%EC%9D%98%EC%A0%90-boj-java" target="_blank">자바로 백준 풀 때의 팁 및 주의점 (boj java) - Nahwasa</a>]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/java-기본.html</link><guid isPermaLink="false">1. Study/Coding Test/java 기본.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 14 May 2024 05:29:41 GMT</pubDate></item><item><title><![CDATA[N과 M(1)]]></title><description><![CDATA[ 
 <br><br>ID: 15649<br>
Site: 백준<br>
URL: <a rel="noopener" class="external-link" href="https://www.acmicpc.net/problem/15649" target="_blank">https://www.acmicpc.net/problem/15649</a><br>
난이도: 실버 3<br>
다시풀기: No<br>
생성 일시: 2023년 9월 3일 오후 6:19<br><br><br><br><br>자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.<br>
<br>1부터 N까지&nbsp;자연수 중에서 중복 없이 M개를 고른 수열
<br><br>첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)<br><br>한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.<br>수열은 사전 순으로 증가하는 순서로 출력해야 한다.<br><br>3 1

복사<br><br>1
2
3

복사<br><br>4 2

복사<br><br>1 2
1 3
1 4
2 1
2 3
2 4
3 1
3 2
3 4
4 1
4 2
4 3

복사<br><br>4 4

복사<br><br>1 2 3 4
1 2 4 3
1 3 2 4
1 3 4 2
1 4 2 3
1 4 3 2
2 1 3 4
2 1 4 3
2 3 1 4
2 3 4 1
2 4 1 3
2 4 3 1
3 1 2 4
3 1 4 2
3 2 1 4
3 2 4 1
3 4 1 2
3 4 2 1
4 1 2 3
4 1 3 2
4 2 1 3
4 2 3 1
4 3 1 2
4 3 2 1

복사<br><br>
<br>문제를 만든 사람:&nbsp;<a data-tooltip-position="top" aria-label="https://www.acmicpc.net/user/baekjoon" rel="noopener" class="external-link" href="https://www.acmicpc.net/user/baekjoon" target="_blank">baekjoon</a>
<br><br>
<br>모든 경우의 수 구하기는 BFS → level 1, 2, 3,…
<br>다른말로 backtracking (사용한 node 만나면 뒤로가기) → pop으로 구
<br>복사<br><br>import sys

def n_m():
    def recursive(result):
        for i in range(n):
            if len(result) == m:
                print(" ".join(result))
                break
            if str(i+1) not in result:
                result.append(str(i+1))
                recursive(result)
        if len(result) != 0:
            result.pop()
            return ""

    n, m = map(int, sys.stdin.readline().rstrip().split())
    recursive([])

if __name__ == "__main__":
    n_m()
복사<br><br>from itertools import permutations
N,M = map(int, input().split(' '))
print('\n'.join(list(map(' '.join, permutations(map(str, range(1, N+1)), M)))))
복사<br>
<br>
그냥 조합을 구해주는 함수를 사용해도됨ㅋㅋㅋㅋ

<br>
itertools permutations, combinations 등

<br>
그리고 아, 굳이 result를 안넘겨 줘도 되는 구나… 같은 list 중복해서 쓰는 줄 알았는데, 차피 pop을 하게 되니까 괜찬은 건가?

<br>
아 그리고 잠시만,,, bfs → stack으로 구현가능ㅋㅋㅋㅋㅋ → 아니다 이건 트리라서 좀 다른 거 같음.

<br>n, m = list(map(int, input().split()))
s = []
li=[]
def dfs():
    if len(s) == m:
        li.append(s)
        return
    for i in range(1,n+1):
        if i not in s:
            s.append(i)
            dfs()
            s.pop()
dfs()
print(li)
복사<br>
<br>나는 for문 밖에서 pop을 하니까, 길이가 0일때 생기는 문제가 있었는데, 그냥 (전단계, 레벨로) 돌아와서 바로 pop하면 되는구나..
<br>그리고 프린트 한번에 하기.
]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/n과-m(1).html</link><guid isPermaLink="false">1. Study/Coding Test/N과 M(1).md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Tue, 27 Feb 2024 12:05:30 GMT</pubDate></item><item><title><![CDATA[new]]></title><description><![CDATA[ 
 <br>NAV: <a data-href="1. Study/Coding Test.md" href="https://sunha20.github.io/digital-garden/1. Study/Coding Test" class="internal-link" target="_self" rel="noopener">1. Study/Coding Test.md</a><br><br>전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.<br>
전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.<br>
<br>구조대 : 119
<br>박준영 : 97 674 223
<br>지영석 : 11 9552 4421
<br>전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.<br><br>
<br>phone_book의 길이는 1 이상 1,000,000 이하입니다.

<br>각 전화번호의 길이는 1 이상 20 이하입니다.
<br>같은 전화번호가 중복해서 들어있지 않습니다.


<br><br><br><br>입출력 예 #1<br>
앞에서 설명한 예와 같습니다.<br>입출력 예 #2<br>
한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.<br>입출력 예 #3<br>
첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.<br><br>
<br>
우와 이걸 어떻게 해시로하지?

<br>
length만큼 비교하면 안됨?

<br>
근데 기준점이 없으니까 문제.

<br>
아 그냥 start with…?

<br>
제이 짧은 길이 기준으로 (2면) 2만큼 해시, 3만큼 해시, 4만큼 해시, 쭉쭉해서 같은 거 나오면 false 출력

<br>
오 sort를 할 수도…?

<br>import java.util.Arrays;  
  
public class _42577p {  
    public boolean solution1(String[] phone_book) {  
        int len = 0;  
        int cnt = 0;  
        Arrays.sort(phone_book);  
  
        for (String a_phoneNum : phone_book) {  
            for (String b_phoneNum: phone_book) {  
                if (b_phoneNum.length() &gt; a_phoneNum.length() &amp;&amp; b_phoneNum.startsWith(a_phoneNum))  
                    return false;  
            }  
        };  
        return true;  
    }  
}
복사<br>
<br>효율성 테스트 3,4번 막힘.
<br>아 헐 이게 string으로 sort하면 앞에서 부터 체크해서 사전식 배열이니까, start with 하는게 있으면 바로 뒤겠구나… 와 헐.

<br>접두어 = 정렬 하면 붙어있음.


<br>import java.util.Arrays;  
  
public class _42577p {  
    public boolean solution1(String[] phone_book) {  
        Arrays.sort(phone_book);  
        System.out.println(Arrays.toString(phone_book));  
        for (int i=0; i&lt;phone_book.length-1; i++) {  
            if (phone_book[i+1].startsWith(phone_book[i])) {  
                return false;  
            }  
        };  
        return true;  
    }  
}
복사<br><br>
<br>hash를 쓰는 방법

<br>저는 key 에 전화번호 넣고   썻어요 → TIL에 써보기.


]]></description><link>https://sunha20.github.io/digital-garden/1.-study/coding-test/new.html</link><guid isPermaLink="false">1. Study/Coding Test/new.md</guid><dc:creator><![CDATA[seonha20]]></dc:creator><pubDate>Mon, 20 May 2024 13:43:17 GMT</pubDate></item></channel></rss>