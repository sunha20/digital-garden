{"createdTime":1747968369106,"shownInTree":["dev-blog/jungle/week-2.html","dev-blog/jungle/week-1.html","dev-blog/jungle/jungle.html","dev-blog/dev-blog.html","dev-blog/data-structure-&-algorithm/이분탐색-v.2.html","dev-blog/data-structure-&-algorithm/data-structure-&-algorithm.html","dev-blog/coding-test/9663.-n-queen.html","dev-blog/coding-test/coding-test.html","dev-blog/coding-test/9020.-골드바흐의-추측.html","dev-blog/coding-test/2630.-색종이-자르기.html","dev-blog/coding-test/3190.-뱀.html","dev-blog/coding-test/8983.-사냥꾼.html","dev-blog/coding-test/2628.-종이-자르기.html","dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html","dev-blog/coding-test/2504.-괄호의-값.html","dev-blog/coding-test/1978.-소수-찾기.html","dev-blog/coding-test/2493.-탑.html","dev-blog/coding-test/2470.-두-용액.html","dev-blog/coding-test/2468.-안전지대.html","dev-blog/coding-test/2110.-공유기-설치.html","dev-blog/coding-test/1914.-하노이-탑.html","dev-blog/coding-test/1655.-가운데를-말해요.html","dev-blog/coding-test/10971.-외판원-순회2.html","dev-blog/coding-test/1629.-곱셈.html","dev-blog/coding-test/10830.-행렬-제곱.html","dev-blog/coding-test/10819.-차이를-최대로.html","dev-blog/coding-test/1065.-한수.html","dev-blog/coding-test/1074.-z.html","dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html","dev-blog/csapp/csapp.html","index.html"],"attachments":["site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css","⁵-file/image/pasted-image-20250517110728.png","⁵-file/image/pasted-image-20250517163436.png","⁵-file/image/pasted-image-20250517164101.png","⁵-file/image/pasted-image-20250517170728.png","⁵-file/image/pasted-image-20250517172142.png","⁵-file/image/pasted-image-20250517190742.png","⁵-file/image/pasted-image-20250517193510.png","⁵-file/image/pasted-image-20250517210011.png","site-lib/rss.xml","site-lib/fonts/mathjax_zero.woff","site-lib/fonts/mathjax_main-regular.woff","site-lib/fonts/mathjax_main-bold.woff","site-lib/fonts/mathjax_math-italic.woff","site-lib/fonts/mathjax_main-italic.woff","site-lib/fonts/mathjax_math-bolditalic.woff","site-lib/fonts/mathjax_size1-regular.woff","site-lib/fonts/mathjax_size2-regular.woff","site-lib/fonts/mathjax_size3-regular.woff","site-lib/fonts/mathjax_size4-regular.woff","site-lib/fonts/mathjax_ams-regular.woff","site-lib/fonts/mathjax_calligraphic-regular.woff","site-lib/fonts/mathjax_calligraphic-bold.woff","site-lib/fonts/mathjax_fraktur-regular.woff","site-lib/fonts/mathjax_fraktur-bold.woff","site-lib/fonts/mathjax_sansserif-regular.woff","site-lib/fonts/mathjax_sansserif-bold.woff","site-lib/fonts/mathjax_sansserif-italic.woff","site-lib/fonts/mathjax_script-regular.woff","site-lib/fonts/mathjax_typewriter-regular.woff","site-lib/fonts/mathjax_vector-regular.woff","site-lib/fonts/mathjax_vector-bold.woff","site-lib/scripts/graph-wasm.wasm","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","⁵-file/image/그림2.png","⁵-file/image/그림1-1.png","⁵-file/image/pasted-image-20250523213904.png","⁵-file/image/20250523_195539.jpg","⁵-file/image/pasted-image-20250529171635.png","⁵-file/image/pasted-image-20250529171701.png","⁵-file/image/pasted-image-20250529174514.png"],"allFiles":["dev-blog/coding-test/10830.-행렬-제곱.html","dev-blog/dev-blog.html","dev-blog/coding-test/coding-test.html","dev-blog/jungle/week-2.html","dev-blog/coding-test/2504.-괄호의-값.html","dev-blog/coding-test/8983.-사냥꾼.html","dev-blog/coding-test/1655.-가운데를-말해요.html","dev-blog/coding-test/3190.-뱀.html","dev-blog/coding-test/2493.-탑.html","dev-blog/coding-test/1629.-곱셈.html","dev-blog/coding-test/2630.-색종이-자르기.html","dev-blog/coding-test/2470.-두-용액.html","dev-blog/coding-test/1914.-하노이-탑.html","dev-blog/coding-test/2628.-종이-자르기.html","dev-blog/coding-test/1065.-한수.html","dev-blog/coding-test/9020.-골드바흐의-추측.html","dev-blog/coding-test/1978.-소수-찾기.html","dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html","dev-blog/coding-test/1074.-z.html","dev-blog/coding-test/10819.-차이를-최대로.html","dev-blog/coding-test/9663.-n-queen.html","dev-blog/coding-test/2110.-공유기-설치.html","index.html","dev-blog/data-structure-&-algorithm/이분탐색-v.2.html","dev-blog/csapp/csapp.html","dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html","dev-blog/jungle/week-1.html","dev-blog/jungle/jungle.html","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html","dev-blog/coding-test/10971.-외판원-순회2.html","dev-blog/coding-test/2468.-안전지대.html","dev-blog/data-structure-&-algorithm/data-structure-&-algorithm.html","site-lib/scripts/graph-wasm.wasm","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/fonts/mathjax_zero.woff","site-lib/fonts/mathjax_main-regular.woff","site-lib/fonts/mathjax_main-bold.woff","site-lib/fonts/mathjax_math-italic.woff","site-lib/fonts/mathjax_main-italic.woff","site-lib/fonts/mathjax_math-bolditalic.woff","site-lib/fonts/mathjax_size1-regular.woff","site-lib/fonts/mathjax_size2-regular.woff","site-lib/fonts/mathjax_size3-regular.woff","site-lib/fonts/mathjax_size4-regular.woff","site-lib/fonts/mathjax_ams-regular.woff","site-lib/fonts/mathjax_calligraphic-regular.woff","site-lib/fonts/mathjax_calligraphic-bold.woff","site-lib/fonts/mathjax_fraktur-regular.woff","site-lib/fonts/mathjax_fraktur-bold.woff","site-lib/fonts/mathjax_sansserif-regular.woff","site-lib/fonts/mathjax_sansserif-bold.woff","site-lib/fonts/mathjax_sansserif-italic.woff","site-lib/fonts/mathjax_script-regular.woff","site-lib/fonts/mathjax_typewriter-regular.woff","site-lib/fonts/mathjax_vector-regular.woff","site-lib/fonts/mathjax_vector-bold.woff","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css"],"webpages":{"dev-blog/dev-blog.html":{"title":"Dev Blog","icon":"","description":"<a data-tooltip-position=\"top\" aria-label=\"Dev Blog/new file.md\" data-href=\"Dev Blog/new file.md\" href=\".html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">new file</a> | <a data-tooltip-position=\"top\" aria-label=\"Dev Blog/new folder/new folder.md\" data-href=\"Dev Blog/new folder/new folder.md\" href=\".html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">new folder</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Note","level":3,"id":"Note_0"},{"heading":"File","level":3,"id":"File_0"}],"links":[".html",".html","dev-blog/jungle/jungle.html#_0","dev-blog/coding-test/coding-test.html#_0","dev-blog/csapp/csapp.html#_0","dev-blog/data-structure-&-algorithm/data-structure-&-algorithm.html#_0"],"author":"","coverImageURL":"","fullURL":"dev-blog/dev-blog.html","pathToRoot":"..","attachments":[],"createdTime":1747966599472,"modifiedTime":1748516603708,"sourceSize":501,"sourcePath":"Dev Blog/Dev Blog.md","exportPath":"dev-blog/dev-blog.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html":{"title":"컴퓨터시스템 CH1. 컴퓨터 시스템으로의 여행","icon":"","description":"\n컴퓨터 시스템 = 하드웨어 + 시스템 소프트웨어\n작동하며 응용프로그램을 실행함.\n모든 컴퓨터 시스템은 유사한 기능을 수행하는 유사한 하드웨어와 소프트웨어 컴포넌트를 가지고 있다. 비트: 데이터\n컨텍스트: 해석방법\n⇒ 동일한 비트(데이터)가 컨텍스트에 따라 다르게 해석될 수 있음\n좋은 질문이야! 핵심을 짚었네.\n결론부터 말하자면:\n컨텍스트는 ‘항상 파일 안에 직접 쓰여 있는 건 아니고’, 보통은 ‘외부의 규칙’이나 ‘해석하는 프로그램/환경’이 제공해.\n일부 형식 있는 데이터는 스스로를 설명하기 위해 컨텍스트 정보를 내부에 포함해.\n이럴 땐 컨텍스트가 직접적으로 쓰여 있는 것이 맞아.예시:이런 경우는 컨텍스트가 비트/바이트 안에 포함된 경우라고 볼 수 있어.하지만 대부분의 경우, 비트 그 자체만 봐서는 해석할 수 없고,\n외부 환경, 프로세스, 해석자(program)가 그 의미를 부여해줘.예시:\n.txt 파일의 01000001 → 메모장에서 보면 \"A\"지만, hex editor에선 0x41\n0b1010 → 파이썬 코드에서는 2진수 10이지만, 그냥 텍스트 파일로 보면 단순한 문자열 \"0b1010\"\n메모리 안에 있는 8바이트 → 이걸 double로 볼지, int로 볼지는 CPU나 프로그래머가 결정 즉, 이 경우 컨텍스트는 파일 외부에 있어:\n파일 확장자\n프로그래밍 언어의 문법\n운영체제의 실행 규칙\n사용하는 소프트웨어 🔸 요약\n🔹 컨텍스트는 \"해석 기준\"이다.\n🔹 어떤 데이터는 그 기준을 스스로 안에 담기도 하고,\n🔹 어떤 데이터는 해석하는 주체(사람, 프로그램, OS)가 기준을 제공하기도 해.\n원하는 주제로 더 깊이 들어갈 수 있어! 예를 들어 \"컴파일러가 컨텍스트를 어떻게 이해하는가\", \"바이너리 파일 해석\", \"파이썬 인터프리터의 역할\" 같은 것도 연결해서 설명할 수 있어.\n컴파일 시스템 소스코드(원시코드)를 목적코드로 바꾸는 역할\n전처리기, 컴파일러, 어셈블러, 링커의 4단계를 실행하는 프로그램드을 합쳐서 컴파일 시스템이라고 함.\ne.g., GCC 컴파일러 드라이버: 소스파일 hello.c를 읽어서 실행파일인 hello로 번역. <img src=\"⁵-file/image/pasted-image-20250517110728.png\" target=\"_self\">\n시작 파일: 소스코드(.c) 사용 프로그램: 전처리기(cpp)\n<br>역할: #문자로 시작하는 디렉티브<a data-footref=\"1\" href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fn-1-95c3f254feb9cc1d\" class=\"footnote-link\" target=\"_self\" rel=\"noopener nofollow\">[1]</a>에 따라 파일을 수정 e.g., #includes&lt;studio.h&gt;: 시스템 헤더파일인 studio.h를 프로그램 문장에 직접 삽입하라는 뜻 결과파일: 수정된 소스코드 파일(.i) 사용 프로그램: 컴파일러(cc1)\n역할: 어셈블리어로 파일을 번역 어셈블리어는 기계어와 1:1 대응됨\n상위수준 언어 종류에 상관 없이 동일한 어셈블리어로 출력파일을 생성 결과파일: 어셈블리어 프로그램 파일(.s) 사용 프로그램: 어셈블러(as)\n역할: 어셈블리어 → 기계어 인스트럭션 ⇒ 결과 파일로…\n결과파일: 재배치가능 목적프로그램(.o) \"재배치 가능\"하다는 말은, 이 목적파일(hello.o) 안의 코드나 데이터가 메모리에서 최종적으로 어디에 위치할지 아직 정해지지 않았고, 나중에 자유롭게 위치를 조정할 수 있게 설계되어 있다는 뜻이야.**\n🔹 다시 말해:\n\"파일 자체가 이리저리 옮겨진다\"는 의미도 아니고,\n\"인스트럭션들이 뒤죽박죽 위치 바뀐다\"는 뜻도 아니야.\n대신, 이 의미는 메모리에 올려질 때 \"어디에 위치할 수 있는지 유연하다\"는 뜻이야. 🔹 예시:int main() { return 0;\n}\n이 코드가 컴파일되어 hello.o라는 목적파일이 만들어졌다고 해.\n여기에는 main 함수의 기계어 인스트럭션이 들어 있지만,\n“이 코드가 메모리 주소 0x400000부터 실행된다”는 정보는 아직 없음!\n나중에 링커가 여러 목적파일을 결합할 때, 이 main 함수가 0x400000에 올릴지, 0x500000에 올릴지는 그때 결정함.\n그래서 hello.o 안의 기계어 코드에는 이런 주소가 “심볼”로 남아 있음. (예: main이 아직 어딘지 모르므로 main → 심볼 테이블) 📌 즉, “재배치 가능”하다는 것은 이 목적파일 안의 주소들이 아직 \"결정되지 않았고, 나중에 링커가 마음대로 재배치할 수 있게 만들어진 상태”라는 뜻이야.\n사용 프로그램: 링커(ld)\n역할: 통합작업 이미 컴파일된 별도의 목적파일에 들어있는 심볼(함수, 변수 등)을 사용해야할 경우가 많음 e.g., 외부 함수 사용 이러한 심볼들을 연결하여 하나의 실행파일을 생성 결과파일: 실행 가능 목적파일(실행파일) 프로그램 성능 최적화 switch문은 if-else문을 연속해서 사용하는 것보다 언제나 더 효율적일까?\n함수 호출시 발생하는 오버헤드는 얼마나 되는가?\nwhile 루프는 for 루프보다 더 효율적일까?\n포인터 참조가 배열 인덱스보다 더 효율적인가?\n합계를 지역변수에 저장하면 팜조형태로 넘겨받은 인자를 사용하는 것보다 왜 루프가 더 빨리 실행되는가?\n수식 연산시 괄호를 단수히 재배치하기만 해도 함수가 더 빨리 실행되는 이유는 무엇인가? 링크에서 이해하기 링커아 어떤 참조를 풀어낼 수 없다고 할 때는 무엇을 의마하는가\n정적변수와 전역변수의 차이는 무엇?\n각기 다른 파일에 동일한 이름의 두 개의 전역변수를 정의한다면 무슨일이?\n정적 라이블리와 동적 라이브러리의 차이는?\n컴파일 명령을 쉘에서 입력할 때 명령어 라인의 라이브러리들의 순서는 무슨 의미가 있는가? 보안 약점 피하기 e.g., 버퍼 오버플로우 취약성.\n안전한 프로그래밍의 첫번째 → 스택에 데이터와 제어정보가 저장되는 방식의 영향 이해. 속도 빠른 순\n[CPU] └─ 레지스터 └─ 캐시 (L1 → L2 → L3)\n[메모리 계층] └─ RAM (주기억장치) └─ 버퍼 (I/O 대기용) └─ 디스크 (SSD/HDD 등)\n[외부저장소] └─ USB, 외장하드, 클라우드 저장소 CLI(Command-Line Interface) 사용자가 명령어를 입력해 컴퓨터와 상호작용하는 방식\nUI 방식 중 하나로 GUI(마우스, 버튼 등)와 반대 shell 사용자가 CLI를 쓸 수 있도록 운영체제와 사용자 사이를 중계하는 프로그램\n통역가와 같은 역할을함\n입력받는 명령어는 내장 쉘명령어 또는 실행파일의 이름임. 운영체제 명령을 실제 수행하는 주체 시스템 내를 과농하는 전기적 배선군\n컴포넌트들 간에 바이트 정보를 전송\n전송하는 정보는 word라는 고정 크기를 가짐\n→ 대개 4 bytes (32 bits) 나 8 bytes (64 bits) 시스템과 외부세계와의 연결을 담당.\ne.g., 키보드, 마우스, 출력용 디스플레이, 외부 디스크 드라이브\n<br>각 입출력 장치는 입출력 버스 + (컨트롤러 or 어댑터)를 통해 연결됨<a data-footref=\"2\" href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fn-2-95c3f254feb9cc1d\" class=\"footnote-link\" target=\"_self\" rel=\"noopener nofollow\">[2]</a> 컨트롤러: 디바이스 자체가 칩셋이거나 시스템의 인쇄기판에 장착\n어댑터: 마더보드의 슬롯에 장착되는 카드 프로세서가 프로그램을 실행하는 동안 데이터와 프로그램을 모두 저장하는 임시 저장장치\n물리적: DRAM칩들로 구성\n논리적: 연속적인 바이트들의 배열 → 각 byte들은 고유의 주소를 가짐.\n<br><a data-tooltip-position=\"top\" aria-label=\"https://computing-jhson.tistory.com/21\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://computing-jhson.tistory.com/21\" target=\"_self\">RAM 메모리 : DRAM vs SRAM</a>\nRAM: 어떤 메모리 주소에 접근(random access)하더라도 동일한 시간의 읽고 쓰기가 보장되어서 random access memory라고 부름 cf) 하드디스크 vs RAM 데이터 주소에 따라 접근 시간이 다름 → 헤드라는 장치를 이용해 플래터라는 원판에 데이터를 읽고 쓰는데, 플래터를 돌려 헤드를 해당주소로 옮겨야함. → 헤드 위치에 따라 접근 시간 달라짐.\nRAM은 전기를 저장하는 cell들의 배열(반도체 회로)로 구성→ cell의 전압정보를 읽어오는데 동일한 시간 소요 비용: SRAM &gt; DRAM\n속도: SRAM &gt; DRAM\n⇒ 메인메모리: DRAM = 주처리장치(CPU)\n메인 메모리에 저장된 인스트럭션들을 해독 및 실행하는 엔진\n프로그램 카운터(PC) 메인 메모리의 기계어 인스트럭션의 주솟값을 가짐\nWord크기의 저장장치임. → register내에 존재하기도 함. 프로세서는 프로그램 카운터가 가리키는 인스트럭션을 실행하고 PC값은 다음 인스트럭션의 위치로 값을 업데이트하는 행위를 반복함. 인스트럭션 실행: 메모리로부터 인스트럭션 읽어오기(Fetch)\n인스트럭션 해석하기(Decode)\n인스트럭션 실행하기(Execute) 인스트럭션 예시: 적재(Load): 메인 메모리 → 레지스터\n저장(Store): 레지스터 → 메인 메모리\n작업(Operate): 두 레지스터 값 가지고 ALU에서 연산을 수행하고 결과 값을 저장(덮어쓰기)\n점프(Jump): 인스트럭션 자신으로부터 한 개의 워드를 추출 하고 이것을 PC에 덮어쓰기함. <br><img src=\"⁵-file/image/pasted-image-20250517163436.png\" target=\"_self\">\n원인1. 데이터 복사 및 이동에 많은 시간이 소요 → 실제 작업 속도를 저해 빠른 복사와 빠른 이동이 중요해짐 원인2. 프로세서의 속도 향상이 메모리의 속도 향상보다 더 쉽고 더 쌈. 프로세서와 메모리 간의 속도 격차가 발생 “캐시”: 작으면서 빠른 캐시 메모리를 고안 단기간에 프로세서에서 사용할 가능성이 높은 데이터들을 임시 저장해둠.\n<br><a class=\"internal-link\" data-href=\"컴퓨터시스템 CH1. 컴퓨터 시스템으로의 여행.md#✅RAM\" href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#✅RAM\" target=\"_self\" rel=\"noopener nofollow\">SRAM</a>을 사용 <br><img src=\"⁵-file/image/pasted-image-20250517164101.png\" target=\"_self\">\n주요 아이디어는 한 레벨의 저장장치가 다음 하위레벨 저장장치의 캐시 역할을 한다는 것\n<br><img alt=\"Pasted image 20250517170728.png\" src=\"⁵-file/image/pasted-image-20250517170728.png\" style=\"width: 530px; max-width: 100%;\" target=\"_self\">\n운영체제: 하드웨어와 소프트 웨어 사이에 위치한 소프트웨어 계층\n응용프로그램이 하드웨어를 사용하려면 무조건 운영체제를 거쳐야함 Why? 제멋대로 동작하는 응용프로그램들이 하드웨어를 잘못사용하는 것을 방지 <br>메모리 주소를 잘못 참조하면 → 다른 프로그램 메모리를 침범할 수 있어<a data-footref=\"3\" href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fn-3-95c3f254feb9cc1d\" class=\"footnote-link\" target=\"_self\" rel=\"noopener nofollow\">[3]</a>\n프린터를 동시에 여러 앱이 사용하면 → 출력 충돌이 날 수 있어\n저장장치를 잘못 쓰면 → 파일 손상 발생\nCPU를 혼자 다 쓰는 프로그램이 있으면 → 다른 프로그램이 멈춤 단순하고 균일한 매커니즘을 사용하여 복잡하고 매우 다른 저수준 하드웨어 장치들을 조작할 수 있도록 하기위해 종류, 제조사마다 모두 동작 방식이 다 달라\n이걸 응용프로그램이 직접 처리해야 한다면? → 너무 복잡하고 오류 많음\ne.g., 파일을 읽고싶으면, 해당파일을 그냥 지정해주면 됨. 그 파일이 SDD에 있든, USB에 있든 상관 없음 위의 목적을 추상화를 통해 달성 → 맘대로 접근하지 못하게 숨겨놓음\n추상화 형태 <br><img src=\"⁵-file/image/pasted-image-20250517172142.png\" target=\"_self\">\n파일: 입출력 장치의 추상화\n가상 메모리: 메인메모리와 입출력 장치의 추상화\n프로세스: 프로세서, 메인메모리, 입출력장치 전체의 추상화 <br>\n환상 → 한개의 프로그램만 실행되는 것 같고, 그 프로그램이 모든 시스템<a data-footref=\"4\" href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fn-4-95c3f254feb9cc1d\" class=\"footnote-link\" target=\"_self\" rel=\"noopener nofollow\">[4]</a> 자원을 독차지 하는 것처럼 보임 ⇒ 프로세스라는 개념을 통해 가능 프로그램: 정적인 코드. 디스크에 저장된 실행파일 프로세스: 실행 중인 프로그램의 인스턴스. 여러 자원을 사용중 프로세스라는 객체는 실행되는 데 필요한 모든 상태정보(컨텍스트)를 가지고, 그 변화를 추적함 단일 프로세서의 경우, 한 순간에 한개의 프로세스 코드만 실행 할 수있음\n문맥전환: os가 현재 프로세스에서 다른 프로세스로 제어를 옮기려고 할 때, 현재 프로세스의 컨텍스트를 저장하고 새프로세스의 컨텍스트를 복원시키는 방법\n문맥의 전환을 통해 프로세스는 중단된 그 상태에서부터 다시 실행될 수 있음. 프로세스A: 쉘\n프로세스B: hello 프로세스\n<br><img src=\"⁵-file/image/pasted-image-20250517190742.png\" target=\"_self\">\n각각의 제어권이 이동함\n<br>운영체제(커널)로 제어권을 넘겨줄 때는 시스템 콜<a data-footref=\"5\" href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fn-5-95c3f254feb9cc1d\" class=\"footnote-link\" target=\"_self\" rel=\"noopener nofollow\">[5]</a>을 이용\n커널모드에서는 종료된 프로세스의 상태를 저장하고 실행할 프로세스를 선택 후 사용자 모드로 전환함\ndisk interrupt: 디스크에서 메모리로 전송됐음을 의미 커널은 별도의 프로세스가 아니다\n프로세스를 관리하는 운영체제에 속한 별도의 코드임\n이러한 커널이 실행되려면 시스템 콜이 발생하거나\n키보드 입력과 같은 인터럽트가 발생하거나\n프로세스 스케줄링이 필요한 경우 등 → 커널의 실행은 프로세스 전환이 아니라, 모드 전환이자 제어권의 위임임. 프로세스를 구성하는 다수의 실행 유닛\n쓰레드는 해당하는 프로세스의 컨텍스트에서 실행되며 동일한 코드와 전역데이터를 공유함. → 다수의 프로세스들보다 공유가 더 쉽다 +) CPU는 항상 스레드 단위로 실행하고 스레드 간의 전환이 일어나는데, 그게 같은 프호세스 안의 스레드라면 가벼운 전환, 다른 프로세스의 스레드라면 문맥 전환이 되는 것임.\n<br><img alt=\"Pasted image 20250517193510.png\" src=\"⁵-file/image/pasted-image-20250517193510.png\" style=\"width: 340px; max-width: 100%;\" target=\"_self\">\n각 프로세스들이 메인 메모리 전체를 독점적으로 사용하고 있는 것같은 환상을 제공하는 추상화\n각 프로세스는 가상 주소 공간이라고 하는 균일한 메모리의 모습을 가짐.\n운영체제가 이 가상 주소공간을 실제 저장 위치(RAM, Disk)와 매핑해줌\n구성 프로그램 코드/데이터: 코드: 모든 프로세스들이 같은 가상 주소에서 시작함.\n데이터: 코드 다음에 전역변수와 정적변수들이 저장됨 cf) 지역변수: 스택\ncf) 동적 할당 변수: 힙 힙 동적으로 크기가 변화함.\n실행 중 동적으로 생성된 데이터가 저장되는 공간 공유라이브러리 중간정도 위치\n표준 라이브러리나 수학 라이브러리같은 공유라이브러리의 코드와 데이터 스택 맨위에 위치\n컴파일러가 함수 초룩을 구현하기 위해 사용하는 공간\n동적으로 크기 변화 커널 가상메모리 가장 윗부분\n커널을 위해 예약된 공간\n응용프로그램이 읽고 쓸 수 없으며 호출도 금지됨. 모든 I/O 자원을 추상화한 공통 인터페이스\n단순히 연속된 바이트들을 의미함\n모든 입출력은 파일을 읽고 쓰는 형태로 이루어짐 → 유닉스 I/O라는 시스템 콜들을 이용. 개별시스템의 관점에서 네트워크는 단지 또다른 입출력 장치로 볼 수 있다. 이메일, 메신저, 웹 페이지, FTP, telnet → 네트워크를 통해 정보를 복사하는 기능 이용 실행 예시 telnet 클라이언트, “hello” 입력하고 엔터\n클라이언트 프로그램, 입력값을 네트워크를 거쳐 telnet 서버로 보냄\ntelnet 서버, 네트워크에서 문자열 받아서 원격 쉘프로그램에 전달\n원격 쉘, hello 프로그램 실행 후 출력을 서버로 전달\ntelnet 서버, 네트워크를 거쳐 출력 스트링을 telnet 클라이언트로 전달\ntelnet 클라이언트 프로그램, 출력 스트링을 로컬 터미널에 표시 한 시스템의 일부분의 성능을 개선할 때, 전체 시스템 성능에 대한 효과는 그 부분이 얼마나 중요한가와 이부분이 얼마나 빨라졌는가에 관계됨\n전체 시스템을 상당히 빠르게 하기 위해서는 전체 시스템의 매우 큰 부분의 성능을 개선해야한다.\n그 성능을 무시할 수 있을 정도의 시간이 걸리는 지점까지 속도를 올려도 두드러지는 성능개선이 되지 않을 수도 있다.\n⇒ 생각보다 성능 개선이 어렵다. 컴퓨터 발전의 큰 2가지 요구: 더 많은 일, 더 빠른 실행 ⇒ 프로세서가 한번에 더 많은 일을 할 때 개선\n동시성: 다수의 동시에 벌어지는 일을 갖은 시스템에 관한 일반적인 개념\n병렬성: 동시성을 사용해서 시스템을 보다 빠르게 동작하도록 하는 것 → 컴퓨터 시스템의 다양한 수준의 추상화에 활용 가능 한 개의 프로세스 내에서 실행되는 다수의 제어 흐름을 가질 수 있음. 초기: 시분할(시간 공유)을 기반으로한 시뮬레이션 형태 ⇒ 단일 프로세서 시스템 한 개의 컴퓨터가 실행하는 프로세스를 빠르게 전환하는 방법\n다수의 사용자들이 한 시스템과 동시 교신 가능 예시: 3명의 사용자가 SSH로 접속 중 사용자 A가 명령어 입력 중\n사용자 B가 코드를 컴파일 중\n사용자 C가 파일 다운로드 중\n→ OS는 이들의 프로세스를 빠르게 교체하며 CPU를 돌려줌\n→ 사용자 입장에선 “내 프로그램이 계속 실행 중”처럼 보임\n→ 실제로는 CPU가 순차적으로 처리 중 한 명의 사용자가 다수의 태스크에 동시에 연관 가능 IDE(통합 개발 환경) 같은 프로그램은 동시에: 코드 작성\n실시간 오류 검사\n백그라운드 저장\n자동 완성\n을 실행 중인데,\n→ 이건 내부적으로 여러 스레드로 분리돼서 동시에 실행되는 것처럼 보이는 것이야\n운영체제가 각 스레드를 빠르게 전환하며 실행함으로써\n→ 사용자는 “다중 작업을 동시에 하고 있다”고 인식하게 돼 멀티 프로세서 시스템 여러개의 프로세서를 가지고 하나의 웅영체제 제어하에 동작하는 경우\n멀티 코어 <br><img alt=\"Pasted image 20250517210011.png\" src=\"⁵-file/image/pasted-image-20250517210011.png\" style=\"width: 300px; max-width: 100%;\" target=\"_self\">\n여러개의 CPU를 하나의 집적화된 칩에 내장. 멀티 쓰레드(하이퍼 쓰레드) 하나의 CPU가 여러개의 제어흐름을 실행할 수 있게 해주는 기술\n프로그램 카운터나 레지스터 파일 등 → 여러개\n다른 부분 (e.g., 부동소수 연산기) → 한 개\n기존에 쓰레드 간의 전환에 드는 시간이 약 2만 클럭사이클이었다면, 매싸이클마다 실행할 쓰레드를 결정할 수 있게됨. 다수의 태스크를 실행할 때, 동시성 시뮬레이션할 필요를 줄여줌 이제 CPU가 여러개라 동시에 처리할 수 있으니, 동시성처럼 보이게 시뮬레이션 할 필요가 없음 멀티 코어를 쓴다고 모든 프로그램이 빨라지는 것은 아님. 프로그램이 멀티 스레드 구조여야 병렬처리로 속도가 빨라질 수 있음. 멀티 코어: 여러 프로그램을 동시에 실행\n멀티 쓰레드: 하나의 프로그램을 병렬 처리. 여러개의 인스트럭션을 한번에 실행할 수 있음\n파이프라이닝 기법, 슈퍼스케일러 프로세서 등이 여기에 해당. 한개의 인스트럭션이 병렬로 다수의 연산을 수행할 수 있는 특수 하드웨어.\n영상, 소리, 동영상 데이터 처리 및 머신러닝 분야에서 많이 사용됨.\n(여러 개의 연산을 숨기고, 사용자에겐 “하나의 명령처럼 보이게” 만드는 추상화) ISA: 실제 프로세서 하드웨어의 추상화\n마치 한번에 하나의 인스트럭션을 실행하는 프로세서인 것처럼 보이게 함.\n실제로는 파이프라이닝, out-of-order, 분기 예측, 병렬 유닛 등 뭐가 많지만, 신경 쓰지 않아도됨 가상머신 운영체제, 프로세서, 프로그램 모두를 포함하는 컴퓨터 전체의 추상화를 제공.\n하드웨어가 실제로 존재하지 않아도 있는 것처럼 \"흉내 내는\" 소프트웨어 컴퓨터\n운영체제, CPU, 메모리, 저장공간, 프로그램 실행 환경까지 모두 가짜로 만든 컴퓨터 환경 <br>C언어에서 디렉티브는&nbsp;컴파일러에게 지시를 내리기 위해 사용하는 전처리 지시문을 의미함<a href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fnref-1-95c3f254feb9cc1d\" class=\"footnote-backref footnote-link\" target=\"_self\" rel=\"noopener nofollow\">↩︎</a>\n<br>이해 다 못함.<a href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fnref-2-95c3f254feb9cc1d\" class=\"footnote-backref footnote-link\" target=\"_self\" rel=\"noopener nofollow\">↩︎</a>\nQ: 실행파일(=목적코드) 안에 메모리 주소가 이미 써 있는데, 실행 중에 “주소를 잘못 참조한다”는 건 그럼 무슨 뜻?<br>\nA:실행파일에 들어 있는 주소는 보통 \"가상 주소(virtual address)\"이고, 이걸 실제 메모리 주소로 매핑(mapping)해주는 건 운영체제(OS)야<a href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fnref-3-95c3f254feb9cc1d\" class=\"footnote-backref footnote-link\" target=\"_self\" rel=\"noopener nofollow\">↩︎</a>\n<br>컴퓨터 전체 환경<a href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fnref-4-95c3f254feb9cc1d\" class=\"footnote-backref footnote-link\" target=\"_self\" rel=\"noopener nofollow\">↩︎</a>\n<br>사용자 프로그램이 운영체제의 기능을 요청할 때 사용하는 인터페이스.<a href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fnref-5-95c3f254feb9cc1d\" class=\"footnote-backref footnote-link\" target=\"_self\" rel=\"noopener nofollow\">↩︎</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"컴퓨터시스템 CH1. 컴퓨터 시스템으로의 여행","level":1,"id":"컴퓨터시스템 CH1. 컴퓨터 시스템으로의 여행"},{"heading":"컴퓨터 시스템으로의 여행","level":2,"id":"컴퓨터_시스템으로의_여행"},{"heading":"1.1 정보는 비트와 컨텍스트로 이루어진다.","level":3,"id":"1.1_정보는_비트와_컨텍스트로_이루어진다."},{"heading":"✅ 컨텍스트는 어디에서 주어지는 것인가?","level":5,"id":"✅_컨텍스트는_어디에서_주어지는_것인가?"},{"heading":"✅ 1. 컨텍스트가 파일 안에 명시적으로 있는 경우","level":6,"id":"✅_1._**컨텍스트가__파일_안에_명시적으로__있는_경우**"},{"heading":"✅ 2. 컨텍스트가 외부에서 주어지는 경우","level":6,"id":"✅_2._**컨텍스트가__외부에서_주어지는__경우**"},{"heading":"🧠 정리하자면","level":6,"id":"🧠_정리하자면"},{"heading":"1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다.","level":3,"id":"1.2_프로그램은_다른_프로그램에_의해_다른_형태로_번역된다."},{"heading":"각 단계","level":4,"id":"각_단계"},{"heading":"전처리 단계","level":5,"id":"전처리_단계"},{"heading":"컴파일 단계","level":5,"id":"컴파일_단계"},{"heading":"어셈블리 단계","level":5,"id":"어셈블리_단계"},{"heading":"✅ 1. ‘재배치 가능 목적 프로그램’에서 ‘재배치’란?","level":6,"id":"✅_1._‘재배치_가능_목적_프로그램’에서_‘재배치’란?"},{"heading":"링크 단계","level":5,"id":"링크_단계"},{"heading":"메모리 적재 후 실행","level":5,"id":"메모리_적재_후_실행"},{"heading":"1.3 컴파일 시스템 이해가 중요한 이유","level":3,"id":"1.3_컴파일_시스템_이해가_중요한_이유"},{"heading":"✅ 기억장치","level":3,"id":"✅_기억장치"},{"heading":"1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.","level":3,"id":"1.4_프로세서는_메모리에_저장된_인스트럭션을_읽고_해석한다."},{"heading":"✅ 쉘과 CLI","level":4,"id":"✅_쉘과_CLI"},{"heading":"하드웨어 구성 요소","level":4,"id":"하드웨어_구성_요소"},{"heading":"Bus","level":5,"id":"Bus"},{"heading":"입출력 장치","level":5,"id":"입출력_장치"},{"heading":"메인 메모리","level":5,"id":"메인_메모리"},{"heading":"✅RAM","level":6,"id":"✅RAM"},{"heading":"프로세서","level":5,"id":"프로세서"},{"heading":"프로그램 실행 개괄 → hello 프로그램 실행","level":4,"id":"프로그램_실행_개괄_→_hello_프로그램_실행"},{"heading":"1.5 캐시가 중요하다","level":3,"id":"1.5_캐시가_중요하다"},{"heading":"1.6 저장장치들은 계층구조를 이룬다","level":3,"id":"1.6_저장장치들은_계층구조를_이룬다"},{"heading":"1.7 운영체제는 하드웨어를 관리한다.","level":3,"id":"1.7_운영체제는_하드웨어를_관리한다."},{"heading":"추상화","level":4,"id":"추상화"},{"heading":"프로세스","level":5,"id":"프로세스"},{"heading":"작동 방식: 문맥 전환(Context Switching)","level":6,"id":"작동_방식_**문맥_전환**(Context_Switching)"},{"heading":"작동 예시","level":6,"id":"작동_예시"},{"heading":"커널","level":6,"id":"커널"},{"heading":"쓰레드","level":5,"id":"쓰레드"},{"heading":"가상메모리","level":5,"id":"가상메모리"},{"heading":"파일","level":5,"id":"파일"},{"heading":"1.8 시스템은 네트워크를 통해 다른 시스템과 통신한다","level":3,"id":"1.8_시스템은_네트워크를_통해_다른_시스템과_통신한다"},{"heading":"1.9 중요한 주제들","level":3,"id":"1.9_중요한_주제들"},{"heading":"Amdahl의 법칙","level":4,"id":"Amdahl의_법칙"},{"heading":"동시성과 병렬성","level":4,"id":"동시성과_병렬성"},{"heading":"쓰레드 수준 동시성","level":5,"id":"쓰레드_수준_동시성"},{"heading":"인스트럭션 수준 병렬성","level":5,"id":"인스트럭션_수준_병렬성"},{"heading":"싱글 인스트럭션, 다중 데이터 병렬성(SIMD)","level":5,"id":"싱글_인스트럭션,_다중_데이터_병렬성(SIMD)"},{"heading":"추가적인 추상화","level":4,"id":"추가적인_추상화"}],"links":["dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fn-1-95c3f254feb9cc1d","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fn-2-95c3f254feb9cc1d","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#✅RAM","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fn-3-95c3f254feb9cc1d","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fn-4-95c3f254feb9cc1d","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fn-5-95c3f254feb9cc1d","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fnref-1-95c3f254feb9cc1d","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fnref-2-95c3f254feb9cc1d","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fnref-3-95c3f254feb9cc1d","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fnref-4-95c3f254feb9cc1d","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#fnref-5-95c3f254feb9cc1d"],"author":"","coverImageURL":"","fullURL":"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html","pathToRoot":"../..","attachments":["⁵-file/image/pasted-image-20250517110728.png","⁵-file/image/pasted-image-20250517163436.png","⁵-file/image/pasted-image-20250517164101.png","⁵-file/image/pasted-image-20250517170728.png","⁵-file/image/pasted-image-20250517172142.png","⁵-file/image/pasted-image-20250517190742.png","⁵-file/image/pasted-image-20250517193510.png","⁵-file/image/pasted-image-20250517210011.png"],"createdTime":1747966660132,"modifiedTime":1747967655090,"sourceSize":27451,"sourcePath":"Dev Blog/CSAPP/컴퓨터시스템 CH1. 컴퓨터 시스템으로의 여행.md","exportPath":"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/csapp/csapp.html":{"title":"CSAPP","icon":"","description":"<a data-tooltip-position=\"top\" aria-label=\"Dev Blog/CSAPP/new file.md\" data-href=\"Dev Blog/CSAPP/new file.md\" href=\".html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">new file</a> | <a data-tooltip-position=\"top\" aria-label=\"Dev Blog/CSAPP/new folder/new folder.md\" data-href=\"Dev Blog/CSAPP/new folder/new folder.md\" href=\".html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">new folder</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Note","level":3,"id":"Note_0"},{"heading":"File","level":3,"id":"File_0"}],"links":[".html",".html","dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#_0","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html#_0"],"author":"","coverImageURL":"","fullURL":"dev-blog/csapp/csapp.html","pathToRoot":"../..","attachments":[],"createdTime":1747966729672,"modifiedTime":1748508555827,"sourceSize":434,"sourcePath":"Dev Blog/CSAPP/CSAPP.md","exportPath":"dev-blog/csapp/csapp.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/10819.-차이를-최대로.html":{"title":"10819. 차이를 최대로","icon":"","description":"N개의 정수로 이루어진 배열 A가 주어진다. 이때, 배열에 들어있는 정수의 순서를 적절히 바꿔서 다음 식의 최댓값을 구하는 프로그램을 작성하시오.|A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]|첫째 줄에 N (3 ≤ N ≤ 8)이 주어진다. 둘째 줄에는 배열 A에 들어있는 정수가 주어진다. 배열에 들어있는 정수는 -100보다 크거나 같고, 100보다 작거나 같다.첫째 줄에 배열에 들어있는 수의 순서를 적절히 바꿔서 얻을 수 있는&nbsp;식의 최댓값을 출력한다.제일 어려웠던 문제 중에 하나.from itertools import permutations N = int(input()) numList = list(map(int, input().split(\" \"))) max = 0 # 순열 구하기 for per in permutations(numList, N): total = 0 for i in range(N-1): total += abs(per[i] - per[i+1]) if total &gt; max: max = total print(max) 리스트의 모든 값을 사용하는 순열 전부를 구해서(for per in permutations(numList, N):)\n각 순열 별로 문제에서 주워진 수식을 계산한 후 max값을 찾음.\n# 입력 받기\nn = int(input())\nnumbers = list(map(int, input().split())) # 정렬\nnumbers.sort() # 차이의 합 계산\nans = 0\nmid = n // 2 # 절반씩 번갈아 계산\nfor i in range(mid): ans += numbers[n - i - 1] - numbers[i] # 총합의 두 배\nans *= 2 # 중앙 값 처리 (홀수/짝수 구분)\nif n % 2 == 1: ans -= min(numbers[mid] - numbers[mid - 1], numbers[mid + 1] - numbers[mid])\nelse: ans -= numbers[mid] - numbers[mid - 1] # 결과 출력\nprint(ans)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"},{"heading":"입력","level":4,"id":"입력_0"},{"heading":"출력","level":4,"id":"출력_0"},{"heading":"풀이","level":3,"id":"풀이_0"},{"heading":"완전탐색으로 풀기","level":4,"id":"완전탐색으로_풀기_0"},{"heading":"내가 원래 풀고 싶었던 풀이","level":4,"id":"내가_원래_풀고_싶었던_풀이_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/10819.-차이를-최대로.html","pathToRoot":"../..","attachments":[],"createdTime":1747967132371,"modifiedTime":1748516250615,"sourceSize":2064,"sourcePath":"Dev Blog/Coding Test/10819. 차이를 최대로.md","exportPath":"dev-blog/coding-test/10819.-차이를-최대로.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/1074.-z.html":{"title":"1074. Z","icon":"","description":"한수는 크기가 2N&nbsp;× 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.<img alt=\"\" src=\"https://u.acmicpc.net/21c73b56-5a91-43aa-b71f-9b74925c0adc/Screen%20Shot%202020-12-02%20at%208.09.46%20AM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"width: 200px; max-width: 100%;\">N &gt; 1인 경우, 배열을 크기가 2N-1&nbsp;× 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.다음 예는 22&nbsp;× 22&nbsp;크기의 배열을 방문한 순서이다.<br><img alt=\"\" src=\"https://u.acmicpc.net/adc7cfae-e84d-4d5c-af8e-ee011f8fff8f/Screen%20Shot%202020-12-02%20at%208.11.17%20AM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"width: 300px; max-width: 100%;\">N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.다음은 N=3일 때의 예이다.<br><img alt=\"\" src=\"https://u.acmicpc.net/d3e84bb7-9424-4764-ad3a-811e7fcbd53f/Screen%20Shot%202020-12-30%20at%2010.50.47%20PM.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"width: 350px; max-width: 100%;\">첫째 줄에 정수 N, r, c가 주어진다.r행 c열을 몇 번째로 방문했는지 출력한다.\n1 ≤ N ≤ 15\n0 ≤ r, c &lt; 2N\ndef Z(n, r, c): global cnt if r == R and c == C: print(cnt) exit() if n == 0: cnt += 1 return i = 2**(n-1) Z(n-1, r, c) Z(n-1, r, c+i) Z(n-1, r+i, c) Z(n-1, r+i, c+i) return N, R, C = map(int, input().split()) # 2의 N승 cnt = 0 Z(N, 0, 0) Z(n, r, c)의 역할: 위치 (r,c)에 도달할 때까지, 주어진 정사각형을 4칸으로 쪼개며 Z모양으로 방문함. 전역변수 cnt: 이동 횟수 매개 변수 n: 정사각형 한 변의 길이가 2^n일 때 이 n의 값\nr, c: 목적지 좌표 내부 동작 만일 좌표에 도달했으면(if r == R and c == C: ), 지금까지 누적된 이동 횟수(cnt)를 출력하고 프로그램 종료(exit() )\n만일 영역이 다 쪼개져서 1칸 (1x1)에 도달하면, 그 위치로 이동한 것이기 때문에, cnt += 1을 하고 return\n다 아니라면, 영역을 4분의 1로 쪼개서 다시 Z함수 호출 각 변 길이 2^n의 n값은 1이 줄어들어야함 (ex. 4였던 것이 2가 되어야함.)\n호출 순서는 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래 순이다. n == 0까지 가는 게 아니라, n == 1로 뭉뚱그리고 그 중에서 r,c의 위치를 체크(checkRC(r,c))해서 값을 더해주는 방법으로 하면 어떨까?\ndef Z(n, r, c): global cnt if n == 1: if R-1&lt;=r&lt;=R and C-1&lt;=c&lt;=C: print(cnt + checkRC(r,c)) exit() else: cnt += 4 return i = 2**(n-1) Z(n-1, r, c) Z(n-1, r, c+i) Z(n-1, r+i, c) Z(n-1, r+i, c+i) return def checkRC(r, c): if r == R and c == C: return 0 elif r == R and c == C+1: return 1 elif r == R+1 and c == C: return 2 else: return 3 N, R, C = map(int, input().split()) # 2의 N승 cnt = 0 Z(N, 0, 0)\ndef Z(n, r, c): global cnt if r == R and c == C: print(cnt) exit() i = 2 ** (n-1) haveRC(n-1, r, c) # 1사분면 haveRC(n-1, r, c+i) # 2사분면 haveRC(n-1, r+i, c) # 3사분면 haveRC(n-1, r+i, c+i) # 4사분면 return def haveRC(n, r, c): # 해당 범위에 target이 있는지 없는지 global cnt i = 2**n if (r &lt;= R &lt; r+i) and (c &lt;= C &lt; c+i): # 있으면 탐색 Z(n, r, c) else: cnt += (i*i) # 없으면 해당 범위 넓이 만큼 더함 N, R, C = map(int, input().split()) cnt = 0 Z(N, 0, 0) Z(n, r, c)의 역할: 위치 (r,c)에 도달할 때까지, 주어진 정사각형을 4칸으로 쪼개며 Z모양으로 방문함. → +) 직접 방문하는 게 아니라 이동 횟수만 카운트해서 더하는 방식으로 수정 (r, c)가 속하지 않은 영역의 경우 이동 횟수만 카운트\n(r, c)가 속한 영역의 경우 원래처럼 탐색하기. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"},{"heading":"입력","level":4,"id":"입력_0"},{"heading":"출력","level":4,"id":"출력_0"},{"heading":"제한","level":4,"id":"제한_0"},{"heading":"풀이","level":3,"id":"풀이_0"},{"heading":"실패: 시간 초과","level":4,"id":"실패_시간_초과_0"},{"heading":"시간 초과 해결 아이디어 1 → 실패","level":4,"id":"시간_초과_해결_아이디어_1_→_실패_0"},{"heading":"성공","level":4,"id":"성공_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/1074.-z.html","pathToRoot":"../..","attachments":[],"createdTime":1747967448873,"modifiedTime":1748516251654,"sourceSize":4722,"sourcePath":"Dev Blog/Coding Test/1074. Z.md","exportPath":"dev-blog/coding-test/1074.-z.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/9663.-n-queen.html":{"title":"9663. N-Queen","icon":"","description":"N-Queen 문제는&nbsp;크기가 N × N인 체스판 위에 퀸 N개를&nbsp;서로 공격할 수 없게 놓는&nbsp;문제이다.N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15)첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는&nbsp;경우의 수를 출력한다.def n_queen(x, y): # 부분1 if checkY[y] == 1: return 0 if (addList[x+y] == 1): return 0 if (minusList[x-y+N] == 1): return 0 # 부분 2 cnt = 0 queens[x][y] = 1 checkY[y] = 1 addList[x+y] = 1 minusList[x-y+N] = 1 # 부분 3 if x == N-1: addList[x + y] = 0 minusList[x - y + N] = 0 checkY[y] = 0 queens[x][y] = 0 return 1 # 부분 4 for i in range(N): cnt += n_queen(x+1, i) # 부분 5 checkY[y] = 0 addList[x + y] = 0 minusList[x - y + N] = 0 queens[x][y] = 0 return cnt N = int(input()) queens = [[0 for _ in range(N)] for _ in range(N)] checkY = [0 for _ in range(N)] addList = [0 for _ in range(2*N)] minusList = [0 for _ in range(2*N)] sum = 0 for y in range(N): sum += n_queen(0,y) print(sum) n_queen(x, y): 주어진 x, y값에 queen을 놓을 수 있는 지 없는 지를 판별하고, 놓을 수 있다면 다음 줄로 넘어감. 부분 1: x, y값에 queen을 놓을 수 없으면 return 0\n부분 2: x, y에 queen 놓기\n부분 3: 만일 마지막 줄인 경우, 놓았던 queen을 되돌리고 return 1\n부분 4: 다음 줄에 처음부터 끝까지 queen을 배치해보기 위해 n_queen() 재귀호출하고 호출의 return 값을 cnt에 누적\n부분 5: 놓았던 queen을 되돌리고 누적된 cnt를 반환. 실패 원인: 함수 호출이 너무 많음 def n_queen(i): if (i == N): return 1 cnt = 0 for j in range(N): if checkCol[j] == 0 and checkDiagAdd[i+j] == 0 and checkDiagMinus[i-j+N] == 0: checkCol[j] = checkDiagAdd[i+j] = checkDiagMinus[i-j+N] = 1 cnt += n_queen(i+1) checkCol[j] = checkDiagAdd[i+j] = checkDiagMinus[i-j+N] = 0 return cnt N = int(input()) checkCol = [0] * N checkDiagAdd = [0] * (2*N) checkDiagMinus = [0] * (2*N) print(n_queen(0)) 수정 굳이 체스판(queens)을 사용할 필요 없어서 제거 → 이미 필요한 정보는 다른 배열들에 저장되어있음\n함수 n_queen()의 역할이 살짝 수정됨 해당 줄(i)에 각 칸에 퀸을 넣을 수 있는지 없는지를 판별하고 다음 줄로 넘어감\n기준이 칸이 아니라 줄로 변경되어 함수 호출 횟수가 줄어듬.\n줄 기준이 가능 한 이유는 줄별로 무조건 1개의 queen만을 놓아야하기 때문임. 2번으로 인해 함수 n_queen()이 필요로하는 매개 변수가 x, y 두 개에서 i한개로 변함. 풀이 n_queen()의 역할: 해당 줄(i)의 특정 칸 (j)에 queen을 놓을 수 있는 지 판별 만일 끝까지 queen을 놓으면서 끝에 도달했다면, 1을 반환 → if (i == N): return 1\n아직 끝이 아니라면 각 칸별로 놓을 수 있는지 판별\n→ if checkCol[j] == 0 and checkDiagAdd[i+j] == 0 and checkDiagMinus[i-j+N] == 0: 놓을 수 있다면 놓은 후 → checkCol[j] = checkDiagAdd[i+j] = checkDiagMinus[i-j+N] = 1\n다음 줄(i+1)로 넘어가 같은 작업 반복 → cnt += n_queen(i+1) 완료하고 받아온 return값을 cnt에 저장하고\n놓았던 queen을 회수함 → checkCol[j] = checkDiagAdd[i+j] = checkDiagMinus[i-j+N] = 0 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"},{"heading":"입력","level":4,"id":"입력_0"},{"heading":"출력","level":4,"id":"출력_0"},{"heading":"풀이","level":3,"id":"풀이_0"},{"heading":"실패: 시간초과","level":4,"id":"실패_시간초과_0"},{"heading":"성공","level":4,"id":"성공_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/9663.-n-queen.html","pathToRoot":"../..","attachments":[],"createdTime":1747967104607,"modifiedTime":1748516249393,"sourceSize":4211,"sourcePath":"Dev Blog/Coding Test/9663. N-Queen.md","exportPath":"dev-blog/coding-test/9663.-n-queen.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html":{"title":"2869. 달팽이는 올라가고 싶다","icon":"","description":"땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B &lt; A ≤ V ≤ 1,000,000,000)첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.\n기본 반복문 안 됨 → 시간 초과(시간 제한을 보면 0.25로 굉장히 짧은 걸 알 수 있다.)\n기본 수학으로 풀기 안 됨 → 그냥 하루에 이동하는 거리 분에 전체 거리(V/(A-B))로 풀 수 없음 포인트는 “정상에 올라간 후에는 미끄러지지 않는다”는 점\n하루의 마지막 그러니까 정상에 도달했는지를 체크하는 시기를 A만큼 올라간 직후로 잡으면 됨 기존의 수식(V/(A-B))은 올라갔다 B만큼 내려갔을 때 정상에 도달했는지를 체크함\n미리 A만큼 올려둬서(V -= A) (-B +A)를 한싸이클로 두면 됨.\n다르게 표현하면 첫째날 밤부터 시작하는 거임. import math A, B, V = map(int, input().split()) V -= A # 끝에 도달했는지 검증하는 시기가 올라간 직후니까. 이걸 해주지 않으면 내려간 후에 검증을 하게됨. 대신 이후에 하루 더해줘야함. q = math.ceil(V/(A-B)) # 내려갔다 올라갔다를 며칠씩 하는지. =&gt; A-B = 하루에 움직이는 거리 print(q + 1) 추가적으로 A 대신 B를 빼주는 경우가 있는데, 어떤 로직인지 이해를 다 하진 못함. ((V - B - 1) // (A - B) + 1)\n<a data-tooltip-position=\"top\" aria-label=\"https://chatgpt.com/share/68273f81-c5c8-800a-9c15-091d804653ca\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://chatgpt.com/share/68273f81-c5c8-800a-9c15-091d804653ca\" target=\"_self\">GPT 참고 링크</a>\nN일 째 밤에 V-B에 도달한거면, N일 째 낮에는 V에 도달한 거니까! ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"},{"heading":"입력","level":4,"id":"입력_0"},{"heading":"출력","level":4,"id":"출력_0"},{"heading":"풀이","level":3,"id":"풀이_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html","pathToRoot":"../..","attachments":[],"createdTime":1747967245829,"modifiedTime":1748516252435,"sourceSize":2404,"sourcePath":"Dev Blog/Coding Test/2869. 달팽이는 올라가고 싶다.md","exportPath":"dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/1978.-소수-찾기.html":{"title":"1978. 소수 찾기","icon":"","description":"주어진 수 N개&nbsp;중에서&nbsp;소수가 몇 개인지 찾아서 출력하는 프로그램을 작성하시오.첫 줄에 수의 개수 N이 주어진다. N은 100이하이다. 다음으로 N개의 수가 주어지는데 수는 1,000 이하의 자연수이다.주어진 수들 중 소수의 개수를 출력한다.N = int(input())\nnums = list(map(int, input().split()))\ncnt = 0 for n in nums: if n == 1: cnt -= 1 for i in range(2, int(n**(0.5))+1): # math.sqrt 안하고 이거 해도 되네! if n % i == 0: break else: cnt += 1 print(cnt)\nmath.sqrt(n)대신 n**(0.5)를 사용해도 됨","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"},{"heading":"입력","level":4,"id":"입력_0"},{"heading":"출력","level":4,"id":"출력_0"},{"heading":"풀이","level":3,"id":"풀이_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/1978.-소수-찾기.html","pathToRoot":"../..","attachments":[],"createdTime":1747967228377,"modifiedTime":1748516253091,"sourceSize":1034,"sourcePath":"Dev Blog/Coding Test/1978. 소수 찾기.md","exportPath":"dev-blog/coding-test/1978.-소수-찾기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/9020.-골드바흐의-추측.html":{"title":"9020. 골드바흐의 추측","icon":"","description":"1보다 큰 자연수&nbsp;중에서 &nbsp;1과 자기 자신을 제외한 약수가 없는 자연수를 소수라고 한다. 예를 들어, 5는 1과 5를 제외한 약수가 없기 때문에 소수이다. 하지만, 6은 6 = 2 × 3 이기 때문에 소수가 아니다.골드바흐의 추측은 유명한 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 것이다. 이러한 수를 골드바흐 수라고 한다. 또, 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다. 예를 들면, 4 = 2 + 2, 6 = 3 + 3, 8 = 3 + 5, 10 = 5 + 5, 12 = 5 + 7, 14 = 3 + 11, 14 = 7 + 7이다. 10000보다 작거나 같은&nbsp;모든 짝수 n에 대한 골드바흐 파티션은 존재한다.2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오. 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다.첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고 짝수 n이 주어진다.각 테스트 케이스에 대해서 주어진 n의 골드바흐 파티션을 출력한다. 출력하는 소수는 작은 것부터 먼저 출력하며, 공백으로 구분한다.\n4 ≤ n ≤ 10,000\nT = int(input()) targets = [] for _ in range(T): targets.append(int(input())) primes = [0]*(max(targets)+1) for i in range(2, len(primes)): if (i == 1): continue # 이미 채워졌으면 넘어감 -&gt; 자기 자신의 배수도 이미 다 지워졌기 때문에. for check in range(i+1, len(primes)): if check % i == 0: primes[check] = 1 for t in targets: for i in range(t//2, t): if primes[i] == 1: continue if primes[t-i] == 0: print(f\"{t-i} {i}\") break 에라토스테네스의 체로 소수를 구해 둔 다음에,\nt = t/2 + t/2니까 t//2에서부터 멀어져 가면서 각 수가 소수 인지를 판별하고 그렇다면 print 후 종료 → 더 자세히\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"},{"heading":"입력","level":4,"id":"입력_0"},{"heading":"출력","level":4,"id":"출력_0"},{"heading":"제한","level":4,"id":"제한_0"},{"heading":"풀이","level":3,"id":"풀이_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/9020.-골드바흐의-추측.html","pathToRoot":"../..","attachments":[],"createdTime":1747967208221,"modifiedTime":1748516253874,"sourceSize":2500,"sourcePath":"Dev Blog/Coding Test/9020. 골드바흐의 추측.md","exportPath":"dev-blog/coding-test/9020.-골드바흐의-추측.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/1065.-한수.html":{"title":"1065. 한수","icon":"","description":"어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.&nbsp;첫째 줄에 1,000보다 작거나 같은 자연수 N이 주어진다.첫째 줄에 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력한다.N = int(input()) if N &lt; 100: print(N)\nelse: if N == 1000: N -= 1 sum = 99 numList = [0,0,0] for num in range(100, N+1): for i in range(3): numList[i] = num%10 num //= 10 if numList[0] - numList[1] == numList[1] - numList[2]: sum += 1 print(sum) 1자리수와 2자리수의 수는 모두 한수 → if N &lt; 100: print(N) 1000의 경우 한수가 아니므로 999와 한수의 개수가 같음 → if N == 1000: N -= 1 이 두 조건을 잘 활용하면 3자리 수에 대해서만 추가 로직을 수행하면 됨. 3자리 수에 대한 추가 로직 1자리수 2자리수의 개수 더해줌. → sum = 99\n100부터 각 자리 수를 리스트에 넣고 숫자들 사이에 등차성을 테스트(if numList[0] - numList[1] == numList[1] - numList[2]) 하면서 sum에 값을 누적(sum += 1 ) 추가적으로 뿌듯했던 점! 2년 전에 같은 문제를 풀었던 코드 보다 훨씬 깔끔해졌음!! # 2년전 코드\nimport sys def solution(): x = int(sys.stdin.readline().rstrip()) # x: 두자리 이하의 양의정수 if x &lt;= 99: return(x) # x가 abc(d)일 때 a(b-1)9(9)까지 탐색 n = 10 result = 99 i = 1 while n &lt; x//(10**i): d = ((n%10) - (n//10))*i a_1 = n%10 if a_1+d &gt;= 0 and a_1+d&lt;=9: result+=1 n += 1 # 자릿수 변화 if n == 100: n = 10 i += 1 # ab--일때 탐색 a_1 = n%10 d = ((n%10) - (n//10))*i if a_1+d &gt;= 0 and a_1+d&lt;=9: x_ = n for j in range(1,i+1): d = ((n%10) - (n//10))*j x_ = x_*(10*j) + (d+a_1) if x_ &lt;= x: result += 1 return result if __name__ == \"__main__\": print(solution())\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"},{"heading":"입력","level":4,"id":"입력_0"},{"heading":"출력","level":4,"id":"출력_0"},{"heading":"풀이","level":3,"id":"풀이_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/1065.-한수.html","pathToRoot":"../..","attachments":[],"createdTime":1747967185930,"modifiedTime":1748516254669,"sourceSize":2797,"sourcePath":"Dev Blog/Coding Test/1065. 한수.md","exportPath":"dev-blog/coding-test/1065.-한수.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/2628.-종이-자르기.html":{"title":"2628. 종이 자르기","icon":"","description":"아래 &lt;그림 1&gt;과 같이 직사각형 모양의 종이가 있다. 이 종이는 가로방향과 세로 방향으로 1㎝마다 점선이 그어져 있다. 가로 점선은 위에서 아래로 1번부터 차례로 번호가 붙어 있고, 세로 점선은 왼쪽에서 오른쪽으로 번호가 붙어 있다.<img alt=\"\" src=\"https://upload.acmicpc.net/1e689dae-2d24-463b-8725-fb58ae8cd2ba/-/preview/\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"width: 300px; max-width: 100%;\">&lt;그림 1&gt;점선을 따라 이 종이를 칼로 자르려고 한다. 가로 점선을 따라 자르는 경우는 종이의 왼쪽 끝에서 오른쪽 끝까지, 세로 점선인 경우는 위쪽 끝에서 아래쪽 끝까지 한 번에 자른다. 예를 들어, &lt;그림 1&gt;의 가로 길이 10㎝이고 세로 길이 8㎝인 종이를 3번 가로 점선, 4번 세로 점선, 그리고 2번 가로 점선을 따라 자르면 &lt;그림 2&gt;와 같이 여러 개의 종이 조각으로 나뉘게 된다. 이때 가장 큰 종이 조각의 넓이는 30㎠이다.<br><img alt=\"\" src=\"https://upload.acmicpc.net/cf033b95-91ef-4e71-8f2c-49c653e27622/-/preview/\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"width: 300px; max-width: 100%;\">&lt;그림 2&gt;입력으로 종이의 가로 세로 길이, 그리고 잘라야할 점선들이 주어질 때, 가장 큰 종이 조각의 넓이가 몇 ㎠인지를 구하는 프로그램을 작성하시오.첫줄에는 종이의 가로와 세로의 길이가 차례로 자연수로 주어진다. 가로와 세로의 길이는 최대 100㎝이다. 둘째 줄에는 칼로 잘라야하는 점선의 개수가 주어진다. 셋째 줄부터 마지막 줄까지 한 줄에 점선이 하나씩 아래와 같은 방법으로 입력된다. 가로로 자르는 점선은 0과 점선 번호가 차례로 주어지고, 세로로 자르는 점선은 1과 점선 번호가 주어진다. 입력되는 두 숫자 사이에는 빈 칸이 하나씩 있다.첫째 줄에 가장 큰 종이 조각의 넓이를 출력한다. 단, 넓이의 단위는 출력하지 않는다.X, Y = map(int, input().split(\" \")) T = int(input()) xs = [0, X] ys = [0, Y] for _ in range(T): dir, loc = map(int, input().split(\" \")) if dir == 0: ys.append(loc) # 가로 else: xs.append(loc) # 세로 xs.sort() # 자체 정렬(반환x) / list 메서드 ys.sort() xMax = 0 yMax = 0 for i in range(len(xs)-1): xline = xs[i+1] - xs[i] if xline &gt; xMax: xMax = xline for i in range(len(ys) - 1): yline = ys[i + 1] - ys[i] if yline &gt; yMax: yMax = yline print(xMax * yMax) 각 열이 나뉘는 위치를 xs에 각 행이 나뉘는 위치를 ys에 저장 각각 0부터 X까지, 0부터 Y까지라 초기에 2수를 저장해줘야함. input을 받아서 해당하는 list에 넣어주고, sort를 돌림 각 리스트를 순회하면서 가장 긴 변들을 선정하고, 해당 값을 곱하면 그것이 답! ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"},{"heading":"입력","level":4,"id":"입력_0"},{"heading":"출력","level":4,"id":"출력_0"},{"heading":"풀이","level":3,"id":"풀이_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/2628.-종이-자르기.html","pathToRoot":"../..","attachments":[],"createdTime":1747967166129,"modifiedTime":1748516255275,"sourceSize":3138,"sourcePath":"Dev Blog/Coding Test/2628. 종이 자르기.md","exportPath":"dev-blog/coding-test/2628.-종이-자르기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/1914.-하노이-탑.html":{"title":"1914. 하노이 탑","icon":"","description":"세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로&nbsp;쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.\n한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.\n쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.\n이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.아래 그림은 원판이 5개인 경우의 예시이다.<img src=\"https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11729/hanoi.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 100)이 주어진다.첫째 줄에 옮긴 횟수 K를 출력한다.N이 20 이하인 입력에 대해서는 두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다. N이 20보다 큰 경우에는 과정은 출력할 필요가 없다.def hanoi(num, start, sub, dst): if num ==1: print(start, dst) return hanoi(num-1, start, dst, sub) # (N-1)번째까지를 N번째 원판 위에서 치우기 -&gt; 보조 막대로 옮기기 print(start, dst) # N번째 원판을 목표 막대로 옮기기 hanoi(num-1, sub, start, dst) # (N-1)번째까지의 원판을 N번째 원판 위로 올리기 -&gt; 보조막대에서 dst로. return N = int(input()) print(2**N -1) # 총 실행 횟수\nif (N &lt;= 20): hanoi(N,1,2,3) hanoi(num, start, sub, dst): num만큼의 원판을 start 기둥에서 dst 기둥으로 이동시키는 역할 매개변수 num: 옮길 원판의 개수\nstart: 시작기둥의 위치\nsub: 보조기둥의 위치\ndst: 목적지 기둥의 위치 내부 동작 옮겨야할 원판이 하나일 때 → 자신 위에 원판이 하나도 없다는 뜻이기 때문에, 바로 옮기고(print) return\n옮겨야할 원판이 하나 이상일 때 제일 밑에 n번째 원판을 제외하고, n-1번째 원판까지 보조 막대(sub)에 옮김\nn번째 원판을 dst에 옮김(print)\n보조 막대(sub)에 있는 n-1개의 원판을 목적지 막대(dst)로 (= n번째 원판 위로) 옮김 여기서 모든 옮기는 행위는 hanoi함수를 사용하여 진행할 수 있으므로 재귀적으로 호출 n번째 원판을 dst에 옮김(print) → 이부분은 재귀호출을 해도 되나, 그냥 print만 해도 되어서 후자로 구현 예시: 원판 3개를 기둥1에서 기둥3으로 옮겨야한다고 하면, 원판 3개 중 맨 아래 1개를 뺀 2개를 먼저 보조기둥으로 옮기고, 맨 밑에 원판을 목적지 기둥으로 옮기고, 보조기둥에 있던 2개의 원판을 원래 목적지 기둥으로 옮기는 행위를 하도록 코딩되어 있어. 1개 이상의 기둥을 옮길 때는 하노이 함수를 다시 재귀적으로 호출해서 비슷한 행위를 반복해. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":3,"id":"문제_0"},{"heading":"입력","level":4,"id":"입력_0"},{"heading":"출력","level":4,"id":"출력_0"},{"heading":"풀이","level":3,"id":"풀이_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/1914.-하노이-탑.html","pathToRoot":"../..","attachments":[],"createdTime":1747967150421,"modifiedTime":1748516256154,"sourceSize":3659,"sourcePath":"Dev Blog/Coding Test/1914. 하노이 탑.md","exportPath":"dev-blog/coding-test/1914.-하노이-탑.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/10971.-외판원-순회2.html":{"title":"10971. 외판원 순회2","icon":"","description":"def tsp(start, now, move, cost): # 부분 1 if (move == 1): if (lst[now][start] != 0): costs.append(cost+lst[now][start]) return # 부분 2 visited[now] = 1 for next in range(N): if visited[next] == 0 and lst[now][next] != 0: tsp(start,next, move-1, cost+ lst[now][next]) visited[now] = 0 return N = int(input()) lst = [list(map(int, input().split(\" \"))) for _ in range(N)] visited = [0] * N costs = [] for i in range(N): tsp(i, i, N, 0) print(min(costs)) tsp(start, now, move, cost)의 역할 : 외판원이 한 노드를 방문하고 다음으로 갈 노드를 찾고, 해당 노드에 대해서 함수를 재귀적으로 호출하여 다시 방문함. 목적지에 도달하면 거쳐온 경로의 비용을 저장함. 매개 변수 start: 경로의 시작노드 -&gt; 맨 마지막에는 시작노드로 돌아가야하기 때문에 정보 전달을 위해 now: 현재 노드 -&gt; 현재노드 방문 표시와, 다음에 갈 수 있는 노드를 탐색하기 위해\nmove: 앞으로 거쳐야 하는 노드의 남은 개수 -&gt; 1이 되면 모든 노드를 방문했으므로 시작노드(start)로 돌아가야함\ncost: 지금까지 경로에서 누적되어온 비용 -&gt; 순회에 성공하면 전체 비용을 costs 리스트에 저장하고 마지막에 모든 경우 중 최솟값을 구함 내부 동작 부분 1: 남은 노드의 개수가 1인 경우 현재 노드(now)에서 최초 노드(start)로 갈 수 있는다면, 지금까지의 cost와 최초로 돌아가는 경로의 비용을 합쳐서 costs 리스트에 저장\n갈 수 없다면 pass 부분 2: now에 대한 방문 처리를 하고 → visited[now] = 1\n0부터 N까지 순회하면서 갈 수 있는 다음 노드를 탐색\n→ if visited[next] == 0 and lst[now][next] != 0: 갈 수 있는 노드를 찾으면, tsp()함수를 재귀적으로 호출해 해당 노드를 방문\n→ tsp(start,next, move-1, cost+ lst[now][next])\n모두 방문을 하고 돌아오면, 현재 노드(now) 방문을 회수 다 돌고 costs에 저장된 값 중 최솟값을 출력\ndef tsp(start, now, move): # 부분 1 if (move == 1): if (lst[now][start] != 0): return lst[now][start] else: return int(1e9) # 부분 2 visited[now] = 1 cost = int(1e9) for next in range(N): if visited[next] == 0 and lst[now][next] != 0: cost = min(tsp(start,next, move-1)+lst[now][next], cost) visited[now] = 0 return cost N = int(input()) lst = [list(map(int, input().split(\" \"))) for _ in range(N)] visited = [0] * N minCost = int(1e9) for i in range(N): minCost = min(minCost, tsp(i, i, N)) print(minCost) cost를 매개변수로 넘겨주는 게 아니라 return으로 받는 방식\n수정 부분 1에서 마지막에 최초노드로 돌아갈 수 있으면 now → start의 비용을 return\n갈 수 없으면 엄청 큰 값(‘int(1e9)) return 부분 2에서 방문 후 돌아올 때 가져오는 return 값 중에 가장 작은 값을 cost변수에 저장하고 해당 값을 return 함 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"10971. 외판원 순회2","level":1,"id":"10971. 외판원 순회2"},{"heading":"풀이","level":3,"id":"풀이"},{"heading":"Tail Recursion","level":4,"id":"Tail_Recursion"},{"heading":"일반 recursion","level":4,"id":"일반_recursion"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/10971.-외판원-순회2.html","pathToRoot":"../..","attachments":[],"createdTime":1747967063421,"modifiedTime":1747967065117,"sourceSize":3535,"sourcePath":"Dev Blog/Coding Test/10971. 외판원 순회2.md","exportPath":"dev-blog/coding-test/10971.-외판원-순회2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/2468.-안전지대.html":{"title":"2468. 안전지대","icon":"","description":"def safe(h): # h: 가준 물 높이 / que = deque() # 부분 1 que = deque() visited = [[0 for _ in range(N)] for _ in range(N)] # 부분 2 while True: nextSafe = findNextSafe(h,visited) if nextSafe: visited[nextSafe[0]][nextSafe[1]] = 1 que.append(nextSafe) else: return # 부분 3 while que: node = que.popleft() x = node[0] y = node[1] for i in a: nx = x+i[0] ny = y+i[1] if 0&lt;=nx&lt;N and 0&lt;=ny&lt;N and visited[nx][ny] == 0 and lst[nx][ny] &gt; h: visited[nx][ny] = 1 que.append((nx,ny)) def findNextSafe(h, visited): for i in range(0, N): for j in range(0, N): if visited[i][j] == 0 and lst[i][j] &gt; h: waterCnt[h] += 1 return (i, j) return None input = __import__('sys').stdin.readline N = int(input()) a = [[-1, 0], [1, 0], [0, -1], [0, 1]] lst = [list(map(int, input().split(\" \"))) for _ in range(N)] waterCnt = [-1]*101 # 물 높이 waterCnt[0] = 1 waterCnt[100] = 0 for i in range(N): for j in range(N): h = lst[i][j] if waterCnt[h] == -1: waterCnt[h] += 1 safe(h) safe(100) print(max(waterCnt)) 용어 안전한 땅: 특정 물높이 h에 대해 h를 초과하는 지역\n안전지대: 연결되어있는 안전한 땅을 안전지대라고 부름 (연결된 것중 최대 크기) 전역변수 waterCnt 배열: 각 물높이에 대해 안전지대가 몇 개인지 개수를 저장\na 배열: 연결된 다음 안전지대를 찾을 때, 좌표 이동을 위한 배열\nlst 배열: 땅 높이에 대한 정보가 저장 findNextSafe(h, visited)의 역할: 안전한 땅을 탐색하다가 길이 끊겼을 경우(혹은 최초에), 다음으로 아직 방문하지 않은 안전한 땅을 찾는 역할 배열 전체 (땅 전체)를 순회하면서, 아직 방문하지 않았고, 안전한 땅을 찾으면, 해당 땅 위치를 return 또한 이 경우 새로운 안전한 땅 유닛 (=안전지대)의 시작이기 때문에, 해당 높이의 안전지대 count를 올려줌 (waterCnt[h])\n찾는 값이 없을 경우 None을 return safe(h)의 역할: 특정 물높이 h에 대해 h를 초과하는 지역(=안전한 땅)을 방문하고 그 지역과 연결된 다른 안전한 땅을 차례로 방문하는 함수 부분 1: visited 배열: 해당 물높이 h에 대해서 탐색할 때, 특정 지역에 방문 했는지를 체크하는 용도의 배열\nque: 선입 선출의 특징을 가진 리스트로, 갈 수 있는 땅을 발견했을 때, 해당 que에 집어 넣음. 또한 순서대로 빼면서, 빼낸 땅에 대해 인접한 안전한 땅이 또 있는지 확인하기 위해 선언 부분 2 findNextSafe함수를 통해 다음 안전지대 시작점을 찾을 수 없을 때까지 계속 안전지대 탐색을 반복 부분 3 방문한 땅을 하나 빼냄 → node = que.popleft()\n해당 땅에 인접한 땅들을 순회((x-1, y), (x+1, y), (x, y-1), (x, y+1))\n그 땅이 배열의 안에 있고(0&lt;=nx&lt;N and 0&lt;=ny&lt;N), 안전한 땅이며(lst[nx][ny] &gt; h), 아직 방문하지 않은 곳(visited[nx][ny] == 0)인지를 체크\n모두 True라면 해당 땅을 방문하고, 다음 탐색을 위해 que에 삽입\n이것을 que가 다 빌 때까지 반복 물 높이(h) 관련 h = 0일 때, 안전지대는 1개 → 모든 땅이 물에 잠기지 않았음\nh = 100 일때, 안전지대는 0개 → 모든 땅이 물에 잠겼음\n이 외에 물높이에 따라 안전지대의 개수가 변하기 위해서는, 물높이가 특정 땅의 높이와 일치되어야한다.\n즉, 땅 높이가 1 5 8일 때, 물높이 1에서 부터 4까지는 동일한 땅이 물에 잠기고 동일한 땅이 물위에 있지만, 5부터는 물에 잠긴 모습이 변하게 됨.\n따라서, 탐색에 적용할 h의 값은 모든 땅의 높이와 최소 높이 0, 최고 높이 100이다. 출력: waterCnt의 최대값을 출력 시간 초과 원인: 다음 안전지대 시작 위치를 찾는걸 어떻게 해야하지 헷갈렸는데, 어김없이 거기서 문제가 생김 findNextSafe 함수에서 다음 안전지대 시작점을 찾을 때, 매번 처음부터 끝까지 탐색을 하니까 시간이 오래걸림 함수 findNextSafe와 safe로 나누지 말고 2중 포문 돌리면서 다음 시작위치를 탐색하다가 시작위치를 찾으면 que에 넣어서 안전지대 하나 탐험 시작. 그리고 탐험 끝나면, 아까 찾은 안전지대 시작위치 뒤부터 탐색을 시작해서 다음 안전지대를 찾는 방식으로 수정 from collections import deque def safe(h): # h: 가준 물 높이 / que = deque() visited = [[0 for _ in range(N)] for _ in range(N)] for i in range(0, N): for j in range(0, N): if visited[i][j] == 0 and lst[i][j] &gt; h: waterCnt[h] += 1 visited[i][j] = 1 que.append((i,j)) while que: node = que.popleft() x = node[0] y = node[1] for a in A: nx = x+a[0] ny = y+a[1] if 0&lt;=nx&lt;N and 0&lt;=ny&lt;N and visited[nx][ny] == 0 and lst[nx][ny] &gt; h: visited[nx][ny] = 1 que.append((nx,ny)) input = __import__('sys').stdin.readline N = int(input()) A = [[-1, 0], [1, 0], [0, -1], [0, 1]] lst = [list(map(int, input().split(\" \"))) for _ in range(N)] waterCnt = [-1]*101 waterCnt[0] = 1 waterCnt[100] = 0 for i in range(N): for j in range(N): h = lst[i][j] if waterCnt[h] == -1: waterCnt[h] += 1 safe(h) safe(100) print(max(waterCnt))\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"2468. 안전지대","level":1,"id":"2468. 안전지대"},{"heading":"풀이","level":3,"id":"풀이"},{"heading":"실패 → 시간 초과","level":4,"id":"실패_→_시간_초과"},{"heading":"성공","level":4,"id":"성공"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/2468.-안전지대.html","pathToRoot":"../..","attachments":[],"createdTime":1747966984125,"modifiedTime":1747966985548,"sourceSize":6416,"sourcePath":"Dev Blog/Coding Test/2468. 안전지대.md","exportPath":"dev-blog/coding-test/2468.-안전지대.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/coding-test.html":{"title":"Coding Test","icon":"","description":"<a data-tooltip-position=\"top\" aria-label=\"Dev Blog/Coding Test/new file.md\" data-href=\"Dev Blog/Coding Test/new file.md\" href=\".html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">new file</a> | <a data-tooltip-position=\"top\" aria-label=\"Dev Blog/Coding Test/new folder/new folder.md\" data-href=\"Dev Blog/Coding Test/new folder/new folder.md\" href=\".html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">new folder</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Note","level":3,"id":"Note_0"},{"heading":"File","level":3,"id":"File_0"}],"links":[".html",".html","dev-blog/coding-test/10830.-행렬-제곱.html#_0","dev-blog/coding-test/2504.-괄호의-값.html#_0","dev-blog/coding-test/8983.-사냥꾼.html#_0","dev-blog/coding-test/1655.-가운데를-말해요.html#_0","¹-project/computer/algorithm-and-data-structure/heap-(priority-queue).html","dev-blog/coding-test/3190.-뱀.html#_0","dev-blog/coding-test/2493.-탑.html#_0","dev-blog/coding-test/1629.-곱셈.html#_0","dev-blog/coding-test/2470.-두-용액.html#_0","dev-blog/coding-test/2630.-색종이-자르기.html#_0","dev-blog/coding-test/2110.-공유기-설치.html#_0","dev-blog/data-structure-&-algorithm/이분탐색-v.2.html#_0","dev-blog/coding-test/1074.-z.html#_0","dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html#_0","dev-blog/coding-test/1978.-소수-찾기.html#_0","dev-blog/coding-test/9020.-골드바흐의-추측.html#_0","dev-blog/coding-test/1065.-한수.html#_0","dev-blog/coding-test/2628.-종이-자르기.html#_0",".html","dev-blog/coding-test/1914.-하노이-탑.html#_0","dev-blog/coding-test/10819.-차이를-최대로.html#_0","dev-blog/coding-test/9663.-n-queen.html#_0","dev-blog/coding-test/10971.-외판원-순회2.html#_0","dev-blog/coding-test/2468.-안전지대.html#_0"],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/coding-test.html","pathToRoot":"../..","attachments":[],"createdTime":1747966827839,"modifiedTime":1748516603704,"sourceSize":2823,"sourcePath":"Dev Blog/Coding Test/Coding Test.md","exportPath":"dev-blog/coding-test/coding-test.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/jungle/week-1.html":{"title":"Week 1","icon":"","description":"<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/2869. 달팽이는 올라가고 싶다.md\" href=\"dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html\" target=\"_self\" rel=\"noopener nofollow\">2869. 달팽이는 올라가고 싶다</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/1978. 소수 찾기.md\" href=\"dev-blog/coding-test/1978.-소수-찾기.html\" target=\"_self\" rel=\"noopener nofollow\">1978. 소수 찾기</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/9020. 골드바흐의 추측.md\" href=\"dev-blog/coding-test/9020.-골드바흐의-추측.html\" target=\"_self\" rel=\"noopener nofollow\">9020. 골드바흐의 추측</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/1065. 한수.md\" href=\"dev-blog/coding-test/1065.-한수.html\" target=\"_self\" rel=\"noopener nofollow\">1065. 한수</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/2628. 종이 자르기.md\" href=\"dev-blog/coding-test/2628.-종이-자르기.html\" target=\"_self\" rel=\"noopener nofollow\">2628. 종이 자르기</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/1914. 하노이 탑.md\" href=\"dev-blog/coding-test/1914.-하노이-탑.html\" target=\"_self\" rel=\"noopener nofollow\">1914. 하노이 탑</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/9663. N-Queen.md\" href=\"dev-blog/coding-test/9663.-n-queen.html\" target=\"_self\" rel=\"noopener nofollow\">9663. N-Queen</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/1074. Z.md\" href=\"dev-blog/coding-test/1074.-z.html\" target=\"_self\" rel=\"noopener nofollow\">1074. Z</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/10819. 차이를 최대로.md\" href=\"dev-blog/coding-test/10819.-차이를-최대로.html\" target=\"_self\" rel=\"noopener nofollow\">10819. 차이를 최대로</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/10971. 외판원 순회2.md\" href=\"dev-blog/coding-test/10971.-외판원-순회2.html\" target=\"_self\" rel=\"noopener nofollow\">10971. 외판원 순회2</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/2468. 안전지대.md\" href=\"dev-blog/coding-test/2468.-안전지대.html\" target=\"_self\" rel=\"noopener nofollow\">2468. 안전지대</a><br><a class=\"internal-link\" data-href=\"Dev Blog/CSAPP/컴퓨터시스템 CH1. 컴퓨터 시스템으로의 여행.md\" href=\"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html\" target=\"_self\" rel=\"noopener nofollow\">컴퓨터시스템 CH1. 컴퓨터 시스템으로의 여행</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Week 1","level":1,"id":"Week 1"},{"heading":"Coding Test","level":3,"id":"[Coding_Test](Dev%20Blog/Coding%20Test/Coding%20Test.md)"},{"heading":"CSAPP","level":3,"id":"[CSAPP](CSAPP.md)"}],"links":["dev-blog/coding-test/coding-test.html","dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html","dev-blog/coding-test/1978.-소수-찾기.html","dev-blog/coding-test/9020.-골드바흐의-추측.html","dev-blog/coding-test/1065.-한수.html","dev-blog/coding-test/2628.-종이-자르기.html","dev-blog/coding-test/1914.-하노이-탑.html","dev-blog/coding-test/9663.-n-queen.html","dev-blog/coding-test/1074.-z.html","dev-blog/coding-test/10819.-차이를-최대로.html","dev-blog/coding-test/10971.-외판원-순회2.html","dev-blog/coding-test/2468.-안전지대.html","dev-blog/csapp/csapp.html","dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html"],"author":"","coverImageURL":"","fullURL":"dev-blog/jungle/week-1.html","pathToRoot":"../..","attachments":[],"createdTime":1747967262300,"modifiedTime":1747983504600,"sourceSize":1114,"sourcePath":"Dev Blog/Jungle/Week 1.md","exportPath":"dev-blog/jungle/week-1.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/jungle/jungle.html":{"title":"Jungle","icon":"","description":"<a data-tooltip-position=\"top\" aria-label=\"Dev Blog/Jungle/new file.md\" data-href=\"Dev Blog/Jungle/new file.md\" href=\"Dev Blog/Jungle/new file\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new file</a> | <a data-tooltip-position=\"top\" aria-label=\"Dev Blog/Jungle/new folder/new folder.md\" data-href=\"Dev Blog/Jungle/new folder/new folder.md\" href=\"Dev Blog/Jungle/new folder/new folder\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new folder</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Jungle","level":1,"id":"Jungle"},{"heading":"Note","level":3,"id":"Note"},{"heading":"File","level":3,"id":"File"}],"links":["Dev Blog/Jungle/new file.md","Dev Blog/Jungle/new folder/new folder.md","dev-blog/jungle/week-2.html","dev-blog/jungle/week-1.html"],"author":"","coverImageURL":"","fullURL":"dev-blog/jungle/jungle.html","pathToRoot":"../..","attachments":[],"createdTime":1747967262300,"modifiedTime":1747983482799,"sourceSize":339,"sourcePath":"Dev Blog/Jungle/Jungle.md","exportPath":"dev-blog/jungle/jungle.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"index.html":{"title":"index","icon":"","description":"Obsidian publishing 용 블로그 입니다.\n컴퓨터 관련 다양한 지식들을 업로드해 둘 예정입니다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"개요","level":3,"id":"개요_0"},{"heading":"Nav","level":3,"id":"Nav_0"}],"links":["dev-blog/jungle/jungle.html#_0","dev-blog/data-structure-&-algorithm/data-structure-&-algorithm.html#_0","dev-blog/coding-test/coding-test.html#_0","dev-blog/csapp/csapp.html#_0"],"author":"","coverImageURL":"","fullURL":"index.html","pathToRoot":".","attachments":[],"createdTime":1747967820644,"modifiedTime":1748509141756,"sourceSize":587,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/jungle/week-2.html":{"title":"Week 2","icon":"","description":"<a class=\"internal-link\" data-href=\"Dev Blog/Data Structure &amp; Algorithm/이분탐색 v.2.md\" href=\"dev-blog/data-structure-&amp;-algorithm/이분탐색-v.2.html#_0\" target=\"_self\" rel=\"noopener nofollow\">이분탐색 v.2</a><br><a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/2110. 공유기 설치.md\" href=\"dev-blog/coding-test/2110.-공유기-설치.html#_0\" target=\"_self\" rel=\"noopener nofollow\">2110. 공유기 설치</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/2630. 색종이 자르기.md\" href=\"dev-blog/coding-test/2630.-색종이-자르기.html#_0\" target=\"_self\" rel=\"noopener nofollow\">2630. 색종이 자르기</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/2470. 두 용액.md\" href=\"dev-blog/coding-test/2470.-두-용액.html#_0\" target=\"_self\" rel=\"noopener nofollow\">2470. 두 용액</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/1629. 곱셈.md\" href=\"dev-blog/coding-test/1629.-곱셈.html#_0\" target=\"_self\" rel=\"noopener nofollow\">1629. 곱셈</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/2493. 탑.md\" href=\"dev-blog/coding-test/2493.-탑.html#_0\" target=\"_self\" rel=\"noopener nofollow\">2493. 탑</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/3190. 뱀.md\" href=\"dev-blog/coding-test/3190.-뱀.html#_0\" target=\"_self\" rel=\"noopener nofollow\">3190. 뱀</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/1655. 가운데를 말해요.md\" href=\"dev-blog/coding-test/1655.-가운데를-말해요.html#_0\" target=\"_self\" rel=\"noopener nofollow\">1655. 가운데를 말해요</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/8983. 사냥꾼.md\" href=\"dev-blog/coding-test/8983.-사냥꾼.html#_0\" target=\"_self\" rel=\"noopener nofollow\">8983. 사냥꾼</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/2504. 괄호의 값.md\" href=\"dev-blog/coding-test/2504.-괄호의-값.html#_0\" target=\"_self\" rel=\"noopener nofollow\">2504. 괄호의 값</a><br>\n<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/10830. 행렬 제곱.md\" href=\"dev-blog/coding-test/10830.-행렬-제곱.html#_0\" target=\"_self\" rel=\"noopener nofollow\">10830. 행렬 제곱</a><br><a class=\"internal-link\" data-href=\"Dev Blog/CSAPP/컴퓨터시스템 CH2. 정보의 표현과 처리.md\" href=\"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#_0\" target=\"_self\" rel=\"noopener nofollow\">컴퓨터시스템 CH2. 정보의 표현과 처리</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Data Structure &amp; Algorithm","level":3,"id":"Data_Structure_&_Algorithm_0"},{"heading":"<a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/Coding Test.md\" href=\"Dev Blog/Coding Test/Coding Test.md\" target=\"_blank\" rel=\"noopener nofollow\">Coding Test</a>","level":3,"id":"[Coding_Test](Dev%20Blog/Coding%20Test/Coding%20Test.md)_0"},{"heading":"<a class=\"internal-link\" data-href=\"CSAPP.md\" href=\"CSAPP.md\" target=\"_blank\" rel=\"noopener nofollow\">CSAPP</a>","level":3,"id":"[CSAPP](CSAPP.md)_0"}],"links":["dev-blog/data-structure-&-algorithm/이분탐색-v.2.html#_0","dev-blog/coding-test/coding-test.html#_0","dev-blog/coding-test/2110.-공유기-설치.html#_0","dev-blog/coding-test/2630.-색종이-자르기.html#_0","dev-blog/coding-test/2470.-두-용액.html#_0","dev-blog/coding-test/1629.-곱셈.html#_0","dev-blog/coding-test/2493.-탑.html#_0","dev-blog/coding-test/3190.-뱀.html#_0","dev-blog/coding-test/1655.-가운데를-말해요.html#_0","dev-blog/coding-test/8983.-사냥꾼.html#_0","dev-blog/coding-test/2504.-괄호의-값.html#_0","dev-blog/coding-test/10830.-행렬-제곱.html#_0","dev-blog/csapp/csapp.html#_0","dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#_0"],"author":"","coverImageURL":"","fullURL":"dev-blog/jungle/week-2.html","pathToRoot":"../..","attachments":[],"createdTime":1747972311608,"modifiedTime":1748516603143,"sourceSize":1071,"sourcePath":"Dev Blog/Jungle/Week 2.md","exportPath":"dev-blog/jungle/week-2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/data-structure-&-algorithm/이분탐색-v.2.html":{"title":"이분탐색 v.2","icon":"","description":"정렬된 배열에서 원하는 값을 빠르게 찾을 수 있는 탐색 기법으로, 탐색 범위를 절반씩 줄여가며 원하는 값을 찾아가는 방식이다.\n정렬된 배열에서 중간 값을 기준으로 target 값과 비교한다. target이 중간 값보다 크면 왼쪽 부분을 버리고, 작으면 오른쪽 부분을 버린다. 이 과정을 반복하면서 배열의 범위를 점점 좁혀 target을 찾는다.\n이분 탐색의 시간복잡도는 O(log N) 이다.탐색의 범위를 절반씩 줄여나가며 탐색을 진행하는 방식으로, 매 실행마다 탐색범위가 절반씩 줄어들게 된다. 따라서 시간 복잡도는 배열 길이 N이 몇 번까지 2로 나누어(나머지 버림)질 수 있는가가 시간복잡도의 기준이 된다. 즉, 으로 시간 복잡도는 O(log N)의 값을 가진다.\n(다양한 구현 방법 중, 내가 익숙한 한가지를 가지고 설명하겠다 → 이후에 등장하는 코드도 정답코드가 아닌 구현 방법중 하나일뿐이다.)\nlst = {0,10,20,30,40,50,60,70,80,90}; t = 10; while lo &lt;= hi: mid = (lo + hi) // 2 if lst[mid] == t: print(1) break else: if lst[mid] &lt; t: lo = mid + 1 else: hi = mid - 1 else: print(0) while lo &lt;= hi → lo와 hi가 서로 반전되는 순간(lo &gt; hi) while문 종료 target 값이 존재 할 수도 안 할 수도 있으니, 최대한 끝까지(탐색 구간이 아예 없을 때까지) 탐색하기 위해 이러한 종료 조건을 사용한다.\n즉, 종료 조건인 lo &gt; hi의 의미는 더이상 탐색할 구간이 없으니 그만하고 나가라는 뜻이다. lo와 hi가 의미하는 건 다음과 같다. <img alt=\"그림2.png\" src=\"⁵-file/image/그림2.png\" target=\"_self\" style=\"width: 260px; max-width: 100%;\">\n탐색해야하는 양극단의 요소들을 참조한다는 느낌임 lo를 mid + 1로 , hi를 mid - 1로 업데이트 하는 이유 목적이 정확한 값을 찾는 것이기 때문에 mid는 이미 탐색한 idx이므로 다시 탐색할 필요가 없다\n따라서 mid를 제외한 범위를 책정하는 것이 효율적이다. 개요 기본 이분탐색이 내가 이미 가지고 있는 책을 책장 안에서 찾아내는 느낌임 따라서 OOO Bound는 책장에 새 책을 끼워넣을 올바른 위치를 찾는 느낌임 “찾는 값 이상의 값이 처음 등장하는 위치\" 또는\n\"찾는 값을 초과하는 값이 처음 등장하는 위치\" lo와 hi의 초기값 만일 찾는 값 이상(초과)의 값이 배열 내에 저장되어있지 않다면, 즉 배열 내의 값이 target값보다 다 작다면, 배열의 가장 마지막이 해당 위치가 됨.\n<br><img alt=\"그림1 1.png\" src=\"⁵-file/image/그림1-1.png\" target=\"_self\" style=\"width: 290px; max-width: 100%;\">\n따라서, lo는 일반적인 이분탐색과 같이 0으로 초기화 하지만, hi는 len(arr)-1이 아닌 len(arr)으로 초기화 한다.\n위 그림에서 10이 들어가는 위치까지 탐색할 수 있도록. 종료조건: while lo &lt; hi → lo와 hi가 같아지는 순간(lo == hi) while문 종료 기본 이분탐색과 달리 답이 반드시 있다. 해당 값이 아니라, 끼워 넣을 위치를 찾는 것이기 때문이다.\n따라서 탐색을 하다 두 값이 같아진 곳(lo == hi)이 곧 답이된다. 또한 index 값(lo, hi)이 우리가 원하는 값이기 때문에 둘의 인덱스가 반전될 때까지 탐색을 이어가면 마지막에 보정을 해줘야하는 귀찮음이 있다.\n종료조건인 lo == hi는 우리가 찾는 위치에 결국 도달했고, 이게 정답! 이라는 뜻이다. lst = {0,10,20,30,40,50,60,70,80,90}; t = 10.5; lo = 0\nhi = len(lst)\nwhile lo &lt; hi: mid = (lo + hi) // 2 now = lst[mid] if now &lt;= t: lo = mid + 1 if now &gt; t: hi = mid target 초과인 값이 처음 등장하는 인덱스 target 값과 마주쳤을 때 target 값을 찾았다고 바로 return되는 알고리즘이 아니기 때문에, target 값을 만났을 때 lo, hi 중 어떤 포인터를 옮길지가 중요하다.\nupper bound의 경우, target값을 만났을 때 해당 위치의 오른쪽에 또다른 target값이 존재하는지 안하는지가 중요하다.\n따라서 오른쪽을 계속 탐색할 수 있도록, 왼쪽의 lo를 옮겨주는 것이 적절하다. lo를 mid + 1로 , hi를 mid로 업데이트 하는 이유 우선 upper bound는 범위를 계속 위쪽으로(오른쪽으로) 좁혀가야한다는 느낌을 가지고 출발하자\nlo mid의 값 &lt; target일 때 → mid까지는 target 값이 등장조차하지 않았으니, mid는 절대 우리가 찾는 위치가 아님.\nmid의 값 == target일 때 만일 뒤에도 target값이 있다면, 탐색을 계속하면 됨\n만일 mid의 값이 마지막 target값이었다면, 새로 업데이트 한 lo값이 우리가 찾는 위치가 될 것 hi: mid의 값 &gt; target인 경우, 혹여나 해당 mid의 값이 우리가 찾는 값(target 이상인 첫 번째 값)일 수도 있음\nmid를 포함하여 탐색할 수 있도록 hi를 mid로 업데이트 함. lst = {0,10,20,30,40,50,60,70,80,90}; t = 10.5; lo = 0\nhi = len(lst)\nwhile lo &lt; hi: mid = (lo + hi) // 2 now = lst[mid] if now &lt; t: lo = mid + 1 if now &gt;= t: hi = mid target 이상인 값이 처음 등장하는 인덱스 = target 값이 처음 등장하는 인덱스 target 값과 마주쳤을 때 이것도 target 값을 찾았다고 바로 return되는 알고리즘이 아니기 때문에, target 값을 만났을 때 lo, hi 중 어떤 포인터를 옮길지가 중요하다.\nlower bound의 경우, target값을 만났을 때 해당 위치의 왼쪽에 또다른 target값이 존재하는지 안하는지가 중요하다.\n따라서 왼쪽을 계속 탐색할 수 있도록, 오른쪽의 hi를 옮기는 것이 적절하다. lo를 mid + 1로 , hi를 mid로 업데이트 하는 이유 우선 lower bound는 범위를 계속 아래쪽으로(왼쪽으로) 좁혀가야한다는 느낌을 가지고 출발하자\nlo mid의 값 &lt; target일 때 → mid까지는 target 값이 등장조차하지 않았으니, mid는 절대 우리가 찾는 위치가 아님. hi: mid의 값 ≥ target인 경우, 혹여나 해당 mid의 값이 우리가 찾는 값(target 이상인 첫 번째 값)일 수도 있음\nmid를 포함하여 탐색할 수 있도록 hi를 mid로 업데이트 함. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"개요","level":3,"id":"개요_0"},{"heading":"동작 방식","level":3,"id":"동작_방식_0"},{"heading":"시간복잡도","level":3,"id":"시간복잡도_0"},{"heading":"기본 이분 탐색 (정확한 값 찾기)","level":3,"id":"기본_이분_탐색_(정확한_값_찾기)_0"},{"heading":"OOO Bound","level":3,"id":"OOO_Bound_0"},{"heading":"Upper Bound","level":4,"id":"Upper_Bound_0"},{"heading":"Lower Bound","level":4,"id":"Lower_Bound_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/data-structure-&-algorithm/이분탐색-v.2.html","pathToRoot":"../..","attachments":["⁵-file/image/그림2.png","⁵-file/image/그림1-1.png"],"createdTime":1748509111384,"modifiedTime":1748509112785,"sourceSize":6990,"sourcePath":"Dev Blog/Data Structure & Algorithm/이분탐색 v.2.md","exportPath":"dev-blog/data-structure-&-algorithm/이분탐색-v.2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/data-structure-&-algorithm/data-structure-&-algorithm.html":{"title":"Data Structure & Algorithm","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Data Structure &amp; Algorithm","level":1,"id":"Data_Structure_&_Algorithm_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/data-structure-&-algorithm/data-structure-&-algorithm.html","pathToRoot":"../..","attachments":[],"createdTime":1747966841178,"modifiedTime":1747966841878,"sourceSize":74,"sourcePath":"Dev Blog/Data Structure & Algorithm/Data Structure & Algorithm.md","exportPath":"dev-blog/data-structure-&-algorithm/data-structure-&-algorithm.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html":{"title":"컴퓨터시스템 CH2. 정보의 표현과 처리","icon":"","description":" 컴퓨터는 비트를 저장하고 처리 디지털 혁명의 근원 두개의 값을 갖는 신호. 펀치카드에 구멍이 뚤렸는지 막혔는지\n높은 전압이 걸리는지 앉은 전압이 걸리는지\n자기장이 시계방향인지 반시계방향인지. 이를 계산하고 저장하기 위한 전자회로는 매우 간단하고 안정적 비트 패턴 비트만으로는 그다지 유용 x\n비트들을 묶어서 비트 패턴을 만듦\n특정 해석방법을 적용하여 해당 비트패턴에 의미를 부여 정수 특징: 작은 범위의 값을 매우 정밀하게\n비부호형 인코딩 → 양의 정수 전통적인 이진수 표시\n0 이상의 수 표시 2의 보수 인코딩 → 정수 양수와 음수값을 갖는 부호형 정수를 표시하는 가장 일반적 방법 계산의 결과값이 너무 크면 오버플로우 발생 이상한 숫자가 일관되게 나타남\n교환법칙, 분배법칙 성립 소수 특징: 넓은 범위의 값을 근사값으로만\n부동소수점 인코딩 소수 표시 오버플로우 발생시 +∞ 라는 특별한 값 생성\n교환 법칙이 성립하지 않음 많은 컴퓨터 보안 취약성은 컴퓨터 연산의 취약성 때문에 생김 → 어떻게 원하지 않은 방향으로 동작하게 될 수 있는 지 이해하고 있어야함. 메모리 접근 단위 = 메모리 주소 지정 단위 ⇒ 바이트(Byte)\n각 바이트는 주소라고 하는 고유한 숫자로 식별 가능\n가상 주소 공간 각 바이트를 식별하는 주소로 표현되는 전체 영역\n개념적인 이미지임 → 실제로는 균일하지 않으나, 균일한 것처럼 보이도록 함 ex) C에서 어떤 포인터의 값 = 해당 정수가 저장된 메모리 블록의 첫 바이트의 주소 비트 패턴을 16진수로 표시함 모든 컴퓨터는 워드 크기를 규격으로 가짐 주소는 워드 크기로 인코딩됨 이에 따라 가상 주소공간의 최대 크기도 결정됨 적용 워드 크기가 w비트 크기라는 소리는 주소의 길이도 w bit 크기라는 뜻임\n주소의 길이가 w bit 길이라는 것은 총 개를 주소로 표현할 수 있다는 의미이며,\n이에 따라 가상주소의 범위는 0 ~ 이 된다.\n결과적으로 가상주소공간의 크기는 byte 이다. (ex. byte = 4GB) 64비트 머신에서는 32비트로 컴파일된 프로그램과 64비트로 컴파일된 프로그램 모두 잘 작동 하지만, 32비트 머신에서는 그렇지 않다. 부호형 / 비부호형\nchar도 숫자표현에 사용될 수 있음. 단, 부호형으로 사용하기 위해서는 signed를 붙여줘야함.\nshort, int, long은 데이터 크기에 따라 구분됨. 각각 2, 4, 8(32bit 프로그램에서는 4) byte의 크기를 가짐.\nint32_t, int64_t은 컴파일러와 컴퓨터 설정에 관계없이 사용할 수 있는 자료형임\nT *p는 자료형 T에 대한 포인터 변수로 word 길이의 주소값을 가진다.\nfloat, double: 부동 소수점 형식의 소수형 자료형. float: 단일 정밀도 / 4byte\ndouble: 이중 정밀도 / 8byte C언어에서는 데이터 타입의 최대값이 시스템(32, 64)마다 달라질 수 있음. 여러 바이트에 걸쳐 있는 객체들에 대해, 객체의 주소가 여러 바이트중 무엇이 되어야 하는지\n객체들을 여러바이트에 어떻게 정렬할 것인지 주소지정: 사용된 바이트의 최소 주소 정렬관습 용어: 중요한 바이트 → 숫자의 경우 얼마나 큰값을 차지하고 있는지.\n(16진수 값 0x01234567에 대새)\n리틀 엔디안 덜 중요한 바이트가 먼저 옴\n67 45 32 01 빅 엔디안 중요한 바이트가 먼저옴\n01 23 45 67 선택해야하는 기술적 이유는 딱히 없고, 컴퓨터의 타입에 따라 달라짐 대부분의 인텔 호환 머신에서는 리틀 엔디안 사용\nIBM, Oracle 머신들은 빅 엔디안 사용. 네트워크를 통해 다른 컴퓨터로 전송될 때 → 송신시에 네트워크 표준으로 변경하고, 수신시에 내 컴퓨터에 맞게 변환하는 방식 사용\n정수 데이터를 나타내는 바이트들을 살펴볼때 예시 4004d3: 01 05 43 0b 20 00\nadd %eax, 0x200b43(%rip) 정수 데이터: 0x200b43 → 어셈블리 명령어 안에 주소, 상수, 오프셋 등으로 사용되는 정수 값(사람이 직접쓴 숫자나, 참조되는 메모리 위치)\n정수 데이터를 나타내는 바이트: 43 0b 20 00\n이것에 대한 해석을 잘 못하면 완전 다른 값이 도출됨. 프로그램이 정상적인 타입체계를 회피하도록 작성되었을 때 C에서 스트링은 null<a data-footref=\"1\" href=\"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#fn-1-ddff43e41cd65f11_0\" class=\"footnote-link\" target=\"_self\" rel=\"noopener nofollow\">[1]</a> 문자로 졸요하는 문자열로 인코딩 됨.\n<br>각 문자열은 표준 인코딩<a data-footref=\"2\" href=\"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#fn-2-ddff43e41cd65f11_0\" class=\"footnote-link\" target=\"_self\" rel=\"noopener nofollow\">[2]</a>에 따라 표시됨\n텍스트 데이터는 이진데이터에 비해 플랫폼 독립적이다. 이진데이터의 경우 정렬 순서나 워드크기에 따라 값이 변할 수 있지만\n텍스트의 경우 각 매칭되는 ascii값과 종료바이트인 0x00으로 이루어져있기 때문. 인스트럭션들의 인코딩은 컴퓨터 타입과 운영체제 등에 따라 모두 다름\n동일한 것은 컴퓨터의 관점에서 프로그램은 단순히 바이트의 연속이라는 점이다. 부울 대수: 논리 값 TRUE(0)와 FALSE(1)를 다루는 이론적체계로, 논리연산을 수학적으로 다루기 위한 체계임.\nboole이라는 사람이 이진수 값 1과 0을 논리값 TRUE와 FALSE로 인코딩하면, 논리추론의 기본원리들을 수식화 할 수 있다는 것을 발견해서 이런 이름이 붙었음. 0과 1로 이루어진 비트 스트링(배열)\n연산 비트벡터간의 연산은 동일한 자리수의 비트간의 연산으로 볼 수 있다.\n즉 각 비트 벡터의 i번째 원소를 , 라고 할 때 는 와 같다. 유한 집합의 원소 포함 여부 각 비트는 어떤 특정 항목의 포함 여부를 나타냄\n{0, 2, 5}라는 집합을 표현할 때 → 101001 인덱스 0, 2, 5는 1 → 포함\n인덱스 1, 3, 4는 0 → 미포함 이에 대해 합집합이나 교집합, 여집합 연산을 하기에 편함\n비트 (벡터) 마스크 특정 시그널의 선택적으로 활성화, 비활성화 할 수 있도록 해줌\n아래에서 자세히 다룸 장점 메모리 사용이 표율적이고\n연산이 빠름 C는 비트들 간의 부울 연산을 지원함(위에 기호 정리해둠.)\n일반적으로 마스크 연산을 구현 할 때 사용. x = 0x89ABCDEF일 때 x&amp;0xFF는 맨 우측의 EF 값만 활성화하는데 사용.\n~0은 비트가 모두 1인 마스크를 만들 때 사용 논리연산자인 ||, &amp;&amp;, !를 제공함\n비트수준의 연산과 혼동하지 말것 해당 논리연산이 참인지 거짓인지에 따라 0 또는 1을 리턴함\n만일 첫번째 인자를 계산해서 참, 거짓이 결정된다면 뒤의 연산을 하지 않음. 비트 패턴을 좌우로 이동시키는 연산 (정수를 2로 나눌 때 유용)\n좌측연산(x≪k): x를 좌측으로 k비트 이동 / 제일 좌측 비트 k개는 삭제 / 우측은 k개의 0으로 채워짐\n우측연산(x≫k): x를 우측으로 k비트 이동 / 제일 우측 비트 k개는 삭제 논리 우측 쉬프트: 좌측 k개가 0으로 채워짐\n산술 우측 쉬프트: 좌측 k개가 가장 중요한 비트(원래 제일 왼쪽 비트)로 채워짐 → 부호형 정수 데이터의 연산에서 유용하게 작용.\n대부분 산술 우측 쉬프트를 사용, 비부호형 데이터에 대해서 놀니 쉬프트를 적용 char: 1 byte\nshort: 2 byte\nint: 4 byte\nlong: 4 byte(32-bit) or 8 byte(64-bit) → 컴퓨터에 의존적인 범위\nint32_t: 4 byte\nint64_t: 8 byte\n각각에 대해 signed한 자료형(기본)과 unsigned한 자료형이 존재함.\nc표준에서는 각 데이터 타입에서 나타낼 수 있어야하는 최소한의 범위를 정의함. 비트 벡터의 각 비트는 0이나 1의 값을 가짐\n자리수 i에 대해 비트 값 1을 가진다는 의미 → 값이 숫자의 값을 계산 할 때 포함 되어야한다는 의미\n계산: 자릿값() x 1 또는 0을 해서 합함\n![|300](20250523_195552.jpg 부호형 숫자를 컴퓨터에서 표시하는 가장 일반적인 방법 가장 왼쪽 비트를 부호 비트로 사용함 1이면 음수\n0이면 양수 <br>\n<img alt=\"Pasted image 20250523213904.png\" src=\"⁵-file/image/pasted-image-20250523213904.png\" target=\"_self\" style=\"width: 320px; max-width: 100%;\"> 계산 → 4자리 비트에서 부호비트의 자리값은 나머지의 자리값은 각 자리값에 해당하는 비트값(0 or 1)을 곱한 값들의 합합 <br>\n<img alt=\"20250523_195539.jpg\" src=\"⁵-file/image/20250523_195539.jpg\" target=\"_self\" style=\"width: 300px; max-width: 100%;\"> 특징 2의 보수의 범위는 비대칭적임. (양수값의 범위) = (음수값의 범위) - 1\n비트 패턴의 절반으로 음수를, 나머지 절반으로 비음수(0과 양수)를 표현하기 때문 비부호형의 최대값 = 2의 보수 최대값 * 2 + 1 2의 보수에서 음수를 표시하는 모든 비트 패턴들은 비부호형에서 양수값을 표시하고 있기 때문임. 사용 C의 경우 부호형 정수를 2의 보수 형식으로 나타낼 것을 요구하지는 않지만, 거의 모든 컴퓨터에서 요하고 있음.\n자바는 64비트의 경우 2의 보수 표시를 요구함 비트의 값 → 동일하게 유지\n비트를 해석하는 방법 → 변경 묵시적으로 부호형 인자를 비부호형으로 변환하고 숫자들이 비음수라고 가정하고 계산\n이것은 관계 연산에 대해서 다소 덜 직관적인 결과를 만든다 비부호형 수: 단순히 앞에 0을 추가 → 0의 확장(zero extension)\n부호형 수(2의 보수): 부호비트를 복사해서 앞부분 전체에 추가 → 부호 확장(sign extension) 수를 절삭하면 그 값이 바뀔 수 있다. → 일종의 오버플로우\n컴퓨터는 그냥 자르지만 우리가 이것을 계산하려면 mod 연산을 하면 된다.\n비부호형 수: x’ = x mod k 위로 자를 때, i ≥ k인 모든 의 자리값은 0으로 계산됨. 부호형 수(2의 보수): 똑같이 그냥 자르고 그 값을 부호형 수로 바꿔 줌. x’ = U2T(x mod )\n가장 중요한 비트인 이 자리값 대신 을 가짐 부호형과 비부호형 간의 묵시적인 타입변환은 미묘한 에러들을 수반한다.\n기왕이면 비부호형 수를 절대로 사용하지 말아라. → C외에 다른 언어들은 비부호형 수를 지원하지 않음. 두 개의 0 이상 미만의 정수 x와 y에 대해 x+y는 최대 개의 비트로 표현 될 수 있음.\n→ 오버플로우 발생\n이때 컴퓨터는 넘어간 비트를 절삭함\n<br><img alt=\"Pasted image 20250529171635.png\" src=\"⁵-file/image/pasted-image-20250529171635.png\" target=\"_self\" style=\"width: 180px; max-width: 100%;\"> <br><img alt=\"Pasted image 20250529171701.png\" src=\"⁵-file/image/pasted-image-20250529171701.png\" target=\"_self\" style=\"width: 250px; max-width: 100%;\">\n이 경우도 비슷하게 overflow가 발생할 수 있다.\n양의 오버플로우 (case 4): 음의 오버플로우 (case 1): overflow의 판별은 양수끼리 더했을 때 음수가, 음수끼리 더했을 때 양수가 나오는 경우로 판별할 수 있다.\n여기도 동일하게 절삭을 진행하고, 그 값은 아래와 같이 계산할 수 있다. 양의 오버플로우: 음의 오버플로우: 표시하려면 비트까지 필요할 수 있다.\n동일하게 절삭을 진행한다.\n2의 보수는 절삭 후 해당 수를 2의 보수로 해석한다. 컴퓨터에서 정수 곱셈은 매우 느리다.\n따라서 곱셈을 대체할 수 있는 방법이 필요하다.\n그 방법이 시프트 연산을 하고 그 값을 더하는 것이다. 2의 제곱을 곱하는 경우 → 좌측 시프트\n2의 제곱이 아닌 경우 곱하는 수를 2의 제곱들의 합(또는 차)로 표현을 하고 그것을 활용\nex) 14 = 8 + 4 + 2 (x &lt;&lt; 3) + (x &lt;&lt; 2) + (x &lt;&lt; 1) = x * 14 일반 곱셈기 또한 내부에서 위의 방식으로 작동한다. 곱셈보다도 느리다므로 우측 시프트연산을 사용한다.\n각각 표현방식에 따라 논리 시프트(비부호형), 산술 시프트(2의 보수)를 사용함\n정수의 나눗셈에 대해 소수점 이하는 버린다고 정의했기 때문에 이에 맞추어 컴퓨터가 작동하게 보정을 해줘야함.\n기본적으로 시프트 연산을 마치면 결과는 버림이 아닌 내림으로 나옴 양수: 내림 = 버림\n음수: 내림 ≠ 버림 → -3.5 = -3 (버림) = -4 (내림) 따라서 이 값을 보정해주기위해 bias값을 사용한다. 가장 큰 오차를 더하는 것임. &nbsp;소수점이 있는 이진수로 2의 음의 거듭제곱이다.\n십진수에 무한소수가 있는 것처럼, 비율이진수 또한 무한 소수가 있다\n따라서 모든 수를 정확히 표현할 수 없고 근사값을 사용할 때가 많다. 부동소수점: 아주 큰 수 또는 아주 작은 수를 효율적으로 표현하기 위한 범용적인 숫자 표현 방식\n기본 공식: S: 부호 비트 → 0이면 양수, 1이면 음수\nM: 가수 실제 숫자의 유효 자릿수\n비율 이진수와 유사 E: 지수 2의 몇 제곱인지\nbias 값을 사용하여 부호 없이 음수, 양수를 모두 표현할 수 있도록함. 종류 <br><img src=\"⁵-file/image/pasted-image-20250529174514.png\" target=\"_self\">\n정규화 값 가장 일반적인 경우 지수 필드가 모두 0은 아니며, 모두 1이 아니어야 한다.\n가수 앞에 암묵적 ‘1.’ 이 존재함 비정규화 값 지수 필드가 모두 0일 때\n아주 작은 수를 표현할 때 사용\n가수 앞의 암묵적 1. 이 없음 → 0. 특수 값 지수 필드가 모두 1인 경우\n숫자가 아닌 것을 표현함\nNaN이나, 무한대 값을 표현함 정확하지 않은 경우가 많다 → 근사값값\n분배, 교환, 결합법칙이 성립하지 않는다 <br>값 0을 가짐<a href=\"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#fnref-1-ddff43e41cd65f11_0\" class=\"footnote-backref footnote-link\" target=\"_self\" rel=\"noopener nofollow\">↩︎</a>\n<br>대개 ASCII<a href=\"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#fnref-2-ddff43e41cd65f11_0\" class=\"footnote-backref footnote-link\" target=\"_self\" rel=\"noopener nofollow\">↩︎</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"정보의 표현과 처리","level":2,"id":"정보의_표현과_처리_0"},{"heading":"비트","level":3,"id":"비트_0"},{"heading":"컴퓨터의 숫자표현 기초","level":3,"id":"컴퓨터의_숫자표현_기초_0"},{"heading":"2.1 정보의 저장","level":3,"id":"2.1_정보의_저장_0"},{"heading":"2.1.1 16진수 표시","level":4,"id":"2.1.1_16진수_표시_0"},{"heading":"int t = *p","level":3,"id":"int_t_=_\\*p_0"},{"heading":"2.1.2 데이터의 크기","level":4,"id":"2.1.2_데이터의_크기_0"},{"heading":"다중 데이터 포멧","level":5,"id":"다중_데이터_포멧_0"},{"heading":"+) ✅ 자바나 파이썬과 비교해 보면?","level":6,"id":"+)_✅_자바나_파이썬과_비교해_보면?_0"},{"heading":"2.1.3 주소지정과 바이트 순서","level":4,"id":"2.1.3_주소지정과_바이트_순서_0"},{"heading":"정렬 관련 이슈","level":5,"id":"정렬_관련_이슈_0"},{"heading":"2.1.4 스트링의 표시","level":4,"id":"2.1.4_스트링의_표시_0"},{"heading":"2.1.5 코드의 표현","level":4,"id":"2.1.5_코드의_표현_0"},{"heading":"2.1.6 부울(Boolean) 대수","level":4,"id":"2.1.6_부울(Boolean)_대수_0"},{"heading":"비트 벡터","level":5,"id":"비트_벡터_0"},{"heading":"2.1.7 C에서의 비트수준 연산","level":4,"id":"2.1.7_C에서의_비트수준_연산_0"},{"heading":"2.1.8 C에서의 논리 연산","level":4,"id":"2.1.8_C에서의_논리_연산_0"},{"heading":"2.1.9 C에서의 쉬프트 연산","level":4,"id":"2.1.9_C에서의_쉬프트_연산_0"},{"heading":"2.2 정수의 표시","level":3,"id":"2.2_정수의_표시_0"},{"heading":"2.2.1 정수형 데이터 타입","level":4,"id":"2.2.1_정수형_데이터_타입_0"},{"heading":"2.2.2 비부호형의 인코딩","level":4,"id":"2.2.2_비부호형의_인코딩_0"},{"heading":"2.2.3 2의 보수(two’s complement) 인코딩","level":4,"id":"2.2.3_2의_보수(two’s_complement)_인코딩_0"},{"heading":"2.2.4 비부호형과 부호형 간의 변환","level":4,"id":"2.2.4_비부호형과_부호형_간의_변환_0"},{"heading":"2.2.5 C에서 부호형과 비부호형의 비교","level":4,"id":"2.2.5_C에서_부호형과_비부호형의_비교_0"},{"heading":"2.2.6 수의 비트 표시를 확장하기","level":4,"id":"2.2.6_수의_비트_표시를_확장하기_0"},{"heading":"2.2.7 숫자의 절삭","level":4,"id":"2.2.7_숫자의_절삭_0"},{"heading":"Signed와 Unsigned에 대한 조언","level":4,"id":"Signed와_Unsigned에_대한_조언_0"},{"heading":"2.3 정수의 산술 연산","level":3,"id":"2.3_정수의_산술_연산_0"},{"heading":"2.3.1 비부호형 덧셈","level":4,"id":"2.3.1_비부호형_덧셈_0"},{"heading":"2.3.2 2의 보수의 덧셈","level":4,"id":"2.3.2_2의_보수의_덧셈_0"},{"heading":"2.3.4 비부호형 곱셈 / 2.3.5 2의 보수 곱셈","level":4,"id":"2.3.4_비부호형_곱셈_/_2.3.5_2의_보수_곱셈_0"},{"heading":"2.3.6 상수를 사용한 곱셈","level":4,"id":"2.3.6_상수를_사용한_곱셈_0"},{"heading":"2.3.7 2의 제곱으로 나눗셈하기","level":4,"id":"2.3.7_2의_제곱으로_나눗셈하기_0"},{"heading":"2.4 부동소수점","level":3,"id":"2.4_부동소수점_0"},{"heading":"2.4.1 비율 이진수","level":4,"id":"2.4.1_비율_이진수_0"},{"heading":"2.4.2 IEEE 부동 소수점 표시","level":4,"id":"2.4.2_IEEE_부동_소수점_표시_0"},{"heading":"2.4.4 근사법","level":4,"id":"2.4.4_근사법_0"},{"heading":"2.4.5 부동소수점 연산","level":4,"id":"2.4.5_부동소수점_연산_0"}],"links":["dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#fn-1-ddff43e41cd65f11_0","dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#fn-2-ddff43e41cd65f11_0","dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#fnref-1-ddff43e41cd65f11_0","dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html#fnref-2-ddff43e41cd65f11_0"],"author":"","coverImageURL":"","fullURL":"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html","pathToRoot":"../..","attachments":["⁵-file/image/pasted-image-20250523213904.png","⁵-file/image/20250523_195539.jpg","⁵-file/image/pasted-image-20250529171635.png","⁵-file/image/pasted-image-20250529171701.png","⁵-file/image/pasted-image-20250529174514.png"],"createdTime":1748508530439,"modifiedTime":1748508532517,"sourceSize":19309,"sourcePath":"Dev Blog/CSAPP/컴퓨터시스템 CH2. 정보의 표현과 처리.md","exportPath":"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/2110.-공유기-설치.html":{"title":"2110. 공유기 설치","icon":"","description":"도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi&nbsp;(0 ≤ xi&nbsp;≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다. 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치\n→ 거리2, 거리8 (X) / 거리 5 거리 5 (O) 구하는 것 = 가장 인접한 두 공유기 사이의 거리의 최대값 → 이걸 이분 탐색 이 “최대값”이 의미하는 은 → upper-bound <a class=\"internal-link\" data-href=\"이분탐색 2.md\" href=\"¹-project/computer/algorithm-and-data-structure/이분탐색-2.html\" target=\"_self\" rel=\"noopener nofollow\">참고</a>\nupper bound인 이유 초과하는 첫 번째 값 == 설치가 불가능해지는 값\nupper bound -1을 하면 설치가 불가능해지기 바로 전 값이 도출됨 def installRouter(dist): cnt = C-1 i = 0 while cnt &gt; 0: for j in range(i, N): if (homes[j] - homes[i]) &gt;= dist: cnt -= 1 i = j break else: return -1 if homes[i] &lt; homes[-1]: # homes[i]: 마지막에 설치한 집의 위치 &lt; homes[-1]: 가장 먼 집의 위치 return 1 return 0 N,C = map(int, input().split(\" \")) homes = [] for _ in range(N): homes.append(int(input())) homes.sort() dl = 1 dr = (homes[-1] - homes[0] + 1) // (C-1) # 최대 거리 / 설치해야하는 공유기 개수 sameList = [0]*dr while dl &lt; dr: dm = (dr + dl) // 2 result = installRouter(dm) if result &gt;= 0: dl = dm + 1 else: dr = dm print(dr) 워낙에 문제가 많아서 뭐부터 지적해야할지 모르겠음.\nN, C = map(int, input().split()) homes = [int(input()) for _ in range(N)] homes.sort() dl = 1 dr = (homes[-1] - homes[0]) // (C-1) +1 while dl &lt; dr: cnt = C - 1 dm = (dr + dl) // 2 # 설치 i = 0 for j in range(i, N): d = homes[j] - homes[i] if d &gt;= dm: cnt -= 1 i = j if cnt &lt;= 0: # 설치가 많이 되었으면 dl = dm + 1 # 거리를 더 늘려야함 else: # 설치가 적게 되었으면 dr = dm # 거리를 줄여야함. print(dr-1) 수정 내용: 설치로직 간소화. 처음에는 하나 설치하고 for문 break하고, 다시 for문 들어와서 하나설치 하고의 반복 궅이 그럴 필요 없이 for문 하나에서 기준 집만 바꾸면서 탐색 지속\ndr 초기값을 늘려주기 종료조건이 dl &gt;= dr임. 즉. 같아지면 끝나는데. dr은 초기값에서 멈춰있고 dl이 dr과 같은 값으로 업데이트되면, dr(즉 마지막)을 탐색할 수 없음.\n단 범위를 넘어가는 값이 도출될 수 있으니 결과값으로 다시 리스트 요소에 접근하려면 주의해야함. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"입력","level":3,"id":"입력_0"},{"heading":"출력","level":3,"id":"출력_0"},{"heading":"풀이","level":2,"id":"풀이_0"},{"heading":"문제 이해","level":3,"id":"문제_이해_0"},{"heading":"실패","level":3,"id":"실패_0"},{"heading":"성공","level":3,"id":"성공_0"}],"links":["¹-project/computer/algorithm-and-data-structure/이분탐색-2.html"],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/2110.-공유기-설치.html","pathToRoot":"../..","attachments":[],"createdTime":1748513493693,"modifiedTime":1748516101394,"sourceSize":4184,"sourcePath":"Dev Blog/Coding Test/2110. 공유기 설치.md","exportPath":"dev-blog/coding-test/2110.-공유기-설치.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/2630.-색종이-자르기.html":{"title":"2630. 색종이 자르기","icon":"","description":"아래 &lt;그림 1&gt;과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고, 각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다. 주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다.<img alt=\"\" src=\"https://www.acmicpc.net/upload/images/bwxBxc7ghGOedQfiT3p94KYj1y9aLR.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"width: 215px; max-width: 100%;\">전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다.전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 &lt;그림 2&gt;의 I, II, III, IV와 같이 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다. 나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다. 이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다.위와 같은 규칙에 따라 잘랐을 때 &lt;그림 3&gt;은 &lt;그림 1&gt;의 종이를 처음 나눈 후의 상태를, &lt;그림 4&gt;는 두 번째 나눈 후의 상태를, &lt;그림 5&gt;는 최종적으로 만들어진 다양한 크기의 9장의 하얀색 색종이와 7장의 파란색 색종이를 보여주고 있다.<br><img alt=\"\" src=\"https://www.acmicpc.net/upload/images/VHJpKWQDv.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"width: 480px; max-width: 100%;\">입력으로 주어진 종이의 한 변의 길이 N과 각 정사각형칸의 색(하얀색 또는 파란색)이 주어질 때 잘라진 하얀색 색종이와 파란색 색종이의 개수를 구하는 프로그램을 작성하시오.첫째 줄에는 전체 종이의 한 변의 길이 N이 주어져 있다. N은 2, 4, 8, 16, 32, 64, 128 중 하나이다. 색종이의 각 가로줄의 정사각형칸들의 색이 윗줄부터 차례로 둘째 줄부터 마지막 줄까지 주어진다. 하얀색으로 칠해진 칸은 0, 파란색으로 칠해진 칸은 1로 주어지며, 각 숫자 사이에는 빈칸이 하나씩 있다.첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고, 둘째 줄에는 파란색 색종이의 개수를 출력한다.\n<br><a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/1074. Z.md\" href=\"dev-blog/coding-test/1074.-z.html#_0\" target=\"_self\" rel=\"noopener nofollow\">1074. Z</a>와 비슷한 문제\ndef cut_paper(x, y, n): global blue global white if n == 1: if papers[x][y] == 1: return 1 else: return 0 pieces = [0,0,0] n //= 2 for i in a: p = cut_paper(x+(n*i[0]), y+n*(i[1]), n) pieces[p] += 1 if pieces[0] == 4: return 0 if pieces[1] == 4: return 1 white += pieces[0] blue += pieces[1] return 2 N = int(input()) papers = [list(map(int, input().split())) for _ in range(N)] a = [[0,0], [0,1], [1,0], [1,1]] blue = 0 white = 0 p = cut_paper(0,0, N) if p == 0: white += 1 elif p == 1: blue += 1 print(white) print(blue) 내가 생각했던 풀이 일단 다 나누고 병합하면서 다 같은 색인지 체크후 다 같은 색이면 0이나 1을 return함\n나중에 합친 영역 내에 다른 색이 생겼을 때, 즉 색종이 색 단일성이 깨졌을 때 합치기 바로 이전의 종이 사이즈로 종이를 자른다고 확정! 별로 였던게, 종이 전체가 모두 같은 색이면 마지막 병합 후에 함수 바깥에서 한번 더 체크해줘야함. 색종이에 단일 성이 깨졌을 때 종이 사이즈를 확정하는데, 색종이 색의 단일성이 깨어지는 결합이 없기 때문. def cut_paper(x, y, n): color = papers[x][y] same = True for i in range(x, x+n): for j in range(y, y+n): if papers[i][j] != color: same = False break if same: colors[color] += 1 return n //= 2 for i in a: cut_paper(x + (n * i[0]), y + n * (i[1]), n) return N = int(input()) papers = [list(map(int, input().split())) for _ in range(N)] a = [[0,0], [0,1], [1,0], [1,1]] colors = [0,0 ] cut_paper(0,0, N) print(colors[0]) print(colors[1]) input = __import__('sys').stdin.readline gpt가 추천해준방법 일단 탐색해서 영역 내에 여러 색이 섞여있으면 잘라 들어가기.\n이전에는 자르고 붙이면서 판단했다면, 얘는 판단하고 자름 웃긴게 이전 Z에서도 비슷한 사고방식으로 시간초과가 났었는데, 이번에도 더 복잡(?) 지저분(?)한 코드를 씀.\n분할정복 문제는 판단하고 넘어갈지, 넘어갔다 돌아와서 판단할지를 잘 생각해볼것\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"입력","level":3,"id":"입력_0"},{"heading":"출력","level":3,"id":"출력_0"},{"heading":"풀이","level":2,"id":"풀이_0"},{"heading":"성공 1","level":3,"id":"성공_1_0"},{"heading":"성공2","level":3,"id":"성공2_0"}],"links":["dev-blog/coding-test/1074.-z.html#_0"],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/2630.-색종이-자르기.html","pathToRoot":"../..","attachments":[],"createdTime":1748516297140,"modifiedTime":1748516535689,"sourceSize":5221,"sourcePath":"Dev Blog/Coding Test/2630. 색종이 자르기.md","exportPath":"dev-blog/coding-test/2630.-색종이-자르기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/2470.-두-용액.html":{"title":"2470. 두 용액","icon":"","description":"KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.def bs(lo, hi): while lo&lt;=hi: mid = (lo+hi)//2 solution = lst[i] + lst[mid] if solution == 0: print(min(i, mid), max(i, mid)) exit() elif solution &gt; 0: hi = mid - 1 else: lo = mid + 1 return lo - 1 N = int(input()) lst = list(map(int, input().split())) lst.sort() if len(lst) == 2: print(lst[0], lst[1]) exit() minV = int(1e9) minI = (0,0) for i in range(N): j1 = bs(0, i-1) j2 = bs(i+1, N-1) j = j1 if abs(lst[i] + lst[j1]) &gt; abs(lst[i] + lst[j2]): j = j2 newM = abs(lst[i] + lst[j]) if newM &lt; minV: minI = (min(i,j), max(i,j)) print(lst[minI[0]], lst[minI[1]]) 어려웠던 점: 자기자신을 제외한 이분탐색을 구현하는 것.\nimport sys N = int(input()) lst = list(map(int, input().split())) lst.sort() s = 0 e = N-1 minMix = sys.maxsize minIdx = (0,0) while s&lt;e: newMix = lst[s] + lst[e] if newMix == 0: print(lst[s], lst[e]) break if abs(newMix) &lt; minMix: minMix = abs(newMix) minIdx = (s, e) if newMix &lt; 0: s += 1 else: e -= 1 else: print(lst[minIdx[0]], lst[minIdx[1]]) 양쪽에서 포인터 하나씩 잡고 비교하면서 서로 가까워지게 포인터를 옮기는 코드 → 시간 복잡도가 O(n)밖에 안 됨 → 내가 생각한 이분탐색 코드(O(nlogn))보다 훨씬 효율적임\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"입력","level":3,"id":"입력_0"},{"heading":"출력","level":3,"id":"출력_0"},{"heading":"풀이","level":2,"id":"풀이_0"},{"heading":"이분탐색 풀이 → 실패 (나중에 다시 해보기)","level":3,"id":"이분탐색_풀이_→_실패_(나중에_다시_해보기)_0"},{"heading":"투포인터 풀이 → 성공","level":3,"id":"투포인터_풀이_→_성공_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/2470.-두-용액.html","pathToRoot":"../..","attachments":[],"createdTime":1748516317016,"modifiedTime":1748516325225,"sourceSize":4289,"sourcePath":"Dev Blog/Coding Test/2470. 두 용액.md","exportPath":"dev-blog/coding-test/2470.-두-용액.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/1629.-곱셈.html":{"title":"1629. 곱셈","icon":"","description":"자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.def times(num, cnt, div): if cnt == 1: return num if cnt % 2 == 0: return (times(num, cnt//2, div)*times(num, cnt//2, div)) % div else: return (times(num, cnt//2, div)*times(num, cnt//2+1, div)) % div A,B,C = map(int, input().split()) A %= C print(times(A, B, C)) 원래는 그냥 (A**B)%C 하면 되는데,\n문제는 숫자가 너무 커서 중간에 overflow가 생길 수 있다는 점이다. 그래서 for 문으로 A 하나하나 곱할 때 마다 %C를 해주는 방식을 취하면 O(N)으로 시간 초과가 난다 (0.5초짜리 문제임)\n분할 정복을 그래서 사용해야하는데, B번 곱해야할 걸 B//2번, B//4번, ... 이렇게 작은 문제로 쪼개는 거다. 여기서는 쪼갤 때, (B//2) * (B//2)같은 방식으로 하면 똑같이 시간 초과가 난다. 따라서 (B//2)**2와 같이 작성 또한 홀수의 경우 딱 이등분이 되지 않으므로, * A를 한번더 해준다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"입력","level":3,"id":"입력_0"},{"heading":"출력","level":3,"id":"출력_0"},{"heading":"풀이","level":2,"id":"풀이_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/1629.-곱셈.html","pathToRoot":"../..","attachments":[],"createdTime":1748516334662,"modifiedTime":1748516552987,"sourceSize":1822,"sourcePath":"Dev Blog/Coding Test/1629. 곱셈.md","exportPath":"dev-blog/coding-test/1629.-곱셈.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/2493.-탑.html":{"title":"2493. 탑","icon":"","description":"KOI 통신연구소는 레이저를 이용한 새로운 비밀 통신 시스템 개발을 위한 실험을 하고 있다. 실험을 위하여 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고, 탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다. 하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다.예를 들어 높이가 6, 9, 5, 7, 4인 다섯 개의 탑이 수평 직선에 일렬로 서 있고, 모든 탑에서는 주어진 탑 순서의 반대 방향(왼쪽 방향)으로 동시에 레이저 신호를 발사한다고 하자. 그러면, 높이가 4인 다섯 번째 탑에서 발사한 레이저 신호는 높이가 7인 네 번째 탑이 수신을 하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신을 한다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신을 하지 못한다.탑들의 개수 N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 프로그램을 작성하라.첫째 줄에 탑의 수를 나타내는 정수 N이 주어진다. N은 1 이상 500,000 이하이다. 둘째 줄에는 N개의 탑들의 높이가 직선상에 놓인 순서대로 하나의 빈칸을 사이에 두고 주어진다. 탑들의 높이는 1 이상 100,000,000 이하의 정수이다.첫째 줄에 주어진 탑들의 순서대로 각각의 탑들에서 발사한 레이저 신호를 수신한 탑들의 번호를 하나의 빈칸을 사이에 두고 출력한다. 만약 레이저 신호를 수신하는 탑이 존재하지 않으면 0을 출력한다.N = int(input()) buildings = list(map(int, input().split())) receivers = [0]*N # 지금까지중에 가장 높았던 빌딩이자, 마지막 0highestIdx = 0 for i in range(1, N): nowB = buildings[i] # 지금까지 중에 가장 높은 빌딩이면 if nowB &gt;= buildings[highestIdx]: receivers[i] = 0 highestIdx = i continue for j in range(i-1, highestIdx-1, -1): # 반대로 돌리면서 # 나보다 높은 빌딩을 만나면 if nowB &lt; buildings[j]: receivers[i] = j+1 break else: receivers[i] = 0 highestIdx = i print(*receivers) 따로 pop하는 거 없이 내 앞에 있는 거 (수신탑 만나기 전까지) 계속 탐색\nlastZero로 탐색범위 줄여봤는데 시간초과 → 나중에 따져봤는데 이것 때문에 정답이 틀려질 수도 있을듯\nfrom collections import deque N = int(input()) buildings = list(map(int, input().split())) checkB = deque() checkB.append([0, buildings[0]]) receivers = [0]*N for i in range(1, N): while True: if len(checkB) == 0: receivers[i] = 0 break now = buildings[i] last = checkB[-1] if now &gt;= last[1]: checkB.pop() else: receivers[i] = last[0] + 1 break checkB.append([i, buildings[i]]) print(*receivers) 많은 참고와 도움으로 푼 코드라 다시 풀어야함\n감소수열을 만들어서 탐색범위를 좁게해야한다는게 포인트\n내가 어려웠던 부분은 pop을 하면 처음 인덱스값과 이후 인덱스 값이 달라지는데 어떻게 올바른 인덱스 값을 출력할 수 있는가? 고민 많이 했는데, 그냥 인덱스값도 저장하면됨. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"입력","level":3,"id":"입력_0"},{"heading":"출력","level":3,"id":"출력_0"},{"heading":"풀이","level":2,"id":"풀이_0"},{"heading":"시간초과","level":3,"id":"시간초과_0"},{"heading":"성공 → 다시 풀기","level":3,"id":"성공_→_다시_풀기_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/2493.-탑.html","pathToRoot":"../..","attachments":[],"createdTime":1748516346864,"modifiedTime":1748516563270,"sourceSize":4423,"sourcePath":"Dev Blog/Coding Test/2493. 탑.md","exportPath":"dev-blog/coding-test/2493.-탑.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/3190.-뱀.html":{"title":"3190. 뱀","icon":"","description":"'Dummy' 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.\n먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.\n만약 벽이나 자기자신의 몸과 부딪히면 게임이 끝난다.\n만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.\n만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.\n사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100)다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다.다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100)다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데, 정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 'L') 또는 오른쪽(C가 'D')로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.첫째 줄에 게임이 몇 초에 끝나는지 출력한다.from collections import deque input = __import__(\"sys\").stdin.readline N = int(input()) # 보드 크기 K = int(input()) # 사과 개수 apples = [[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(K): temp = list(map(int, input().rstrip().split())) apples[temp[0]][temp[1]] = 1 L = int(input()) # 뱡향 전환 횟수 dirs = [0]*10001 for _ in range(L): temp = list(input().rstrip().split()) dirs[int(temp[0])] = temp[1] snake = deque() snake.append((1,1)) cnt = 0 x = 1 y = 2 D = [[0,1], [1, 0], [0,-1], [-1,0]] Di = 0 while True: cnt += 1 # 벽 판별 if x &lt; 1 or y &lt; 1 or x &gt; N or y &gt; N: print(cnt) break # 뱀 판별 if (x, y) in snake: print(cnt) break snake.append((x, y)) if apples[x][y] == 1: # 사과 get apples[x][y] = 0 else: snake.popleft() if dirs[cnt] != 0: if dirs[cnt] == \"D\": Di = (Di + 1) % 4 # 오른쪽 else: Di = (Di - 1) % 4 # 왼쪽 x += D[Di][0] y += D[Di][1] 중간에 한번 실패 했었는데, 그 이유가 xy좌표를 혼동해서임. 이차원 배열에서 xy좌표로 접근할때, 제대로 사용했는지 질 확인하기.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"입력","level":3,"id":"입력_0"},{"heading":"출력","level":3,"id":"출력_0"},{"heading":"풀이","level":2,"id":"풀이_0"},{"heading":"성공","level":3,"id":"성공_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/3190.-뱀.html","pathToRoot":"../..","attachments":[],"createdTime":1748516357266,"modifiedTime":1748516569794,"sourceSize":3758,"sourcePath":"Dev Blog/Coding Test/3190. 뱀.md","exportPath":"dev-blog/coding-test/3190.-뱀.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/1655.-가운데를-말해요.html":{"title":"1655. 가운데를 말해요","icon":"","description":"백준이는 동생에게 \"가운데를 말해요\" 게임을 가르쳐주고 있다. 백준이가&nbsp;정수를 하나씩 외칠때마다 동생은 지금까지 백준이가 말한 수 중에서 중간값을 말해야 한다. 만약, 그동안 백준이가 외친 수의 개수가 짝수개라면 중간에 있는 두 수 중에서 작은 수를 말해야 한다.예를 들어 백준이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 백준이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.첫째 줄에는 백준이가 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서 백준이가 외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.한 줄에 하나씩 N줄에 걸쳐 백준이의 동생이 말해야 하는 수를 순서대로 출력한다.import heapq input = __import__(\"sys\").stdin.readline N = int(input()) a = int(input()) print(a) if N == 1: exit() b = int(input()) print(min(a,b)) smallMaxH = [-min(a, b)] bigMinH = [max(a, b)] for _ in range(N-2): num = int(input()) # 삽입 if num &lt; -smallMaxH[0]: heapq.heappush(smallMaxH, -num) elif num &gt; bigMinH[0]: heapq.heappush(bigMinH, num) else: if len(smallMaxH) &lt; len(bigMinH): heapq.heappush(smallMaxH, -num) else: heapq.heappush(bigMinH, num) # 균형 맞추기 diff = len(smallMaxH) - len(bigMinH) if diff == -2: heapq.heappush(smallMaxH, -heapq.heappop(bigMinH)) elif diff == 2: heapq.heappush(bigMinH, -heapq.heappop(smallMaxH)) diff = len(smallMaxH) - len(bigMinH) # 중앙값 구하기 if diff &gt;= 0: print(-smallMaxH[0]) else: print(bigMinH[0]) 정말 상상하지도 못한 접근법이어서 보고나서 우울했음\n다음에는 더 깔끔한 코드가 있는지 고민해보기 특히 입력시킬 때, 2개의 큐 중에 어느 큐에 값을 넣어야할지 고민하는 판단 코드가 필요한지. 그냥 균형맞추는 부분에서 자동적으로 값의 밸런스가 잡히는지 확인해보기 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"입력","level":3,"id":"입력_0"},{"heading":"출력","level":3,"id":"출력_0"},{"heading":"풀이 → 다시풀기","level":2,"id":"풀이_→_다시풀기_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/1655.-가운데를-말해요.html","pathToRoot":"../..","attachments":[],"createdTime":1748516368122,"modifiedTime":1748516576902,"sourceSize":3012,"sourcePath":"Dev Blog/Coding Test/1655. 가운데를 말해요.md","exportPath":"dev-blog/coding-test/1655.-가운데를-말해요.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/8983.-사냥꾼.html":{"title":"8983. 사냥꾼","icon":"","description":"KOI 사냥터에는 N 마리의 동물들이 각각 특정한 위치에 살고 있다. 사냥터에 온 사냥꾼은 일직선 상에 위치한 M 개의 사대(총을 쏘는 장소)에서만 사격이 가능하다. 편의상, 일직선을 x-축이라 가정하고, 사대의 위치 x1, x2, ..., xM은 x-좌표 값이라고 하자. 각 동물이 사는 위치는 (a1, b1), (a2, b2), ..., (aN, bN)과 같이 x,y-좌표 값으로 표시하자. 동물의 위치를 나타내는 모든 좌표 값은 양의 정수이다.사냥꾼이 가지고 있는 총의 사정거리가 L이라고 하면, 사냥꾼은 한 사대에서 거리가 L 보다 작거나 같은 위치의 동물들을 잡을 수 있다고 한다. 단, 사대의 위치 xi와 동물의 위치 (aj, bj) 간의 거리는 |xi-aj| + bj로 계산한다.예를 들어, 아래의 그림과 같은 사냥터를 생각해 보자. (사대는 작은 사각형으로, 동물의 위치는 작은 원으로 표시되어 있다.) 사정거리 L이 4라고 하면, 점선으로 표시된 영역은 왼쪽에서 세 번째 사대에서 사냥이 가능한 영역이다.<img alt=\"\" src=\"https://upload.acmicpc.net/80de7dba-b822-4f30-b833-de3071af385b/-/preview/\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\" style=\"width: 320px; max-width: 100%;\">사대의 위치와 동물들의 위치가 주어졌을 때, 잡을 수 있는 동물의 수를 출력하는 프로그램을 작성하시오.입력의 첫 줄에는 사대의 수 M (1 ≤ M ≤ 100,000), 동물의 수 N (1 ≤ N ≤ 100,000), 사정거리 L (1 ≤ L ≤ 1,000,000,000)이 빈칸을 사이에 두고 주어진다. 두 번째 줄에는 사대의 위치를 나타내는 M개의 x-좌표 값이 빈칸을 사이에 두고 양의 정수로 주어진다. 이후 N개의 각 줄에는 각 동물의 사는 위치를 나타내는 좌표 값이 x-좌표 값, y-좌표 값의 순서로 빈칸을 사이에 두고 양의 정수로 주어진다. 사대의 위치가 겹치는 경우는 없으며, 동물들의 위치가 겹치는 경우도 없다. 모든 좌표 값은 1,000,000,000보다 작거나 같은 양의 정수이다.출력은 단 한 줄이며, 잡을 수 있는 동물의 수를 음수가 아닌 정수로 출력한다.input = __import__(\"sys\").stdin.readline M, N, L = map(int, input().split()) guns = list(map(int, input().split())) guns.sort() yList = [0] * (guns[-1] + L + 1) for g in guns: for l in range(1, L): yList[g] = L if (g - 1 &gt; 0) and (yList[g - l] &lt; L - l): yList[g - l] = L - l else: break for l in range(1, L): if yList[g + l] &lt; L - l: yList[g + l] = L - l else: break cnt = 0 for _ in range(N): x,y = map(int, input().split()) if len(yList) &gt;= x and yList[x] &gt;= y: cnt += 1 print(cnt) 문제1: 메모리 초과 1번 yList가 최악의 메모리를 가지는 경우가 1000000000 + 1000000000 + 1임...\n이걸 파악하지 못하고 무지성으로 짬.\n앞으로 인풋값이 큰 경우나 시간초과, 메모리초과가 날때는 인풋 개수 보면서 하나하나 따져보기 문제2: 시간초과 인풋값이 커지면 통과가 안되는건 어디선가 시간이 많이 투자되고 있는건데\n나는 원래 마지막 for문 동물 위치 받아서 잡을 수 있는 동물인지 확인하는 부분을 줄이려고 했음 그 위에 y_list 너무 깔끔하게 짰다고 생각해서..ㅋ\n그런데 사실 그 yList 만드는 부분이 문제였음. 생각해보면, 여기서 대부분의 연산을 다하고(뒤에서는 비교만 하면됨) 심지어 얘만 이중 for문인데. def findLR(n): # n = 동물의 x좌표 S = 0 # guns 좌표값에 대한 인덱스 E = len(guns)-1 if n &gt; guns[E]: return E, -1 # max(사대 좌표값 들) &lt; 동물 좌표 elif n &lt; guns[S]: return -1, S # min(사대 좌표값 들) &gt; 동물 좌표 while S &lt; E: # upper bound 연산 mid = (S + E) // 2 if guns[mid] &lt;= n: S = mid + 1 else: E = mid if n == guns[S-1]: return S-1, S-1 # 이분탐색 결과 찾은 위치 -1의 값이 동물 좌표랑 동일하면, else: return S - 1, E # 아니면 범위 return M, N, L = map(int, input().split()) guns = list(map(int, input().split())) guns.sort() cnt = 0 for _ in range(N): x, y = map(int, input().split()) # 동물 위치 s, e = findLR(x) # 동물 위치와 가장 가까운 사대 2개의 index diff = 0 if s != e: if e == -1: diff = x - guns[s] if s == -1: diff = guns[e] - x else: diff = min(x - guns[s], guns[e] - x) if y &lt;= L-diff: cnt += 1 print(cnt) yList로 다 세팅해놓는게 아니라, 동물 좌표 받으면 가까운 사대 위치를 이분 탐색으로 찾아서 연산하는 방식으로 변경\ndef findUpper(n, arr): # n = 동물의 x좌표 S = 0 # guns 좌표값에 대한 인덱스 E = len(arr) while S &lt; E: # upper bound 연산 mid = (S + E) // 2 if arr[mid] &lt;= n: S = mid + 1 else: E = mid else: return E M, N, L = map(int, input().split()) guns = list(map(int, input().split())) guns.sort() # 동물 받기 animals = {} for _ in range(N): x, y = map(int, input().split()) if x in animals: animals[x] = animals[x].append(y) else: animals[x] = [y] cnt = 0 for x in animals: # 해당 x에서 쏠 수 있는 거리(gunY) 구하기 e = findUpper(x, guns) # 오른쪽에서 가까운 사대의 위치 s = e-1 # 왼쪽에서 가까운 사대의 위치 diff = 0 if s &lt; 0: # 주어진 x가 가장 작은 사대 위치보다도 작은 값일때, diff = guns[e] - x elif e &gt;= len(guns): # 주어진 x가 가장 큰 사대 위치보다도 큰 값일 때, diff = x - guns[s] else: diff = min(x - guns[s], guns[e] - x) gunY = L-diff # 어느 동물까지 사정거리에 들어오는 지. ys = animals[x] ys.sort() cnt += findUpper(gunY, ys) print(cnt) 동물 위치 다 받아서 x값 기준으로 dic을 만들고 이것 또한 정렬해서 이분탐을 돌림 = 어느 위치의 동까지 쏠 수 있는지 확인 용으로\n저장했다 뺐다 하는 게 생각보다 품이 많이 들었음.\ndef findUpper(n, arr): # n = 동물의 x좌표 S = 0 # guns 좌표값에 대한 인덱스 E = len(arr) while S &lt; E: # upper bound 연산 mid = (S + E) // 2 if arr[mid] &lt;= n: S = mid + 1 else: E = mid else: return E M, N, L = map(int, input().split()) guns = list(map(int, input().split())) guns.sort() cnt = 0 dicY = {} for _ in range(N): x, y = map(int, input().split()) # 동물 위치 # 해당 x에서 쏠 수 있는 거리(gunY) 구하기 if x in dicY: gunY = dicY[x] else: e = findUpper(x, guns) # 오른쪽에서 가까운 사대의 위치 s = e - 1 # 왼쪽에서 가까운 사대의 위치 diff = 0 if s &lt; 0: # 주어진 x가 가장 작은 사대 위치보다도 작은 값일때, diff = guns[e] - x elif e &gt;= len(guns): # 주어진 x가 가장 큰 사대 위치보다도 큰 값일 때, diff = x - guns[s] else: diff = min(x - guns[s], guns[e] - x) gunY = L - diff dicY[x] = gunY if y &lt;= gunY: cnt += 1 print(cnt) 일단 풀이 2로 돌아감\n매번 이분탐색을 진행하는 건 품이 많이드니까\n특정 x값에 대해서 탐색한 결과값을 dict에 저장해둠\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"입력","level":3,"id":"입력_0"},{"heading":"출력","level":3,"id":"출력_0"},{"heading":"풀이","level":2,"id":"풀이_0"},{"heading":"풀이 1 → sub task 2까지","level":3,"id":"풀이_1_→_sub_task_2까지_0"},{"heading":"풀이2 → sub task 3까지 통과","level":3,"id":"풀이2_→_sub_task_3까지_통과_0"},{"heading":"풀이3 → sub task 1로 돌아옴","level":3,"id":"풀이3_→_sub_task_1로_돌아옴_0"},{"heading":"풀이4 → 성공","level":3,"id":"풀이4_→_성공_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/8983.-사냥꾼.html","pathToRoot":"../..","attachments":[],"createdTime":1748516380023,"modifiedTime":1748516583919,"sourceSize":8598,"sourcePath":"Dev Blog/Coding Test/8983. 사냥꾼.md","exportPath":"dev-blog/coding-test/8983.-사냥꾼.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/2504.-괄호의-값.html":{"title":"2504. 괄호의 값","icon":"","description":"4개의 기호 ‘(’, ‘)’, ‘[’, ‘]’를 이용해서 만들어지는 괄호열 중에서 올바른 괄호열이란 다음과 같이 정의된다.\n한 쌍의 괄호로만 이루어진 ‘()’와 ‘[]’는 올바른 괄호열이다.\n만일&nbsp;X가 올바른 괄호열이면 ‘(X)’이나 ‘[X]’도 모두 올바른 괄호열이 된다.\nX와&nbsp;Y&nbsp;모두 올바른 괄호열이라면 이들을 결합한&nbsp;XY도 올바른 괄호열이 된다.\n예를 들어 ‘(()[[]])’나 ‘(())[][]’ 는 올바른 괄호열이지만 ‘([)]’ 나 ‘(()()[]’ 은 모두 올바른 괄호열이 아니다. 우리는 어떤 올바른 괄호열&nbsp;X에 대하여 그 괄호열의 값(괄호값)을 아래와 같이 정의하고 값(X)로 표시한다.\n‘()’ 인 괄호열의 값은 2이다.\n‘[]’ 인 괄호열의 값은 3이다.\n‘(X)’ 의 괄호값은 2×값(X) 으로 계산된다.\n‘[X]’ 의 괄호값은 3×값(X) 으로 계산된다.\n올바른 괄호열&nbsp;X와&nbsp;Y가 결합된&nbsp;XY의 괄호값은 값(XY)= 값(X)+값(Y) 로 계산된다.\n예를 들어 ‘(()[[]])([])’ 의 괄호값을 구해보자. ‘()[[]]’ 의 괄호값이 2 + 3×3=11 이므로 ‘(()[[]])’의 괄호값은 2×11=22 이다. 그리고 ‘([])’의 값은 2×3=6 이므로 전체 괄호열의 값은 22 + 6 = 28 이다.여러분이 풀어야 할 문제는 주어진 괄호열을 읽고 그 괄호값을 앞에서 정의한대로 계산하여 출력하는 것이다.첫째 줄에 괄호열을 나타내는 문자열(스트링)이 주어진다. 단 그 길이는 1 이상, 30 이하이다.첫째 줄에 그 괄호열의 값을 나타내는 정수를 출력한다. 만일 입력이 올바르지 못한 괄호열이면 반드시 0을 출력해야 한다.from collections import deque def checkSameLv(close): global i close = close[0] score = close[1] sum = 1 stk.append(p[i]) while True: if i &gt;= I: # 다 안 닫혔는데, input 끝남 print(0) exit() if p[i] == close: # 제대로 닫힘 return score * sum if p[i] in closes: # 새로운게 열리면. sum += checkSameLv(closes[p[i]]) continue else: # 다른게 닫히면 print(0) exit() p = input() closes = {'(': (')', 2), '[': (']', 3)} i = 1 I = len(p) stk = deque() stk.append(p[0]) result = 0 while i &lt; I: result += checkSameLv(closes[p[i]]) if len(stk) == 0: print(result) else: print(0) 괄호 깊이를 기준으로 재귀를 돌려 풀려고 했는데, 예제부터 재귀가 깊다고 실패 → 코드 자체를 잘걸 수도 있음\nfrom collections import deque p = input() stk = deque() closes = {'(': ')', '[': ']'} scores = {')': 2, ']': 3} for i in range(len(p)): if p[i] in closes: stk.append(p[i]) continue # pop을 해야함 add = 0 while True: if len(stk) == 0: print(0) exit() if isinstance(stk[-1], int): add += stk.pop() continue close = closes[stk[-1]] score = scores[p[i]] if p[i] == close: # 제대로 닫힘 stk.pop() stk.append(max(score, score * add)) break else: print(0) exit() try: print(sum(stk)) except: print(0) 성공은 했지만 시간이 좀 걸려서 gpt 한테 물어봤는데, 이해 못 함. <a data-tooltip-position=\"top\" aria-label=\"https://chatgpt.com/share/6836c1c1-89d0-800a-9462-81bd2de8746e\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://chatgpt.com/share/6836c1c1-89d0-800a-9462-81bd2de8746e\" target=\"_self\">ChatGPT - 괄호값 계산 최적화</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"입력","level":3,"id":"입력_0"},{"heading":"출력","level":3,"id":"출력_0"},{"heading":"풀이","level":2,"id":"풀이_0"},{"heading":"실패","level":3,"id":"실패_0"},{"heading":"성공","level":3,"id":"성공_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/2504.-괄호의-값.html","pathToRoot":"../..","attachments":[],"createdTime":1748516392587,"modifiedTime":1748516593961,"sourceSize":4251,"sourcePath":"Dev Blog/Coding Test/2504. 괄호의 값.md","exportPath":"dev-blog/coding-test/2504.-괄호의-값.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"dev-blog/coding-test/10830.-행렬-제곱.html":{"title":"10830. 행렬 제곱","icon":"","description":"크기가 N*N인 행렬 A가 주어진다. 이때, A의 B제곱을 구하는 프로그램을 작성하시오. 수가 매우 커질 수 있으니, A^B의 각 원소를 1,000으로 나눈 나머지를 출력한다.첫째 줄에 행렬의 크기 N과 B가 주어진다. (2&nbsp;≤ N ≤ &nbsp;5, 1 ≤ B ≤ 100,000,000,000)둘째 줄부터 N개의 줄에 행렬의 각 원소가&nbsp;주어진다. 행렬의 각 원소는 1,000보다 작거나 같은&nbsp;자연수 또는 0이다.첫째 줄부터 N개의 줄에 걸쳐 행렬 A를 B제곱한 결과를 출력한다.def dq(b): if b == 1: return A a = dq(b//2) r = matrix_mul(a,a) if b % 2 == 0: return r else: return matrix_mul(r, A) def matrix_mul(a, c): result = [[0 for _ in range(N)] for _ in range(N)] for i in range(N): for j in range(N): for k in range(N): result[i][j] += (a[i][k] * c[k][j]) %1000 result[i][j] %= 1000 return result N, B = map(int,input().split()) A = [list(map(int, input().split())) for _ in range(N)] D = dq(B) for i in A: for j in range(N): i[j] = i[j]%1000 for i in range(N): print(*D[i]) <a class=\"internal-link\" data-href=\"Dev Blog/Coding Test/1629. 곱셈.md\" href=\"dev-blog/coding-test/1629.-곱셈.html#_0\" target=\"_self\" rel=\"noopener nofollow\">1629. 곱셈</a> 문제랑 유사한데, 재귀 구조를 짜는게 훨씬 힘들었음.\n분할 하는건 괜찮은데 분할하고 어떻게 시간복잡도를 줄일 것인지도 어려웠고\n간접재귀다 보니까 구조가 더 헷갈렸던 것 같음\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"문제","level":2,"id":"문제_0"},{"heading":"입력","level":3,"id":"입력_0"},{"heading":"출력","level":3,"id":"출력_0"},{"heading":"풀이","level":2,"id":"풀이_0"}],"links":["dev-blog/coding-test/1629.-곱셈.html#_0"],"author":"","coverImageURL":"","fullURL":"dev-blog/coding-test/10830.-행렬-제곱.html","pathToRoot":"../..","attachments":[],"createdTime":1748516403412,"modifiedTime":1748516617808,"sourceSize":1934,"sourcePath":"Dev Blog/Coding Test/10830. 행렬 제곱.md","exportPath":"dev-blog/coding-test/10830.-행렬-제곱.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"}},"fileInfo":{"dev-blog/dev-blog.html":{"createdTime":1747966599472,"modifiedTime":1748516603708,"sourceSize":501,"sourcePath":"Dev Blog/Dev Blog.md","exportPath":"dev-blog/dev-blog.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html":{"createdTime":1747966660132,"modifiedTime":1747967655090,"sourceSize":27451,"sourcePath":"Dev Blog/CSAPP/컴퓨터시스템 CH1. 컴퓨터 시스템으로의 여행.md","exportPath":"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/csapp/csapp.html":{"createdTime":1747966729672,"modifiedTime":1748508555827,"sourceSize":434,"sourcePath":"Dev Blog/CSAPP/CSAPP.md","exportPath":"dev-blog/csapp/csapp.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/10819.-차이를-최대로.html":{"createdTime":1747967132371,"modifiedTime":1748516250615,"sourceSize":2064,"sourcePath":"Dev Blog/Coding Test/10819. 차이를 최대로.md","exportPath":"dev-blog/coding-test/10819.-차이를-최대로.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/1074.-z.html":{"createdTime":1747967448873,"modifiedTime":1748516251654,"sourceSize":4722,"sourcePath":"Dev Blog/Coding Test/1074. Z.md","exportPath":"dev-blog/coding-test/1074.-z.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/9663.-n-queen.html":{"createdTime":1747967104607,"modifiedTime":1748516249393,"sourceSize":4211,"sourcePath":"Dev Blog/Coding Test/9663. N-Queen.md","exportPath":"dev-blog/coding-test/9663.-n-queen.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html":{"createdTime":1747967245829,"modifiedTime":1748516252435,"sourceSize":2404,"sourcePath":"Dev Blog/Coding Test/2869. 달팽이는 올라가고 싶다.md","exportPath":"dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/1978.-소수-찾기.html":{"createdTime":1747967228377,"modifiedTime":1748516253091,"sourceSize":1034,"sourcePath":"Dev Blog/Coding Test/1978. 소수 찾기.md","exportPath":"dev-blog/coding-test/1978.-소수-찾기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/9020.-골드바흐의-추측.html":{"createdTime":1747967208221,"modifiedTime":1748516253874,"sourceSize":2500,"sourcePath":"Dev Blog/Coding Test/9020. 골드바흐의 추측.md","exportPath":"dev-blog/coding-test/9020.-골드바흐의-추측.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/1065.-한수.html":{"createdTime":1747967185930,"modifiedTime":1748516254669,"sourceSize":2797,"sourcePath":"Dev Blog/Coding Test/1065. 한수.md","exportPath":"dev-blog/coding-test/1065.-한수.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/2628.-종이-자르기.html":{"createdTime":1747967166129,"modifiedTime":1748516255275,"sourceSize":3138,"sourcePath":"Dev Blog/Coding Test/2628. 종이 자르기.md","exportPath":"dev-blog/coding-test/2628.-종이-자르기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/1914.-하노이-탑.html":{"createdTime":1747967150421,"modifiedTime":1748516256154,"sourceSize":3659,"sourcePath":"Dev Blog/Coding Test/1914. 하노이 탑.md","exportPath":"dev-blog/coding-test/1914.-하노이-탑.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/10971.-외판원-순회2.html":{"createdTime":1747967063421,"modifiedTime":1747967065117,"sourceSize":3535,"sourcePath":"Dev Blog/Coding Test/10971. 외판원 순회2.md","exportPath":"dev-blog/coding-test/10971.-외판원-순회2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/2468.-안전지대.html":{"createdTime":1747966984125,"modifiedTime":1747966985548,"sourceSize":6416,"sourcePath":"Dev Blog/Coding Test/2468. 안전지대.md","exportPath":"dev-blog/coding-test/2468.-안전지대.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/coding-test.html":{"createdTime":1747966827839,"modifiedTime":1748516603704,"sourceSize":2823,"sourcePath":"Dev Blog/Coding Test/Coding Test.md","exportPath":"dev-blog/coding-test/coding-test.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/jungle/week-1.html":{"createdTime":1747967262300,"modifiedTime":1747983504600,"sourceSize":1114,"sourcePath":"Dev Blog/Jungle/Week 1.md","exportPath":"dev-blog/jungle/week-1.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/jungle/jungle.html":{"createdTime":1747967262300,"modifiedTime":1747983482799,"sourceSize":339,"sourcePath":"Dev Blog/Jungle/Jungle.md","exportPath":"dev-blog/jungle/jungle.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"index.html":{"createdTime":1747967820644,"modifiedTime":1748509141756,"sourceSize":587,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"site-lib/fonts/94f2f163d4b698242fef.otf":{"createdTime":1748588190127,"modifiedTime":1748588190127,"sourceSize":66800,"sourcePath":"","exportPath":"site-lib/fonts/94f2f163d4b698242fef.otf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/72505e6a122c6acd5471.woff2":{"createdTime":1748588190127,"modifiedTime":1748588190127,"sourceSize":104232,"sourcePath":"","exportPath":"site-lib/fonts/72505e6a122c6acd5471.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/2d5198822ab091ce4305.woff2":{"createdTime":1748588190126,"modifiedTime":1748588190126,"sourceSize":104332,"sourcePath":"","exportPath":"site-lib/fonts/2d5198822ab091ce4305.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c8ba52b05a9ef10f4758.woff2":{"createdTime":1748588190128,"modifiedTime":1748588190128,"sourceSize":98868,"sourcePath":"","exportPath":"site-lib/fonts/c8ba52b05a9ef10f4758.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cb10ffd7684cd9836a05.woff2":{"createdTime":1748588190129,"modifiedTime":1748588190129,"sourceSize":106876,"sourcePath":"","exportPath":"site-lib/fonts/cb10ffd7684cd9836a05.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/b5f0f109bc88052d4000.woff2":{"createdTime":1748588190130,"modifiedTime":1748588190130,"sourceSize":105804,"sourcePath":"","exportPath":"site-lib/fonts/b5f0f109bc88052d4000.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cbe0ae49c52c920fd563.woff2":{"createdTime":1748588190130,"modifiedTime":1748588190130,"sourceSize":106108,"sourcePath":"","exportPath":"site-lib/fonts/cbe0ae49c52c920fd563.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/535a6cf662596b3bd6a6.woff2":{"createdTime":1748588190131,"modifiedTime":1748588190131,"sourceSize":111708,"sourcePath":"","exportPath":"site-lib/fonts/535a6cf662596b3bd6a6.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1748588190149,"modifiedTime":1748588190149,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1748588190150,"modifiedTime":1748588190150,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1748588190132,"modifiedTime":1748588190132,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1748588190150,"modifiedTime":1748588190150,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1748588190122,"modifiedTime":1748588190122,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1748588190122,"modifiedTime":1748588190122,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/2308ab1944a6bfa5c5b8.svg":{"createdTime":1748588190123,"modifiedTime":1748588190123,"sourceSize":278,"sourcePath":"","exportPath":"site-lib/media/2308ab1944a6bfa5c5b8.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1748588190703,"modifiedTime":1748588190703,"sourceSize":15718,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1748560289117,"modifiedTime":1748560289117,"sourceSize":101494,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1748588189856,"modifiedTime":1748588189856,"sourceSize":1105,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/snippets.css":{"createdTime":1748588190256,"modifiedTime":1748588190256,"sourceSize":712,"sourcePath":"","exportPath":"site-lib/styles/snippets.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/obsidian.css":{"createdTime":1748588190253,"modifiedTime":1748588190253,"sourceSize":163770,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/theme.css":{"createdTime":1748560289315,"modifiedTime":1748560289315,"sourceSize":183351,"sourcePath":"","exportPath":"site-lib/styles/theme.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1748588190032,"modifiedTime":1748588190032,"sourceSize":759,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/supported-plugins.css":{"createdTime":1748588190261,"modifiedTime":1748588190261,"sourceSize":2996,"sourcePath":"","exportPath":"site-lib/styles/supported-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1748560289148,"modifiedTime":1748560289148,"sourceSize":19129,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"⁵-file/image/pasted-image-20250517110728.png":{"createdTime":1747447648393,"modifiedTime":1747447648394,"sourceSize":71361,"sourcePath":"⁵ File/image/Pasted image 20250517110728.png","exportPath":"⁵-file/image/pasted-image-20250517110728.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250517163436.png":{"createdTime":1747467276450,"modifiedTime":1747467276451,"sourceSize":890293,"sourcePath":"⁵ File/image/Pasted image 20250517163436.png","exportPath":"⁵-file/image/pasted-image-20250517163436.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250517164101.png":{"createdTime":1747467661153,"modifiedTime":1747467661153,"sourceSize":138069,"sourcePath":"⁵ File/image/Pasted image 20250517164101.png","exportPath":"⁵-file/image/pasted-image-20250517164101.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250517170728.png":{"createdTime":1747469248753,"modifiedTime":1747469248754,"sourceSize":36800,"sourcePath":"⁵ File/image/Pasted image 20250517170728.png","exportPath":"⁵-file/image/pasted-image-20250517170728.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250517172142.png":{"createdTime":1747470102054,"modifiedTime":1747470102056,"sourceSize":36196,"sourcePath":"⁵ File/image/Pasted image 20250517172142.png","exportPath":"⁵-file/image/pasted-image-20250517172142.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250517190742.png":{"createdTime":1747476462488,"modifiedTime":1747476462488,"sourceSize":17841,"sourcePath":"⁵ File/image/Pasted image 20250517190742.png","exportPath":"⁵-file/image/pasted-image-20250517190742.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250517193510.png":{"createdTime":1747478110685,"modifiedTime":1747478110686,"sourceSize":274922,"sourcePath":"⁵ File/image/Pasted image 20250517193510.png","exportPath":"⁵-file/image/pasted-image-20250517193510.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250517210011.png":{"createdTime":1747483211650,"modifiedTime":1747483211652,"sourceSize":14846,"sourcePath":"⁵ File/image/Pasted image 20250517210011.png","exportPath":"⁵-file/image/pasted-image-20250517210011.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"dev-blog/jungle/week-2.html":{"createdTime":1747972311608,"modifiedTime":1748516603143,"sourceSize":1071,"sourcePath":"Dev Blog/Jungle/Week 2.md","exportPath":"dev-blog/jungle/week-2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"site-lib/rss.xml":{"createdTime":1748516678597,"modifiedTime":1748516678597,"sourceSize":58415,"sourcePath":"","exportPath":"site-lib/rss.xml","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"site-lib/fonts/mathjax_zero.woff":{"createdTime":1748588190113,"modifiedTime":1748588190113,"sourceSize":1368,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_zero.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-regular.woff":{"createdTime":1748588190114,"modifiedTime":1748588190114,"sourceSize":34160,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-bold.woff":{"createdTime":1748588190115,"modifiedTime":1748588190115,"sourceSize":34464,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_math-italic.woff":{"createdTime":1748588190114,"modifiedTime":1748588190114,"sourceSize":19360,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_math-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-italic.woff":{"createdTime":1748588190117,"modifiedTime":1748588190117,"sourceSize":20832,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_math-bolditalic.woff":{"createdTime":1748588190115,"modifiedTime":1748588190115,"sourceSize":19776,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_math-bolditalic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size1-regular.woff":{"createdTime":1748588190115,"modifiedTime":1748588190115,"sourceSize":5792,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size1-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size2-regular.woff":{"createdTime":1748588190118,"modifiedTime":1748588190118,"sourceSize":5464,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size2-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size3-regular.woff":{"createdTime":1748588190117,"modifiedTime":1748588190117,"sourceSize":3244,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size3-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size4-regular.woff":{"createdTime":1748588190115,"modifiedTime":1748588190115,"sourceSize":5148,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size4-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_ams-regular.woff":{"createdTime":1748588190118,"modifiedTime":1748588190118,"sourceSize":40808,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_ams-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_calligraphic-regular.woff":{"createdTime":1748588190116,"modifiedTime":1748588190116,"sourceSize":9600,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_calligraphic-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_calligraphic-bold.woff":{"createdTime":1748588190116,"modifiedTime":1748588190116,"sourceSize":9908,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_calligraphic-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_fraktur-regular.woff":{"createdTime":1748588190116,"modifiedTime":1748588190116,"sourceSize":21480,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_fraktur-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_fraktur-bold.woff":{"createdTime":1748588190117,"modifiedTime":1748588190117,"sourceSize":22340,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_fraktur-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-regular.woff":{"createdTime":1748588190117,"modifiedTime":1748588190117,"sourceSize":12660,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-bold.woff":{"createdTime":1748588190118,"modifiedTime":1748588190118,"sourceSize":15944,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-italic.woff":{"createdTime":1748588190117,"modifiedTime":1748588190117,"sourceSize":14628,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_script-regular.woff":{"createdTime":1748588190116,"modifiedTime":1748588190116,"sourceSize":11852,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_script-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_typewriter-regular.woff":{"createdTime":1748588190116,"modifiedTime":1748588190116,"sourceSize":17604,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_typewriter-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_vector-regular.woff":{"createdTime":1748588190116,"modifiedTime":1748588190116,"sourceSize":1136,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_vector-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_vector-bold.woff":{"createdTime":1748588190115,"modifiedTime":1748588190115,"sourceSize":1116,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_vector-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"dev-blog/data-structure-&-algorithm/이분탐색-v.2.html":{"createdTime":1748509111384,"modifiedTime":1748509112785,"sourceSize":6990,"sourcePath":"Dev Blog/Data Structure & Algorithm/이분탐색 v.2.md","exportPath":"dev-blog/data-structure-&-algorithm/이분탐색-v.2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/data-structure-&-algorithm/data-structure-&-algorithm.html":{"createdTime":1747966841178,"modifiedTime":1747966841878,"sourceSize":74,"sourcePath":"Dev Blog/Data Structure & Algorithm/Data Structure & Algorithm.md","exportPath":"dev-blog/data-structure-&-algorithm/data-structure-&-algorithm.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html":{"createdTime":1748508530439,"modifiedTime":1748508532517,"sourceSize":19309,"sourcePath":"Dev Blog/CSAPP/컴퓨터시스템 CH2. 정보의 표현과 처리.md","exportPath":"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/2110.-공유기-설치.html":{"createdTime":1748513493693,"modifiedTime":1748516101394,"sourceSize":4184,"sourcePath":"Dev Blog/Coding Test/2110. 공유기 설치.md","exportPath":"dev-blog/coding-test/2110.-공유기-설치.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/2630.-색종이-자르기.html":{"createdTime":1748516297140,"modifiedTime":1748516535689,"sourceSize":5221,"sourcePath":"Dev Blog/Coding Test/2630. 색종이 자르기.md","exportPath":"dev-blog/coding-test/2630.-색종이-자르기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/2470.-두-용액.html":{"createdTime":1748516317016,"modifiedTime":1748516325225,"sourceSize":4289,"sourcePath":"Dev Blog/Coding Test/2470. 두 용액.md","exportPath":"dev-blog/coding-test/2470.-두-용액.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/1629.-곱셈.html":{"createdTime":1748516334662,"modifiedTime":1748516552987,"sourceSize":1822,"sourcePath":"Dev Blog/Coding Test/1629. 곱셈.md","exportPath":"dev-blog/coding-test/1629.-곱셈.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/2493.-탑.html":{"createdTime":1748516346864,"modifiedTime":1748516563270,"sourceSize":4423,"sourcePath":"Dev Blog/Coding Test/2493. 탑.md","exportPath":"dev-blog/coding-test/2493.-탑.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/3190.-뱀.html":{"createdTime":1748516357266,"modifiedTime":1748516569794,"sourceSize":3758,"sourcePath":"Dev Blog/Coding Test/3190. 뱀.md","exportPath":"dev-blog/coding-test/3190.-뱀.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/1655.-가운데를-말해요.html":{"createdTime":1748516368122,"modifiedTime":1748516576902,"sourceSize":3012,"sourcePath":"Dev Blog/Coding Test/1655. 가운데를 말해요.md","exportPath":"dev-blog/coding-test/1655.-가운데를-말해요.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/8983.-사냥꾼.html":{"createdTime":1748516380023,"modifiedTime":1748516583919,"sourceSize":8598,"sourcePath":"Dev Blog/Coding Test/8983. 사냥꾼.md","exportPath":"dev-blog/coding-test/8983.-사냥꾼.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/2504.-괄호의-값.html":{"createdTime":1748516392587,"modifiedTime":1748516593961,"sourceSize":4251,"sourcePath":"Dev Blog/Coding Test/2504. 괄호의 값.md","exportPath":"dev-blog/coding-test/2504.-괄호의-값.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"dev-blog/coding-test/10830.-행렬-제곱.html":{"createdTime":1748516403412,"modifiedTime":1748516617808,"sourceSize":1934,"sourcePath":"Dev Blog/Coding Test/10830. 행렬 제곱.md","exportPath":"dev-blog/coding-test/10830.-행렬-제곱.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"site-lib/scripts/graph-wasm.wasm":{"createdTime":1748480481311,"modifiedTime":1747984783485.661,"sourceSize":23655,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.wasm","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"site-lib/scripts/graph-wasm.js":{"createdTime":1748560289117,"modifiedTime":1748560289117,"sourceSize":12885,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-render-worker.js":{"createdTime":1748560289117,"modifiedTime":1748560289117,"sourceSize":5681,"sourcePath":"","exportPath":"site-lib/scripts/graph-render-worker.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"⁵-file/image/그림2.png":{"createdTime":1748073509324,"modifiedTime":1748073509326,"sourceSize":5118,"sourcePath":"⁵ File/image/그림2.png","exportPath":"⁵-file/image/그림2.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/그림1-1.png":{"createdTime":1748310241850,"modifiedTime":1748310241853,"sourceSize":28467,"sourcePath":"⁵ File/image/그림1 1.png","exportPath":"⁵-file/image/그림1-1.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250523213904.png":{"createdTime":1748003944403,"modifiedTime":1748003944411,"sourceSize":34712,"sourcePath":"⁵ File/image/Pasted image 20250523213904.png","exportPath":"⁵-file/image/pasted-image-20250523213904.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/20250523_195539.jpg":{"createdTime":1747997914819,"modifiedTime":1747997914821,"sourceSize":682434,"sourcePath":"⁵ File/image/20250523_195539.jpg","exportPath":"⁵-file/image/20250523_195539.jpg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250529171635.png":{"createdTime":1748506595709,"modifiedTime":1748506595712,"sourceSize":942724,"sourcePath":"⁵ File/image/Pasted image 20250529171635.png","exportPath":"⁵-file/image/pasted-image-20250529171635.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250529171701.png":{"createdTime":1748506621374,"modifiedTime":1748506621378,"sourceSize":2765122,"sourcePath":"⁵ File/image/Pasted image 20250529171701.png","exportPath":"⁵-file/image/pasted-image-20250529171701.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"⁵-file/image/pasted-image-20250529174514.png":{"createdTime":1748508314532,"modifiedTime":1748508314541,"sourceSize":102787,"sourcePath":"⁵ File/image/Pasted image 20250529174514.png","exportPath":"⁵-file/image/pasted-image-20250529174514.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null}},"sourceToTarget":{"Dev Blog/Dev Blog.md":"dev-blog/dev-blog.html","Dev Blog/CSAPP/컴퓨터시스템 CH1. 컴퓨터 시스템으로의 여행.md":"dev-blog/csapp/컴퓨터시스템-ch1.-컴퓨터-시스템으로의-여행.html","Dev Blog/CSAPP/CSAPP.md":"dev-blog/csapp/csapp.html","Dev Blog/Coding Test/10819. 차이를 최대로.md":"dev-blog/coding-test/10819.-차이를-최대로.html","Dev Blog/Coding Test/1074. Z.md":"dev-blog/coding-test/1074.-z.html","Dev Blog/Coding Test/9663. N-Queen.md":"dev-blog/coding-test/9663.-n-queen.html","Dev Blog/Coding Test/2869. 달팽이는 올라가고 싶다.md":"dev-blog/coding-test/2869.-달팽이는-올라가고-싶다.html","Dev Blog/Coding Test/1978. 소수 찾기.md":"dev-blog/coding-test/1978.-소수-찾기.html","Dev Blog/Coding Test/9020. 골드바흐의 추측.md":"dev-blog/coding-test/9020.-골드바흐의-추측.html","Dev Blog/Coding Test/1065. 한수.md":"dev-blog/coding-test/1065.-한수.html","Dev Blog/Coding Test/2628. 종이 자르기.md":"dev-blog/coding-test/2628.-종이-자르기.html","Dev Blog/Coding Test/1914. 하노이 탑.md":"dev-blog/coding-test/1914.-하노이-탑.html","Dev Blog/Coding Test/10971. 외판원 순회2.md":"dev-blog/coding-test/10971.-외판원-순회2.html","Dev Blog/Coding Test/2468. 안전지대.md":"dev-blog/coding-test/2468.-안전지대.html","Dev Blog/Coding Test/Coding Test.md":"dev-blog/coding-test/coding-test.html","Dev Blog/Data Structure/Data Structure.md":"dev-blog/data-structure/data-structure.html","Dev Blog/Jungle/Week 1.md":"dev-blog/jungle/week-1.html","Dev Blog/Jungle/Jungle.md":"dev-blog/jungle/jungle.html","index.md":"index.html","":"site-lib/styles/main-styles.css","⁵ File/image/Pasted image 20250517110728.png":"⁵-file/image/pasted-image-20250517110728.png","⁵ File/image/Pasted image 20250517163436.png":"⁵-file/image/pasted-image-20250517163436.png","⁵ File/image/Pasted image 20250517164101.png":"⁵-file/image/pasted-image-20250517164101.png","⁵ File/image/Pasted image 20250517170728.png":"⁵-file/image/pasted-image-20250517170728.png","⁵ File/image/Pasted image 20250517172142.png":"⁵-file/image/pasted-image-20250517172142.png","⁵ File/image/Pasted image 20250517190742.png":"⁵-file/image/pasted-image-20250517190742.png","⁵ File/image/Pasted image 20250517193510.png":"⁵-file/image/pasted-image-20250517193510.png","⁵ File/image/Pasted image 20250517210011.png":"⁵-file/image/pasted-image-20250517210011.png","Dev Blog/Jungle/Week 2.md":"dev-blog/jungle/week-2.html","Dev Blog/Data Structure & Algorithm/이분탐색 v.2.md":"dev-blog/data-structure-&-algorithm/이분탐색-v.2.html","Dev Blog/Data Structure & Algorithm/Data Structure & Algorithm.md":"dev-blog/data-structure-&-algorithm/data-structure-&-algorithm.html","Dev Blog/CSAPP/컴퓨터시스템 CH2. 정보의 표현과 처리.md":"dev-blog/csapp/컴퓨터시스템-ch2.-정보의-표현과-처리.html","Dev Blog/Coding Test/2110. 공유기 설치.md":"dev-blog/coding-test/2110.-공유기-설치.html","Dev Blog/Coding Test/2630. 색종이 자르기.md":"dev-blog/coding-test/2630.-색종이-자르기.html","Dev Blog/Coding Test/2470. 두 용액.md":"dev-blog/coding-test/2470.-두-용액.html","Dev Blog/Coding Test/1629. 곱셈.md":"dev-blog/coding-test/1629.-곱셈.html","Dev Blog/Coding Test/2493. 탑.md":"dev-blog/coding-test/2493.-탑.html","Dev Blog/Coding Test/3190. 뱀.md":"dev-blog/coding-test/3190.-뱀.html","Dev Blog/Coding Test/1655. 가운데를 말해요.md":"dev-blog/coding-test/1655.-가운데를-말해요.html","Dev Blog/Coding Test/8983. 사냥꾼.md":"dev-blog/coding-test/8983.-사냥꾼.html","Dev Blog/Coding Test/2504. 괄호의 값.md":"dev-blog/coding-test/2504.-괄호의-값.html","Dev Blog/Coding Test/10830. 행렬 제곱.md":"dev-blog/coding-test/10830.-행렬-제곱.html","⁵ File/image/그림2.png":"⁵-file/image/그림2.png","⁵ File/image/그림1 1.png":"⁵-file/image/그림1-1.png","⁵ File/image/Pasted image 20250523213904.png":"⁵-file/image/pasted-image-20250523213904.png","⁵ File/image/20250523_195539.jpg":"⁵-file/image/20250523_195539.jpg","⁵ File/image/Pasted image 20250529171635.png":"⁵-file/image/pasted-image-20250529171635.png","⁵ File/image/Pasted image 20250529171701.png":"⁵-file/image/pasted-image-20250529171701.png","⁵ File/image/Pasted image 20250529174514.png":"⁵-file/image/pasted-image-20250529174514.png"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Backlinks","featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""}},"tags":{"featureId":"tags","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"","featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"showInlineTags":{"show":true,"description":"Show tags that are inline in the document"},"showFrontmatterTags":{"show":true,"description":"Show tags that are in the frontmatter"},"info_showInlineTags":{"show":true,"name":"","description":"Show tags defined inside the document at the top of the page.","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"Show tags defined in the frontmatter of the document at the top of the page.","placeholder":""}},"alias":{"featureId":"aliases","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"","featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Properties","featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"A list of properties to hide from the properties view","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"","featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"Show custom icons for files and folders","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"Show a default icon of a folder for every folder in the tree","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"Show a default icon of a file for every file in the tree","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"Whether or not to show the current file in the file tree when the page is first loaded","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Search...","featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""}},"outline":{"featureId":"outline","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Outline","featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"name":"","description":"Should the outline start collapsed?","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"Only allow outline items to be collapsed if they are at least this many levels deep in the tree.","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"","featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"Graph View","featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"name":"","description":"Show nodes that are not connected to any other nodes.","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"Show attachments like images and PDFs as nodes in the graph.","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"Allow the user to view the global graph of all nodes.","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"Allow the user to pop-out the graph view to take up the whole screen","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"How much should linked nodes attract each other? This will make the graph appear more clustered.","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"How long should the links between nodes be? The shorter the links the more connected nodes will cluster together.","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"How much should nodes repel each other? This will make disconnected parts more spread out.","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular.","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links.","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes.","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes.","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be resized","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be collapsed","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"The default width of the right sidebar","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"The default width of the left sidebar","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"displayTitle":"title mergin","featurePlacement":{"selector":"style","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"C:\\Users\\seonha\\Note\\Obsidian\\⁵ Management Hub\\Script\\web-export.css","info_sourcePath":{"show":true,"name":"","description":"The local path to the source .html file which will be included.","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"name":"","description":"Whether or not to allow lists to be folded","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"Whether or not to allow headings to be folded","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"The width of the document","placeholder":""}},"rss":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":false,"siteUrl":"","siteName":"Obsidian","authorName":"","info_siteUrl":{"show":true,"name":"","description":"The url that this site will be hosted at","placeholder":"https://example.com/mysite"},"info_siteName":{"show":true,"name":"","description":"The name of the vault / exported site","placeholder":""},"info_authorName":{"show":true,"name":"","description":"The name of the author of the site","placeholder":""}}},"modifiedTime":1748588190287,"siteName":"Obsidian","vaultName":"Obsidian","exportRoot":"","baseURL":"","pluginVersion":"1.9.0-3b","themeName":"","bodyClasses":"publish css-settings-manager mod-windows is-hidden-frameless show-inline-title show-ribbon show-view-header minimal-default-light minimal-default-dark minimal-readable minimal-dark-tonal borders-none colorful-active links-int-on links-ext-on full-width-media img-grid contextual-typography is-focused trim-cols checkbox-square metadata-heading-off sidebar-tabs-wide maximize-tables tabs-modern","hasFavicon":false}