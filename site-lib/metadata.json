{"createdTime":1730261335103,"shownInTree":["1.-study/coding-test/coding-test.html","1.-study/coding-test/etc/숫자-자료형과-계산-오차.html","1.-study/coding-test/etc/etc.html","1.-study/coding-test/ps/한수.html","1.-study/coding-test/ps/프린터-큐.html","1.-study/coding-test/ps/트리.html","1.-study/coding-test/ps/통계학.html","1.-study/coding-test/ps/큐.html","1.-study/coding-test/ps/집합.html","1.-study/coding-test/ps/체스판-다시-칠하기.html","1.-study/coding-test/ps/카드2.html","1.-study/coding-test/ps/좌표-정렬.html","1.-study/coding-test/ps/제목-없음.html","1.-study/coding-test/ps/요세푸스-문제.html","1.-study/coding-test/ps/요세푸스-문제-0.html","1.-study/coding-test/ps/영화감독-숌.html","1.-study/coding-test/ps/스위치-켜고-끄기.html","1.-study/coding-test/ps/숫자-카드-2.html","1.-study/coding-test/ps/수들의-합2.html","1.-study/coding-test/ps/수-찾기.html","1.-study/coding-test/ps/소수-구하기.html","1.-study/coding-test/ps/설탕-배달.html","1.-study/coding-test/ps/색종이.html","1.-study/coding-test/ps/비밀번호-만들기.html","1.-study/coding-test/ps/본.html","1.-study/coding-test/ps/보물.html","1.-study/coding-test/ps/바이러스.html","1.-study/coding-test/ps/마인크래프트.html","1.-study/coding-test/ps/로프.html","1.-study/coding-test/ps/1654.-랜선-자르기.html","1.-study/coding-test/ps/듣보잡.html","1.-study/coding-test/ps/덩치.html","1.-study/coding-test/ps/단어정렬.html","1.-study/coding-test/ps/다이나믹프로그래밍(dp).html","1.-study/coding-test/ps/나이순-정렬.html","1.-study/coding-test/ps/나는야-포켓몬-마스터-이다솜.html","1.-study/coding-test/ps/기본.html","1.-study/coding-test/ps/계단-오르기.html","1.-study/coding-test/ps/개인정보-수집-유효기간.html","1.-study/coding-test/ps/n과-m(1).html","1.-study/coding-test/ps/atm.html","1.-study/coding-test/ps/dna.html","1.-study/coding-test/ps/1로-만들기.html","1.-study/coding-test/ps/01타일.html","1.-study/coding-test/ps/터렛.html","1.-study/coding-test/ps/괄호.html","1.-study/coding-test/ps/11279.-최대-힙.html","1.-study/coding-test/ps/12865.-평범한-배낭.html","1.-study/coding-test/ps/11047.-동전-0.html","1.-study/coding-test/ps/코테-질문-모음.html","1.-study/coding-test/ps/1003.-피보나치-함수.html","1.-study/coding-test/ps/1107.-리모컨.html","1.-study/coding-test/ps/1012.-유기농-배추.html","1.-study/coding-test/ps/1157.-단어-공부.html","1.-study/coding-test/ps/bufferedreader.html","1.-study/coding-test/ps/15969.-행복.html","1.-study/coding-test/ps/1309.동물원.html","1.-study/coding-test/ps/ps.html","1.-study/coding-test/ps/42626.-더맵게.html","1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html","1.-study/coding-test/ps/42746.-가장-큰-수.html","1.-study/coding-test/ps/42747.-h-index.html","1.-study/coding-test/ps/84512.-모음사전.html","1.-study/coding-test/ps/42842.-카펫.html","1.-study/coding-test/ps/42839.-소수-찾기.html","1.-study/coding-test/ps/43165.-타겟넘버.html","1.-study/coding-test/ps/1844.-게임-맵-최단거리.html","1.-study/coding-test/ps/1302.-deepest-leaves-sum.html","1.-study/coding-test/ps/42860.-조이스틱.html","1.-study/coding-test/ps/42885.-구명보트.html","1.-study/coding-test/ps/894.-all-possible-full-binary-trees.html","1.-study/coding-test/ps/1011.-capacity-to-ship-packages-within-d-days.html","1.-study/coding-test/ps/49191.-순위.html","1.-study/coding-test/ps/99-club-2기-코테-문제-정리.html","1.-study/coding-test/ps/1476.-subrectangle-queries.html","1.-study/coding-test/ps/1260.-dfs와-bfs.html","1.-study/coding-test/ps/24228.-젓가락.html","1.-study/coding-test/ps/1541.-잃어버린-괄호.html","1.-study/coding-test/ps/2805.-나무-자르기.html","1.-study/coding-test/ps/11724.-연결-요소의-개수.html","1.-study/coding-test/ps/1406.-에디터.html","1.-study/coding-test/ps/30804.-과일-탕후루.html","1.-study/coding-test/ps/10025.-게으른-백곰.html","1.-study/coding-test/ps/1074.-z.html","1.-study/coding-test/ps/1249.-보급로.html","1.-study/coding-test/ps/1072.-게임.html","1.-study/coding-test/ps/11561.-징검다리.html","1.-study/coding-test/ps/입국심사.html","1.-study/coding-test/algorithm/help-알고리즘.html","1.-study/coding-test/algorithm/java-기본.html","1.-study/coding-test/algorithm/이분탐색.html","1.-study/coding-test/algorithm/help-반례-찾기.html","1.-study/coding-test/algorithm/help-python과-pypy.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1.-study/coding-test/algorithm/graph/graph.html","1.-study/coding-test/algorithm/graph/0.-graph.html","1.-study/coding-test/algorithm/algorithm.html","99-club/99클럽-코테-스터디-1일차-til-이분탐색.html","99-club/99클럽-코테-스터디-2일차-til-이분탐색.html","99-club/99-club.html","99-club/99클럽-코테-스터디-3일차-til-이분탐색.html","index.html"],"attachments":["site-lib/scripts/graph-wasm.wasm","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/874d8b8e340f75575caa.svg","site-lib/media/3d6c1bdc4d87cde4de67.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/scripts/tinycolor.js","site-lib/scripts/pixi.js","site-lib/scripts/minisearch.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css","5.-file/image/스크린샷-2024-10-29-182303-1.png","5.-file/image/pasted-image-20241029183732.png","site-lib/fonts/mathjax_zero.woff","site-lib/fonts/mathjax_main-regular.woff","site-lib/fonts/mathjax_main-bold.woff","site-lib/fonts/mathjax_math-italic.woff","site-lib/fonts/mathjax_main-italic.woff","site-lib/fonts/mathjax_math-bolditalic.woff","site-lib/fonts/mathjax_size1-regular.woff","site-lib/fonts/mathjax_size2-regular.woff","site-lib/fonts/mathjax_size3-regular.woff","site-lib/fonts/mathjax_size4-regular.woff","site-lib/fonts/mathjax_ams-regular.woff","site-lib/fonts/mathjax_calligraphic-regular.woff","site-lib/fonts/mathjax_calligraphic-bold.woff","site-lib/fonts/mathjax_fraktur-regular.woff","site-lib/fonts/mathjax_fraktur-bold.woff","site-lib/fonts/mathjax_sansserif-regular.woff","site-lib/fonts/mathjax_sansserif-bold.woff","site-lib/fonts/mathjax_sansserif-italic.woff","site-lib/fonts/mathjax_script-regular.woff","site-lib/fonts/mathjax_typewriter-regular.woff","site-lib/fonts/mathjax_vector-regular.woff","site-lib/fonts/mathjax_vector-bold.woff","5.-file/image/pasted-image-20241030171506.png","5.-file/image/pasted-image-20241030173905.png"],"allFiles":["99-club/99클럽-코테-스터디-2일차-til-이분탐색.html","1.-study/coding-test/ps/11561.-징검다리.html","1.-study/coding-test/algorithm/이분탐색.html","99-club/99클럽-코테-스터디-3일차-til-이분탐색.html","99-club/99-club.html","1.-study/coding-test/coding-test.html","1.-study/coding-test/ps/ps.html","1.-study/coding-test/ps/입국심사.html","5.-file/image/pasted-image-20241030173905.png","5.-file/image/pasted-image-20241030171506.png","index.html","1.-study/coding-test/etc/숫자-자료형과-계산-오차.html","1.-study/coding-test/etc/etc.html","99-club/99클럽-코테-스터디-1일차-til-이분탐색.html","1.-study/coding-test/ps/1072.-게임.html","1.-study/coding-test/algorithm/algorithm.html","1.-study/coding-test/ps/42842.-카펫.html","1.-study/coding-test/algorithm/graph/graph.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1.-study/coding-test/algorithm/graph/0.-graph.html","1.-study/coding-test/ps/1074.-z.html","1.-study/coding-test/ps/1249.-보급로.html","1.-study/coding-test/ps/1로-만들기.html","1.-study/coding-test/ps/30804.-과일-탕후루.html","1.-study/coding-test/ps/10025.-게으른-백곰.html","1.-study/coding-test/ps/1107.-리모컨.html","1.-study/coding-test/ps/1406.-에디터.html","1.-study/coding-test/ps/2805.-나무-자르기.html","1.-study/coding-test/ps/11724.-연결-요소의-개수.html","1.-study/coding-test/ps/1654.-랜선-자르기.html","1.-study/coding-test/ps/1541.-잃어버린-괄호.html","1.-study/coding-test/ps/24228.-젓가락.html","1.-study/coding-test/ps/1260.-dfs와-bfs.html","1.-study/coding-test/ps/1012.-유기농-배추.html","1.-study/coding-test/ps/1476.-subrectangle-queries.html","1.-study/coding-test/ps/99-club-2기-코테-문제-정리.html","1.-study/coding-test/ps/49191.-순위.html","1.-study/coding-test/ps/1011.-capacity-to-ship-packages-within-d-days.html","1.-study/coding-test/ps/894.-all-possible-full-binary-trees.html","1.-study/coding-test/ps/42885.-구명보트.html","1.-study/coding-test/ps/42860.-조이스틱.html","1.-study/coding-test/ps/1302.-deepest-leaves-sum.html","1.-study/coding-test/ps/1844.-게임-맵-최단거리.html","1.-study/coding-test/ps/43165.-타겟넘버.html","1.-study/coding-test/ps/42626.-더맵게.html","1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html","1.-study/coding-test/ps/42746.-가장-큰-수.html","1.-study/coding-test/ps/42747.-h-index.html","1.-study/coding-test/ps/42839.-소수-찾기.html","1.-study/coding-test/ps/84512.-모음사전.html","1.-study/coding-test/ps/1309.동물원.html","1.-study/coding-test/ps/15969.-행복.html","1.-study/coding-test/ps/1157.-단어-공부.html","1.-study/coding-test/ps/bufferedreader.html","1.-study/coding-test/algorithm/java-기본.html","1.-study/coding-test/ps/1003.-피보나치-함수.html","1.-study/coding-test/ps/코테-질문-모음.html","1.-study/coding-test/algorithm/help-반례-찾기.html","1.-study/coding-test/algorithm/help-알고리즘.html","1.-study/coding-test/algorithm/help-python과-pypy.html","1.-study/coding-test/ps/다이나믹프로그래밍(dp).html","1.-study/coding-test/ps/01타일.html","1.-study/coding-test/ps/11047.-동전-0.html","1.-study/coding-test/ps/12865.-평범한-배낭.html","1.-study/coding-test/ps/11279.-최대-힙.html","1.-study/coding-test/ps/괄호.html","1.-study/coding-test/ps/터렛.html","1.-study/coding-test/ps/요세푸스-문제-0.html","1.-study/coding-test/ps/한수.html","1.-study/coding-test/ps/프린터-큐.html","1.-study/coding-test/ps/트리.html","1.-study/coding-test/ps/통계학.html","1.-study/coding-test/ps/큐.html","1.-study/coding-test/ps/카드2.html","1.-study/coding-test/ps/체스판-다시-칠하기.html","1.-study/coding-test/ps/집합.html","1.-study/coding-test/ps/좌표-정렬.html","1.-study/coding-test/ps/제목-없음.html","1.-study/coding-test/ps/요세푸스-문제.html","1.-study/coding-test/ps/영화감독-숌.html","1.-study/coding-test/ps/스위치-켜고-끄기.html","1.-study/coding-test/ps/숫자-카드-2.html","1.-study/coding-test/ps/수들의-합2.html","1.-study/coding-test/ps/수-찾기.html","1.-study/coding-test/ps/소수-구하기.html","1.-study/coding-test/ps/설탕-배달.html","1.-study/coding-test/ps/색종이.html","1.-study/coding-test/ps/비밀번호-만들기.html","1.-study/coding-test/ps/본.html","1.-study/coding-test/ps/보물.html","1.-study/coding-test/ps/바이러스.html","1.-study/coding-test/ps/마인크래프트.html","1.-study/coding-test/ps/로프.html","1.-study/coding-test/ps/듣보잡.html","1.-study/coding-test/ps/덩치.html","1.-study/coding-test/ps/단어정렬.html","1.-study/coding-test/ps/나이순-정렬.html","1.-study/coding-test/ps/나는야-포켓몬-마스터-이다솜.html","1.-study/coding-test/ps/기본.html","1.-study/coding-test/ps/계단-오르기.html","1.-study/coding-test/ps/개인정보-수집-유효기간.html","1.-study/coding-test/ps/n과-m(1).html","1.-study/coding-test/ps/dna.html","1.-study/coding-test/ps/atm.html","site-lib/scripts/graph-wasm.wasm","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/874d8b8e340f75575caa.svg","site-lib/media/3d6c1bdc4d87cde4de67.svg","site-lib/fonts/mathjax_zero.woff","site-lib/fonts/mathjax_main-regular.woff","site-lib/fonts/mathjax_main-bold.woff","site-lib/fonts/mathjax_math-italic.woff","site-lib/fonts/mathjax_main-italic.woff","site-lib/fonts/mathjax_math-bolditalic.woff","site-lib/fonts/mathjax_size1-regular.woff","site-lib/fonts/mathjax_size2-regular.woff","site-lib/fonts/mathjax_size3-regular.woff","site-lib/fonts/mathjax_size4-regular.woff","site-lib/fonts/mathjax_ams-regular.woff","site-lib/fonts/mathjax_calligraphic-regular.woff","site-lib/fonts/mathjax_calligraphic-bold.woff","site-lib/fonts/mathjax_fraktur-regular.woff","site-lib/fonts/mathjax_fraktur-bold.woff","site-lib/fonts/mathjax_sansserif-regular.woff","site-lib/fonts/mathjax_sansserif-bold.woff","site-lib/fonts/mathjax_sansserif-italic.woff","site-lib/fonts/mathjax_script-regular.woff","site-lib/fonts/mathjax_typewriter-regular.woff","site-lib/fonts/mathjax_vector-regular.woff","site-lib/fonts/mathjax_vector-bold.woff","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/scripts/graph-wasm.js","site-lib/scripts/graph-render-worker.js","site-lib/scripts/tinycolor.js","site-lib/scripts/pixi.js","site-lib/scripts/minisearch.js","site-lib/media/favicon.png","site-lib/styles/snippets.css","site-lib/styles/obsidian.css","site-lib/styles/theme.css","site-lib/styles/global-variable-styles.css","site-lib/styles/supported-plugins.css","site-lib/styles/main-styles.css"],"webpages":{"1.-study/coding-test/algorithm/graph/0.-graph.html":{"title":"0. Graph","icon":"","description":"그래프는 원소들의 연결관계를 표현한 자료구조이다. 정점(node, vertex)와 간선(edge)로 구성되며, 정점은 각 원소를 나타내고 정점과 정점사이의 연결은 간선으로 표현된다. 방향그래프(directed graph): 방향성을 가진 간선으로 이루어진 그래프 무방향그래프(undirected graph): 방향 없는 간선으로 이루어진 그래프 부분 그래프(subgraph): 그래프의 일부 정점과 간선으로 이루어진 그래프 꼭 연결되어야할 필요는 없다.\n신장 부분 그래프(spanning subgraph): 모든 정점을 포함하는 부분 그래프 연결 그래프(connected graph): 모든 정점들이 서로 점근 가능할 때, 연결 요소(connected components): disjoint connected subgraph → 연결 부분 그래프이면서 다른 연결요소와 분리되어있는 경우 트리(tree): 순환하지 않는 연결 그래프 신장 트리(spanning tree) 가중치 그래프(weighted graph): 간선에 가중치가 할달된 그래프 정점(vertex, node)\n간선(edge)\n인접 정접(adjacent vertices): 간선에 의해 직접적으로 연결된 정점.\n정점의 차수(degree of a vertex): 정점에 연결되어있는 간선 수 방향 그래프에서는 진입차수(in-degree)와 진출차수(out-degree)로 나눠진다. 경로(path): 두 정점 사이를 연결하는 간선들의 나열. 단순 경로(simple path): 중복된 간선이나 정점이 없는 경로\n방향 경로(directed path): 방향 그래프에서, 간선이 모드 같은 방향이어야한다는 제약이 있는 경로 순환(Cycle): 시작과 끝이 같은 정점인 경로 단순 순환(simple cycle): 경로에 중복된 간선이나 정점이 없는 순환\n방향 순환(directed cycle): 방향 그래프에서, 간선이 모드 같은 방향이어야한다는 제약이 있는 순환 간단하고 직관적(intuitive)이나, 효율적이진 않음\nlist V: 정점 저장\nlist E: 간선 저장\nvertex object: 데이터와 V 내의 위지 주소 → 간선정보음 edge object: 데이터(가중치 같은 거), 연결된 vertex object, E 내의 위치 주소\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"0. Graph","level":1,"id":"0. Graph"},{"heading":"개요","level":2,"id":"개요"},{"heading":"종류","level":3,"id":"종류"},{"heading":"용어","level":3,"id":"용어"},{"heading":"구현","level":2,"id":"구현"},{"heading":"간선 리스트(edge list)","level":3,"id":"간선_리스트(edge_list)"},{"heading":"인접 리스트(adjacency list)","level":3,"id":"인접_리스트(adjacency_list)"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/algorithm/graph/0.-graph.html","pathToRoot":"../../../..","attachments":[],"createdTime":1729746324891,"modifiedTime":1730155389024,"sourceSize":2364,"sourcePath":"1. Study/Coding Test/Algorithm/Graph/0. Graph.md","exportPath":"1.-study/coding-test/algorithm/graph/0.-graph.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/algorithm/graph/bfs,-dfs.html":{"title":"BFS, DFS","icon":"","description":"<a data-href=\"11724. 연결 요소의 개수\" href=\"1.-study/coding-test/ps/11724.-연결-요소의-개수.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">11724. 연결 요소의 개수</a><br>\n<a data-href=\"1249. 보급로\" href=\"1.-study/coding-test/ps/1249.-보급로.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1249. 보급로</a><br>\n<a data-href=\"1260. DFS와 BFS\" href=\"1.-study/coding-test/ps/1260.-dfs와-bfs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1260. DFS와 BFS</a><br>\n<a data-href=\"1302. Deepest Leaves Sum\" href=\"1.-study/coding-test/ps/1302.-deepest-leaves-sum.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1302. Deepest Leaves Sum</a><br>\n<a data-href=\"1844. 게임 맵 최단거리\" href=\"1.-study/coding-test/ps/1844.-게임-맵-최단거리.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1844. 게임 맵 최단거리</a><br>\n<a data-href=\"43165. 타겟넘버\" href=\"1.-study/coding-test/ps/43165.-타겟넘버.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">43165. 타겟넘버</a><br>\n<a data-href=\"PS\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"BFS, DFS","level":1,"id":"BFS, DFS"},{"heading":"관련문제","level":3,"id":"관련문제"}],"links":["1.-study/coding-test/ps/11724.-연결-요소의-개수.html","1.-study/coding-test/ps/1249.-보급로.html","1.-study/coding-test/ps/1260.-dfs와-bfs.html","1.-study/coding-test/ps/1302.-deepest-leaves-sum.html","1.-study/coding-test/ps/1844.-게임-맵-최단거리.html","1.-study/coding-test/ps/43165.-타겟넘버.html","1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/algorithm/graph/bfs,-dfs.html","pathToRoot":"../../../..","attachments":[],"createdTime":1729746324891,"modifiedTime":1730155389049,"sourceSize":245,"sourcePath":"1. Study/Coding Test/Algorithm/Graph/BFS, DFS.md","exportPath":"1.-study/coding-test/algorithm/graph/bfs,-dfs.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/algorithm/graph/graph.html":{"title":"Graph","icon":"","description":"<a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/Algorithm/Graph/new file.md\" data-href=\"1. Study/Coding Test/Algorithm/Graph/new file.md\" href=\"1. Study/Coding Test/Algorithm/Graph/new file\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new file</a> | <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/Algorithm/Graph/new folder/new folder.md\" data-href=\"1. Study/Coding Test/Algorithm/Graph/new folder/new folder.md\" href=\"1. Study/Coding Test/Algorithm/Graph/new folder/new folder\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new folder</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Graph","level":1,"id":"Graph"},{"heading":"Note","level":3,"id":"Note"},{"heading":"File","level":3,"id":"File"}],"links":["1. Study/Coding Test/Algorithm/Graph/new file.md","1. Study/Coding Test/Algorithm/Graph/new folder/new folder.md","1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1.-study/coding-test/algorithm/graph/0.-graph.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/algorithm/graph/graph.html","pathToRoot":"../../../..","attachments":[],"createdTime":1729746315529,"modifiedTime":1730155389062,"sourceSize":420,"sourcePath":"1. Study/Coding Test/Algorithm/Graph/Graph.md","exportPath":"1.-study/coding-test/algorithm/graph/graph.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/algorithm/이분탐색.html":{"title":"이분탐색","icon":"","description":"<a data-href=\"1072. 게임\" href=\"1.-study/coding-test/ps/1072.-게임.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1072. 게임</a><br>\n<a data-href=\"11561. 징검다리\" href=\"1.-study/coding-test/ps/11561.-징검다리.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">11561. 징검다리</a><br>\n<a data-href=\"입국심사\" href=\"1.-study/coding-test/ps/입국심사.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">입국심사</a>정렬된 배열에서 원하는 값을 빠르게 찾을 수 있는 탐색 기법으로, 탐색 범위를 절반씩 줄여가며 원하는 값을 찾아가는 방식이다.\n정렬된 배열에서 중간 값을 기준으로 target 값과 비교한다. target이 중간 값보다 크면 왼쪽 부분을 버리고, 작으면 오른쪽 부분을 버린다. 이 과정을 반복하면서 배열의 범위를 점점 좁혀 target을 찾는다.\n이분 탐색의 시간복잡도는 O(log N) 이다.탐색의 범위를 절반씩 줄여나가며 탐색을 진행하는 방식으로, 매 실행마다 탐색범위가 절반씩 줄어들게 된다. 따라서 시간 복잡도는 배열 길이 N이 몇 번까지 2로 나누어(나머지 버림)질 수 있는가가 시간복잡도의 기준이 된다. 즉, 으로 시간 복잡도는 O(log N)의 값을 가진다.public class Main { public static void main(String[] args) { // 문제 설정 int[] list = {0,10,20,30,40,50,60,70,80,90}; int target = 10; // 탐색 범위 설정을 위한 인덱스 값을 저장하는 변수 선언 int si = 0; // si: start index int ei = list.length; // ei: end index // 탐색 시작 // end index가 start index를 초과할 시 while (si &lt;= ei) { int mid = (si+ei)/2; // mid: 배열 탐색범위의 중간 index int now = list[mid]; // now: 배열 탐색범위의 중간값 // target 발견 시 위치를 출력하고 loop 종료 if (now == target) { System.out.println(mid); break; } // target이 mid 값 보다 왼쪽에 있을 시 end index를 mid 위치로 옮김 if (now &gt; target) ei = mid; // target이 mid 값 보다 오른쪽에 있을 시 start index를 mid + 1 위치로 옮김 if (now &lt; target) si = mid+1; } } }\n복사lo가 hi보다 클 때만 while문 탈출 가능.ex)\nlo = 5; hi = 5;\nmid = 5;\n→ lo나 hi를 갱신해야하는 경우에 mid로 갱신한다면 값이 5로 유지되어 무한루프에 빠짐.따라서 lo나 hi의 갱신을 mid 값이 아닌 lo = mid+1, hi = mid-1로 해주어야한다.lo == hi 일때, 마지막으로 mid에서 target 탐색 후 탈출 → 탐색하지 않은 요소가 없음lo와 hi가 같은 경우에도 while문을 탈출 한다.ex)\nlo=4; hi=5;\nmid = 4;\n→ lo를 갱신해야하는 경우 lo의 값이 4로 유지되므로 무한루프에 빠짐. 따라서 lo값을 mid+1로 갱신해주어야한다. (hi값은 mid로 갱신해준다. 둘의 차이는 lo)ex)\n초기에 while문으로 들어가지도 못하는 경우\nlo = 5; hi = 6; 이었다가\nlo = 5; hi = 5; 로 갱신된 경우, while 문 탈출 → list[4]가 target값과 일치하는지를 탐색하지 못함\n→ 해당 부분에 대한 연산을 추가해줘야함.\nhi == lo일 때까지 탐색을 반복 → target값 찾았다고 나가면 안됨.\nLower Bound: target 이상의 첫 위치 (처음 나타나는 위치)\n배열 [1, 2, 4, 4, 4, 5]에서 4의 Lower Bound는 index 2.\ntarget보다 크거나 같은 값을 찾기 위해 mid 값을 기준으로 hi나 lo를 조정. Upper Bound target을 초과하는 첫 위치 (마지막 위치 이후)\n배열 [1, 2, 4, 4, 4, 5, 6]에서 4의 Upper Bound는 index 5.\ntarget보다 큰 값을 찾기 위해 mid 값을 기준으로 조정하되, target과 동일한 경우에도 lo를 오른쪽으로 이동. → mid값으로 초기화 해주어도 됨. lo랑 hi랑 붙어서 지지고 볶고 할 시간도 없이 while문에서 빼내기 때문에,,,ex)\n초기에 while문으로 들어가지도 못하는 경우\nlo = 4; hi = 6; 이었다가\nlo = 4; hi = 5; 로 갱신된 경우, while 문 탈출 → (list[4]와) list[5]가 target값과 일치하는지를 탐색하지 못함\n→ 해당 부분에 대한 연산을 추가해줘야함.\n범위 탐색이나 최적화 문제에 활용.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"이분탐색","level":1,"id":"이분탐색"},{"heading":"개요","level":3,"id":"개요"},{"heading":"동작 방식","level":3,"id":"동작_방식"},{"heading":"시간복잡도","level":3,"id":"시간복잡도"},{"heading":"구현","level":3,"id":"구현"},{"heading":"while (lo <= hi)인 경우 == while(lo < hi + 1)","level":4,"id":"while_(lo_<=_hi)인_경우_==_while(lo_<_hi_+_1)"},{"heading":"갱신","level":5,"id":"갱신"},{"heading":"target 값 탐색","level":5,"id":"target_값_탐색"},{"heading":"while (lo < hi)인 경우","level":4,"id":"while_(lo_<_hi)인_경우"},{"heading":"갱신","level":5,"id":"갱신"},{"heading":"target 값 탐색","level":5,"id":"target_값_탐색"},{"heading":"특징: lower bound, upper bound 탐색에 사용","level":5,"id":"특징_lower_bound,_upper_bound_탐색에_사용"},{"heading":"while (lo + 1< hi)인 경우","level":4,"id":"while_(lo_+_1<_hi)인_경우"},{"heading":"갱신","level":5,"id":"갱신"},{"heading":"target 값 탐색","level":5,"id":"target_값_탐색"},{"heading":"특징","level":5,"id":"특징"}],"links":["1.-study/coding-test/ps/1072.-게임.html","1.-study/coding-test/ps/11561.-징검다리.html","1.-study/coding-test/ps/입국심사.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/algorithm/이분탐색.html","pathToRoot":"../../..","attachments":[],"createdTime":1730105702010,"modifiedTime":1730330897261,"sourceSize":5381,"sourcePath":"1. Study/Coding Test/Algorithm/이분탐색.md","exportPath":"1.-study/coding-test/algorithm/이분탐색.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/algorithm/algorithm.html":{"title":"Algorithm","icon":"","description":"<a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/Algorithm/new file.md\" data-href=\"1. Study/Coding Test/Algorithm/new file.md\" href=\"1. Study/Coding Test/Algorithm/new file\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new file</a> | <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/Algorithm/new folder/new folder.md\" data-href=\"1. Study/Coding Test/Algorithm/new folder/new folder.md\" href=\"1. Study/Coding Test/Algorithm/new folder/new folder\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new folder</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Algorithm","level":1,"id":"Algorithm"},{"heading":"Note","level":3,"id":"Note"},{"heading":"File","level":3,"id":"File"}],"links":["1. Study/Coding Test/Algorithm/new file.md","1. Study/Coding Test/Algorithm/new folder/new folder.md","1.-study/coding-test/algorithm/graph/graph.html","1.-study/coding-test/algorithm/이분탐색.html","1.-study/coding-test/algorithm/java-기본.html","1.-study/coding-test/algorithm/help-python과-pypy.html","1.-study/coding-test/algorithm/help-반례-찾기.html","1.-study/coding-test/algorithm/help-알고리즘.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/algorithm/algorithm.html","pathToRoot":"../../..","attachments":[],"createdTime":1729745161109,"modifiedTime":1730178905256,"sourceSize":629,"sourcePath":"1. Study/Coding Test/Algorithm/Algorithm.md","exportPath":"1.-study/coding-test/algorithm/algorithm.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/algorithm/help-반례-찾기.html":{"title":"HELP: 반례 찾기","icon":"","description":"ID: 0\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/blog/view/70\" target=\"_self\">https://www.acmicpc.net/blog/view/70</a>\n다시풀기: No\n분류: help\n생성 일시: 2023년 4월 20일 오후 5:55\n<br>가장 중요한 것은 직접 데이터를 만들어서 넣어 보는 것입니다.&nbsp;<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/14405\" target=\"_self\">https://www.acmicpc.net/problem/14405</a>&nbsp;를 예로 들어 봅시다. 그러면 이런 입력들을 넣어 볼 수 있습니다.\npi 하나만 넣으면? ka? chu? 한 글자만 넣으면? p? k? c? i? a? r?\npika는 YES가 나와야 합니다. 이걸 조금 변형하면? pik? pia? pka? piak? pkia? ipka? kipa? pikaa? pikka? piika? ppika?\nkapi도 YES가 나와야 합니다. 이걸 조금 변형하면? kap? kai? api? kaip? kpai? kapii? kaapi?\n주어진 예제를 조금 변형하면? pikap? pikpi? pipikach? pipikaphu?\n그냥 정말로 아무거나 넣으면? abcd? pipichukachuka? pichaku? ppap? pikach?\n입력으로 1 이상 1,000,000 이하의 정수 N이 주어진다면 N=1, N=2 등의 최소 케이스가 잘 나오는지 확인하는 것이 좋습니다.&nbsp;이런 입력이 특이 케이스가 되는 문제들이 종종 있고, 굳이 특이 케이스가 아니더라도 우리의 코드가 최소 케이스에서 틀릴 가능성은 얼마든지 있습니다. 위에서 언급한 \"피카츄\" 문제의 경우 p, k 등의 한 글자짜리 입력이 여기에 해당되겠죠.\nN=1,000,000 같은 최대 케이스를 넣었을 때 주어진 시간 제한 안에 답이 나오는지도 확인해 볼 수 있습니다. 답이 맞는지 확인하는 건 어떨까요? 문제에 따라 답을 손으로 알아내기 힘들 수도 있는데, 적어도 말이 되는 값은 나와야겠죠? 출력이 무조건 0 이상일 수밖에 없는 문제에서 음수가 나오면 뭔가 잘못되었다는 뜻입니다.\n매우 간단한 풀이가 있는데 시간복잡도가 너무 커서 못 쓰고, 그 대신 더 효율적인 풀이를 생각해야 하는 문제가 있습니다. 이런 문제는 다음 방법으로도 반례를 찾을 수 있습니다. 매우 간단한 풀이이면 구현하기 쉬워서 틀릴 가능성이 낮다는 점을 이용한 방법입니다.\n매우 간단한 풀이를 작성한다.\n랜덤으로 데이터를 만든다.\n간단한 풀이와 틀린 풀이가 내놓는 답이 일치하는지 검사한다.\n2-3번을 반복...\n<br><a data-tooltip-position=\"top\" aria-label=\"http://www.secmem.org/blog/2020/09/19/rte/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"http://www.secmem.org/blog/2020/09/19/rte/\" target=\"_self\">PS에서의 런타임 에러와 디버깅 (링크)</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":["#정리"],"headers":[{"heading":"HELP: 반례 찾기","level":1,"id":"HELP: 반례 찾기"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/algorithm/help-반례-찾기.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247727,"modifiedTime":1715664523820,"sourceSize":2512,"sourcePath":"1. Study/Coding Test/Algorithm/HELP 반례 찾기.md","exportPath":"1.-study/coding-test/algorithm/help-반례-찾기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/algorithm/help-알고리즘.html":{"title":"HELP: 알고리즘","icon":"","description":"ID: 0\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/blog/view/70\" target=\"_self\">https://www.acmicpc.net/blog/view/70</a>\n다시풀기: No\n분류: help\n생성 일시: 2023년 4월 20일 오후 5:56\n배열 기반의 리스트 (C++&nbsp;vector, string,&nbsp;Java&nbsp;ArrayList, String,&nbsp;Python&nbsp;list, str, ...)의 중간에 뭔가를 끼워넣거나 빼는 건 O(N)입니다.\n퀵소트를 직접 구현하면 O(N^2)이 걸리는 데이터를 손쉽게 만들 수 있습니다. 그냥 내장된 정렬 함수를 쓰세요. 정렬을 직접 구현하는 것을 연습하시고자 한다면, 피벗을 랜덤으로 잡은 퀵소트를 구현하거나 힙소트, 머지소트 등 다른 O(nlogn) 정렬 알고리즘을 구현하는 방법이 있습니다.\n격자에서 탐색할 때 범위 체크를 반드시 합시다.\nDP를 할 때에는 메모이제이션을 합시다. 안 그러면 DP가 아닙니다.\n<br>DFS는 절대로 최단거리를 구해 주지 않습니다.&nbsp;물론 메모이제이션 없이 모든 경로를 탐색하는 DFS는 최단거리를 구해 주겠지만, 시간 초과가 날 것입니다. <img alt=\"https://imgur.com/6griKbJ.png\" src=\"https://imgur.com/6griKbJ.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> <br>BFS는 큐에서 뺀 다음이 아닌, 큐에 넣을 때 방문 체크를 해야 중복 방문이 일어나지 않습니다.&nbsp;BFS 문제에서 시간 초과나 메모리 초과가 나면 이것부터 의심해 보시면 됩니다. <img alt=\"https://imgur.com/TKsmWih.png\" src=\"https://imgur.com/TKsmWih.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> BFS를 할 때 큐의 크기가 제한되어 있도록 구현했다면, 그 크기는 적어도 방문할 수 있는 정점의 총 개수보다는 크게 합시다.\n","aliases":[],"inlineTags":[],"frontmatterTags":["#정리"],"headers":[{"heading":"HELP: 알고리즘","level":1,"id":"HELP: 알고리즘"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/algorithm/help-알고리즘.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247707,"modifiedTime":1715664498891,"sourceSize":1688,"sourcePath":"1. Study/Coding Test/Algorithm/HELP 알고리즘.md","exportPath":"1.-study/coding-test/algorithm/help-알고리즘.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/algorithm/help-python과-pypy.html":{"title":"Help: Python과 Pypy","icon":"","description":"ID: 0\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/blog/view/70\" target=\"_self\">https://www.acmicpc.net/blog/view/70</a>\n다시풀기: No\n분류: help\n생성 일시: 2023년 4월 20일 오후 5:58\nBOJ는 numpy 등 외장모듈을 지원하지 않습니다.&nbsp;(사실 모든 언어가 그렇습니다.)\n풀이가 분명히 맞고 시간복잡도도 충분히 작은데 시간 초과가 난다면 언어를 Pypy로 설정하고 제출하면 됩니다. 파이썬은 원래 편리성과 속도를 맞바꾼 언어이기 때문에, 맞아야 될 풀이가 시간 초과더라도 이상할 게 전혀 없습니다.\n두 수를 입력받고 나서 비교할 때는 반드시 int로 변환을 합시다.&nbsp;문자열의 비교는 사전 순 비교이기 때문에, 3은 10보다 작지만 \"3\"은 \"10\"보다 큽니다.\nis 키워드는 두 대상의 값이 같은지가 아니라 완전히 같은 대상을 가리키는지를 비교합니다. BOJ에서 이걸 쓸 일은 거의 없습니다.&nbsp;같은 \"hello\"더라도 따로 정의하면 다른 대상이 됩니다. 이걸 쓰면 디버깅하기도 힘든 게, -5 이상 255 이하의 int는 미리 만들어 놓고 정의할 때마다 가져다 쓰기 때문에, 딱 그 범위까지는 is와 ==가 똑같은 동작을 합니다. 그래서 손으로 반례를 찾으려고 하면 찾아지지 않습니다.\n<br>list.pop(0), list.index, list.insert, list.count, x in list, list[:-1]&nbsp;등은 다 O(N)입니다. 이외에도 O(N)이 걸리는 list 연산이 굉장히 많습니다. (len(list)는 O(1)) <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://wiki.python.org/moin/TimeComplexity\" target=\"_self\">https://wiki.python.org/moin/TimeComplexity</a>\n위의 이유로,&nbsp;list를 큐 또는 덱으로 사용하면 절대, 절대, 절대, 절대, 절대 안 됩니다!! 반드시&nbsp;collections.deque를 써야 합니다.\n아니요,&nbsp;queue.Queue도 안 됩니다. 이건 멀티스레딩을 위해 만들어진 큐이고 매우 느립니다.\n파이썬의 재귀 깊이는 기본적으로 최대 1,000입니다.&nbsp;sys.setrecursionlimit으로 이 깊이를 조절할 수 있습니다.\n두 개의 int를 나누면 float이 됩니다.&nbsp;int(a/b)&nbsp;말고&nbsp;a//b를 쓰는 것이 훨씬 안전합니다.&nbsp;맨 위의 \"부동소수점 자료형은 나타내는 수의 범위가 넓지만 ...\"을 읽어보세요.\n","aliases":[],"inlineTags":[],"frontmatterTags":["#정리"],"headers":[{"heading":"Help: Python과 Pypy","level":1,"id":"Help: Python과 Pypy"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/algorithm/help-python과-pypy.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247742,"modifiedTime":1715664431457,"sourceSize":2332,"sourcePath":"1. Study/Coding Test/Algorithm/Help Python과 Pypy.md","exportPath":"1.-study/coding-test/algorithm/help-python과-pypy.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/algorithm/java-기본.html":{"title":"java 기본","icon":"","description":"NAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/Algorithm/Algorithm.md\" data-href=\"1. Study/Coding Test/Algorithm/Algorithm.md\" href=\"1.-study/coding-test/algorithm/algorithm.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Algorithm</a><a data-tooltip-position=\"top\" aria-label=\"https://nahwasa.com/entry/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B1%EC%A4%80-%ED%92%80-%EB%95%8C%EC%9D%98-%ED%8C%81-%EB%B0%8F-%EC%A3%BC%EC%9D%98%EC%A0%90-boj-java\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://nahwasa.com/entry/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B1%EC%A4%80-%ED%92%80-%EB%95%8C%EC%9D%98-%ED%8C%81-%EB%B0%8F-%EC%A3%BC%EC%9D%98%EC%A0%90-boj-java\" target=\"_self\">자바로 백준 풀 때의 팁 및 주의점 (boj java) - Nahwasa</a>","aliases":[],"inlineTags":[],"frontmatterTags":["#정리"],"headers":[{"heading":"java 기본","level":1,"id":"java 기본"}],"links":["1.-study/coding-test/algorithm/algorithm.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/algorithm/java-기본.html","pathToRoot":"../../..","attachments":[],"createdTime":1715664552612,"modifiedTime":1716651176016,"sourceSize":501,"sourcePath":"1. Study/Coding Test/Algorithm/java 기본.md","exportPath":"1.-study/coding-test/algorithm/java-기본.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/etc/숫자-자료형과-계산-오차.html":{"title":"숫자 자료형과 계산 오차","icon":"","description":"<a data-href=\"1072. 게임\" href=\"1.-study/coding-test/ps/1072.-게임.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1072. 게임</a>참고: <a data-tooltip-position=\"top\" aria-label=\"https://youtu.be/-GsrYvZoAdA?si=zYEwjxJs2aowVkE5\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://youtu.be/-GsrYvZoAdA?si=zYEwjxJs2aowVkE5\" target=\"_self\">위 수식이 틀린 이유는? (개발자 면접 타임) - YouTube</a>“컴퓨터는 무한한 숫자를 저장하지 못한다” 는 말은 쉽게 동의할 수 있는 명제이다.그러나 이 의미를 정확히 숙지하지 않고 코드를 짜다간 단순히 큰 수를 표현하지 못하는 것으로부터, 계산 결과를 전혀 다르게 만드는 들 불안정한 코드가 완성되게 된다.각각의 자료형은 고유한 메모리 크기를 가지고, 그 크기에 기반하여 해당 자료형이 표현할 수 있는 범위가 정해진다. 숫자를 표현하는 자료형은 경우 정수 자료형과 실수 자료형으로 나뉘고, 각각은 또 여러 개의 자료형으로 나뉜다.자바에서 정수를 표현하기 위한 자료형은 byte, short, int, long이 있다. 기본적으로 int 자료형을 사용한다.해당 범위 내의 값은 정확히 저장하지만, 표현범위를 벗어나는 값을 저장하는 경우 전혀 다른 값을 가지게 된다.<br><img alt=\"스크린샷 2024-10-29 182303 1.png\" src=\"5.-file/image/스크린샷-2024-10-29-182303-1.png\" style=\"width: 270px; max-width: 100%;\" target=\"_self\">\n→ int로 표현가능한 정수들앞서 살펴본 표와 위의 그림을 보면 알 수 있지만, 자바에서 사용하는 정수형들은 음의 정수와 양의 정수를 함께 표현한다. (C언어의 경우 unsigned int와 같이 양의 정수만 표현하는 자료형도 존재한다.)\n컴퓨터가 0과 1로 이루어진 이진수로 데이터를 표현한다고 하는 것을 유명하지만, 음수와 정수는 어떻게 표현할까?메모리에 int형을 저장할 때는 아래와 같이 총 32개의 cell이 할당된다. (= 32 bit = 8 byte)자바에서 정수를 표현하기 위한 자료형은 float와 double이 있다. 기본적으로 표현범위가 넓은 double을 사용한다.이렇게 컴퓨터는 유한한 범위의 숫자만 저장이 가능하다.<br>\n<img alt=\"Pasted image 20241029183732.png\" src=\"5.-file/image/pasted-image-20241029183732.png\" target=\"_self\">문제는 이것으로 끝이 아니다. 위에서 살펴본 유한한 범위 내의 숫자라도 정밀하지 못하게 저장되는 경우가 있기 때문이다.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"숫자 자료형과 계산 오차","level":1,"id":"숫자 자료형과 계산 오차"},{"heading":"자료형","level":3,"id":"자료형"},{"heading":"정수 자료형","level":4,"id":"정수_자료형"},{"heading":"메모리에는?","level":5,"id":"메모리에는?"},{"heading":"실수 자료형","level":4,"id":"실수_자료형"},{"heading":"","level":3,"id":""}],"links":["1.-study/coding-test/ps/1072.-게임.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/etc/숫자-자료형과-계산-오차.html","pathToRoot":"../../..","attachments":["5.-file/image/스크린샷-2024-10-29-182303-1.png","5.-file/image/pasted-image-20241029183732.png"],"createdTime":1730178201830,"modifiedTime":1730195975735,"sourceSize":3281,"sourcePath":"1. Study/Coding Test/etc/숫자 자료형과 계산 오차.md","exportPath":"1.-study/coding-test/etc/숫자-자료형과-계산-오차.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/etc/etc.html":{"title":"etc","icon":"","description":"<a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/etc/new file.md\" data-href=\"1. Study/Coding Test/etc/new file.md\" href=\"1. Study/Coding Test/etc/new file\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new file</a> | <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/etc/new folder/new folder.md\" data-href=\"1. Study/Coding Test/etc/new folder/new folder.md\" href=\"1. Study/Coding Test/etc/new folder/new folder\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new folder</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"etc","level":1,"id":"etc"},{"heading":"Note","level":3,"id":"Note"},{"heading":"File","level":3,"id":"File"}],"links":["1. Study/Coding Test/etc/new file.md","1. Study/Coding Test/etc/new folder/new folder.md","1.-study/coding-test/etc/숫자-자료형과-계산-오차.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/etc/etc.html","pathToRoot":"../../..","attachments":[],"createdTime":1730178878323,"modifiedTime":1730194883558,"sourceSize":415,"sourcePath":"1. Study/Coding Test/etc/etc.md","exportPath":"1.-study/coding-test/etc/etc.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1로-만들기.html":{"title":"1로 만들기","icon":"","description":"ID: 1463\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1463\" target=\"_self\">https://www.acmicpc.net/problem/1463</a>\n난이도: 실버 3\n다시풀기: No\n분류: 다이나믹 프로그래밍\n생성 일시: 2023년 8월 13일 오후 11:15\n💡 - 이거 진짜 도움됨.<br><a data-tooltip-position=\"top\" aria-label=\"https://bio-info.tistory.com/159\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://bio-info.tistory.com/159\" target=\"_self\">[백준] 1463 1로 만들기 (DP) - Python / 자세한 설명 / 여러가지 풀이 / 실버1</a>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.\nX가 3으로 나누어 떨어지면, 3으로 나눈다.\nX가 2로 나누어 떨어지면, 2로 나눈다.\n1을 뺀다.\n정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.2 복사1 복사10 복사3 복사10의 경우에 10 → 9 → 3 → 1 로 3번 만에 만들 수 있다.\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/cyj101366\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/cyj101366\" target=\"_self\">cyj101366</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jugol\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jugol\" target=\"_self\">jugol</a>\n<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/dbfldkfdbgml\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/dbfldkfdbgml\" target=\"_self\">dbfldkfdbgml</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/dynamiseus\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/dynamiseus\" target=\"_self\">dynamiseus</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jooa7878\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jooa7878\" target=\"_self\">jooa7878</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/lcr7324\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/lcr7324\" target=\"_self\">lcr7324</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/25\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/25\" target=\"_self\">다이나믹 프로그래밍</a> Python 3: 1.5 초\nPyPy3: 0.7 초\nPython 2: 1.5 초\nPyPy2: 0.7 초 10 -1(9) /3\n/3 -2(8) /2\n/2\n/2 -3(7)\n-4(6) /3\n/2 -5(5)\n-6(4) /2\n/2 -7 빼는 수를 하나씩 늘려가면서, 빼고, 각각의 경우에 2,3으로 나누고 나누어 떨어지는 경우 개수를 비교함 min 자 계속 틀림...\n복사 dp공부 후… dp list는 X길이로 만들어야겠지… 1을 1로 만들려면 → 0 2를 1로 만들려면 (2) → 1 3을 1로 만들려면 /3 → 1 4를 1로 만들려면 /2/2 → 2 5를 1로 만들려면 →3 점화식을 어떻게 만들어야할까. f(1) = 0 f(2) = 1 f(3) = 1 f(4) = 2 f(5) = 3 f(6) = 2 → f(7) = 3 → -1, f(6) f(8) = 3 → /2, f(4) f(9) = 2 → /3, f(3) f(10) = → -1, f(9) 복사import sys def make_one_topdown(x): if x == 1: return 0 elif x%3 == 0 and x%2 == 0: return 1+ min(make_one_topdown(x//3), make_one_topdown(x//2), make_one_topdown(x-1)) elif x%3 == 0: return 1+ min(make_one_topdown(x//3), make_one_topdown(x-1)) elif x%2 == 0: return 1+ min(make_one_topdown(x//2), make_one_topdown(x-1)) else: return 1+ make_one_topdown(x-1) if __name__ == \"__main__\": print(make_one_topdown(int(sys.stdin.readline().rstrip())))\n복사\n생각해보니까. 이 방식은 메모, 재사용의 취지에 딱 들어맞진 않음.\n여기에 table을 추가하는 겨..\nimport sys X = int(sys.stdin.readline().rstrip())\ndp = {1:0}\ndef make_one_topdown(x): if x in dp: return dp[x] else: dp[x] = 1+ min(make_one_topdown(x//3)+x%3, make_one_topdown(x//2)+x%2, make_one_topdown(x-1)) return dp[x] print(make_one_topdown(X))\n복사\nRecursionError: maximum recursion depth exceeded\n생각해보면, make_one_topdown(x-1) 필요 없음…\nimport sys X = int(sys.stdin.readline().rstrip())\ndp = {1:0,2:1, 3:1}\ndef make_one_topdown(x): if x in dp: return dp[x] else: dp[x] = 1+ min(make_one_topdown(x//3)+ x%3, make_one_topdown(x//2)+x%2) return dp[x] print(make_one_topdown(X))\n복사\n시간이 거의 10배 차이남\nBottom-up 방식은 dp(1)부터 dp(n)까지 전부 구하지만 top-down 방식은 그렇지 않습니다. 실제로 top-down 코드에서 dp(n) 계산이 끝난 후에 arr 전체를 출력해 보면 1~n 전부가 아닌 일부만 계산되어 있음을 확인할 수 있습니다.\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/board/view/122640\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/board/view/122640\" target=\"_self\">글 읽기 - Top-down Bottom-up 시간 차이에 대한 질문입니다</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1로 만들기","level":1,"id":"1로 만들기"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"힌트","level":2,"id":"힌트"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"시간 제한","level":2,"id":"시간_제한"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"},{"heading":"topdown 방식으로 연습","level":2,"id":"topdown_방식으로_연습"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1로-만들기.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247792,"modifiedTime":1722965294942,"sourceSize":4838,"sourcePath":"1. Study/Coding Test/PS/1로 만들기.md","exportPath":"1.-study/coding-test/ps/1로-만들기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/01타일.html":{"title":"01타일","icon":"","description":"ID: 1904\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1904\" target=\"_self\">https://www.acmicpc.net/problem/1904</a>\n난이도: 실버 3\n다시풀기: No\n생성 일시: 2023년 9월 10일 오후 8:37지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다. 그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다. 결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.그러므로 지원이는 타일로 더 이상 크기가&nbsp;N인&nbsp;모든 2진 수열을 만들 수 없게 되었다. 예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.) 또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.첫 번째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 1,000,000)첫 번째 줄에 지원이가 만들 수 있는 길이가 N인 모든 2진 수열의 개수를 15746으로 나눈 나머지를 출력한다.4 복사5 복사\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/mwy3055\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/mwy3055\" target=\"_self\">mwy3055</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/qortmd7777\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/qortmd7777\" target=\"_self\">qortmd7777</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/wider93\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/wider93\" target=\"_self\">wider93</a> N=1 1 N=2 00\n11 N=3 100\n001\n111 N=4 0000\n1100\n1001\n0011\n1111 복사복사복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"01타일","level":1,"id":"01타일"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/01타일.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247809,"modifiedTime":1715664196171,"sourceSize":2217,"sourcePath":"1. Study/Coding Test/PS/01타일.md","exportPath":"1.-study/coding-test/ps/01타일.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/99-club-2기-코테-문제-정리.html":{"title":"99 club 2기 코테 문제 정리","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a> <br>비기너: 폰켓몬 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/1845\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/1845</a>)\n<br>미들러: 전화번호 목록 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42577\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42577</a>)\n<br>챌린저: 베스트앨범 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42579\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42579</a>) <br>비기너: 완주하지 못한 선수 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42576\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42576</a>)\n<br>미들러: 의상 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42578\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42578</a>)\n<br>챌린저: 비슷한 단어 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/2179\" target=\"_self\">https://www.acmicpc.net/problem/2179</a>) <br>비기너: 같은 숫자는 싫어(<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12906\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/12906</a>)\n<br>미들러: 기능개발 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42586\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42586</a>)\n<br>챌린저: 다리를 지나는 트럭 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42583\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42583</a>) <br>비기너: Valid Parentheses (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/valid-parentheses/description/\" target=\"_self\">https://leetcode.com/problems/valid-parentheses/description/</a>)\n<br>미들러: 올바른 괄호 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/12909/\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/12909/</a>)\n<br>챌린저: 주식 가격 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42584\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42584</a>) <br>비기너: Minimum Number Game(<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/minimum-number-game/description/\" target=\"_self\">https://leetcode.com/problems/minimum-number-game/description/</a>)\n<br>미들러: 더 맵게 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42626\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42626</a>)\n<br>챌린저: 디스크 컨트롤러 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42627\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42627</a>) <br>비기너: Maximum Product of Two Elements in an array (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/smallest-number-in-infinite-set/description/\" target=\"_self\">https://leetcode.com/problems/smallest-number-in-infinite-set/description/</a>)\n<br>미들러: smallest-number-in-infinite-set (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/smallest-number-in-infinite-set/description/\" target=\"_self\">https://leetcode.com/problems/smallest-number-in-infinite-set/description/</a>)\n<br>챌린저: 이중우선순위큐 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42628\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42628</a>) <br>비기너: k번째 수 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42748\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42748</a>)\n<br>미들러: 가장 큰 수 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42746\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42746</a>)\n<br>챌린저: Put Marbles in Bags (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/put-marbles-in-bags/description/\" target=\"_self\">https://leetcode.com/problems/put-marbles-in-bags/description/</a>) <br>비기너: count-pairs-whose-sum-is-less-than-target (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/\" target=\"_self\">https://leetcode.com/problems/count-pairs-whose-sum-is-less-than-target/</a>)\n<br>미들러: H 인덱스 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42747\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42747</a>)\n<br>챌린저: orderly-queue (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/orderly-queue/description/\" target=\"_self\">https://leetcode.com/problems/orderly-queue/description/</a>) <br>비기너: 최소직사각형 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/86491\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/86491</a>)\n<br>미들러: 카펫 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42842\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42842</a>)\n<br>챌린저: 모음사전 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/84512\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/84512</a>) <br>비기너: 모의고사 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42840\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42840</a>)\n<br>미들러: 소수찾기 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42839\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42839</a>)\n<br>챌린저: 전력망을 둘로 나누기 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/86971\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/86971</a>) <br>비기너: Range sum of bst (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/range-sum-of-bst/\" target=\"_self\">https://leetcode.com/problems/range-sum-of-bst/</a>)\n<br>미들러: 타겟넘버 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43165\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/43165</a>)\n<br>챌린저: 퍼즐조각채우기 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/84021\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/84021</a>) <br>비기너: Find a Corresponding Node of a Binary Tree in a Clone of That Tree (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/description/\" target=\"_self\">https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/description/</a>)\n<br>미들러: 게임 맵 최단거리 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/1844\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/1844</a>)\n<br>챌린저: 여행경로(<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43164\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/43164</a>) <br>비기너: Invert-binary-tree (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/invert-binary-tree/\" target=\"_self\">https://leetcode.com/problems/invert-binary-tree/</a>)\n<br>미들러: All-paths-from-source-to-target (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/all-paths-from-source-to-target/description/\" target=\"_self\">https://leetcode.com/problems/all-paths-from-source-to-target/description/</a>)\n<br>챌린저: 단어변환 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43163\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/43163</a>) <br>비기너: Maximum-depth-of-binary-tree (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\" target=\"_self\">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a>)\n<br>미들러: Reverse Odd Levels of Binary Tree (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/description/\" target=\"_self\">https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/description/</a>)\n<br>챌린저: 네트워크(<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43162\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/43162</a>) <br>비기너: 체육복 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42862\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42862</a>)\n<br>미들러: 조이스틱 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42860\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42860</a>)\n<br>챌린저: 섬연결하기 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42861\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42861</a>) <br>비기너: Split-a-string-in-balanced-strings (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/split-a-string-in-balanced-strings/description/\" target=\"_self\">https://leetcode.com/problems/split-a-string-in-balanced-strings/description/</a>)\n<br>미들러: 구명보트 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42885\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42885</a>)\n<br>챌린저: 단속카메라(<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42884\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42884</a>) <br>비기너: Counting-bits (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/counting-bits/\" target=\"_self\">https://leetcode.com/problems/counting-bits/</a>)\n<br>미들러: All-possible-full-binary-trees (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/all-possible-full-binary-trees/description/\" target=\"_self\">https://leetcode.com/problems/all-possible-full-binary-trees/description/</a>)\n<br>챌린저: N으로 표현 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42895\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42895</a>) <br>비기너: pascals-triangle (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/pascals-triangle/description/\" target=\"_self\">https://leetcode.com/problems/pascals-triangle/description/</a>)\n<br>미들러: Count Sorted Vowel Strings (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/count-sorted-vowel-strings/description/\" target=\"_self\">https://leetcode.com/problems/count-sorted-vowel-strings/description/</a>)\n<br>챌린저: 정수 삼각형 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43105\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/43105</a>) <br>비기너: Fibonacci-number (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/fibonacci-number/description/\" target=\"_self\">https://leetcode.com/problems/fibonacci-number/description/</a>)\n<br>미들러: partition-array-for-maximum-sum (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/partition-array-for-maximum-sum/description/\" target=\"_self\">https://leetcode.com/problems/partition-array-for-maximum-sum/description/</a>)\n<br>챌린저: 사칙연산 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/1843\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/1843</a>) <br>비기너: divisor-game (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/divisor-game/description/\" target=\"_self\">https://leetcode.com/problems/divisor-game/description/</a>)\n<br>미들러: Count Square Submatrices with All Ones (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/count-square-submatrices-with-all-ones/description/\" target=\"_self\">https://leetcode.com/problems/count-square-submatrices-with-all-ones/description/</a>)\n<br>챌린저: 도둑질 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42897\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42897</a>) <br>비기너: Search Insert Position (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/search-insert-position/description/\" target=\"_self\">https://leetcode.com/problems/search-insert-position/description/</a>)\n<br>미들러: 입국심사 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43238\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/43238</a>)\n<br>챌린저: 징검다리(<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43236\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/43236</a>) <br>비기너: Count-negative-numbers-in-a-sorted-matrix (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description/\" target=\"_self\">https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description/</a>)\n<br>미들러: Capacity-to-ship-packages-within-d-days (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\" target=\"_self\">https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/</a>)\n<br>챌린저: K-th-smallest-prime-fraction (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/k-th-smallest-prime-fraction/description/\" target=\"_self\">https://leetcode.com/problems/k-th-smallest-prime-fraction/description/</a>) <br>비기너: Find-center-of-star-graph (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/find-center-of-star-graph/description/\" target=\"_self\">https://leetcode.com/problems/find-center-of-star-graph/description/</a>)\n<br>미들러: 가장 먼 노드 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/49189\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/49189</a>)\n<br>챌린저: 방의 개수 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/49190\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/49190</a>) <br>비기너: Minimum Number of Moves to Seat Everyone (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/description/?envType=daily-question&amp;envId=2024-06-13\" target=\"_self\">https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/description/?envType=daily-question&amp;envId=2024-06-13</a>)\n<br>미들러: 순위 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/49191\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/49191</a>)\n<br>챌린저: Find-if-path-exists-in-graph (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/find-if-path-exists-in-graph/description/\" target=\"_self\">https://leetcode.com/problems/find-if-path-exists-in-graph/description/</a>) <br>비기너: shuffle-the-array (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/shuffle-the-array/description/\" target=\"_self\">https://leetcode.com/problems/shuffle-the-array/description/</a>)\n<br>미들러: subrectangle-queries (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/subrectangle-queries/description/\" target=\"_self\">https://leetcode.com/problems/subrectangle-queries/description/</a> )\n<br>챌린저: h-index-ii (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/h-index-ii/description/\" target=\"_self\">https://leetcode.com/problems/h-index-ii/description/</a>) <br>비기너: number-of-good-pairs (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/number-of-good-pairs/description/\" target=\"_self\">https://leetcode.com/problems/number-of-good-pairs/description/</a>)\n<br>미들러: find-the-original-array-of-prefix-xor (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/find-the-original-array-of-prefix-xor/description/\" target=\"_self\">https://leetcode.com/problems/find-the-original-array-of-prefix-xor/description/</a>)\n<br>챌린저: maximum-number-of-alloys (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/maximum-number-of-alloys/description/\" target=\"_self\">https://leetcode.com/problems/maximum-number-of-alloys/description/</a>) <br>비기너: find-words-containing-character (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/find-words-containing-character/description/\" target=\"_self\">https://leetcode.com/problems/find-words-containing-character/description/</a>)\n<br>미들러: group-the-people-given-the-group-size-they-belong-to (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/description/\" target=\"_self\">https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/description/</a>)\n<br>챌린저: count-the-hidden-sequences (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/count-the-hidden-sequences/description/\" target=\"_self\">https://leetcode.com/problems/count-the-hidden-sequences/description/</a>) <br>비기너: count-items-matching-a-rule (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/count-items-matching-a-rule/description/\" target=\"_self\">https://leetcode.com/problems/count-items-matching-a-rule/description/</a>)\n<br>미들러: iterator-for-combination (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/iterator-for-combination/description/\" target=\"_self\">https://leetcode.com/problems/iterator-for-combination/description/</a>)\n<br>챌린저: next-greater-element-iii (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/next-greater-element-iii/description/\" target=\"_self\">https://leetcode.com/problems/next-greater-element-iii/description/</a>) <br>비기너: shuffle-string (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/shuffle-string/description/\" target=\"_self\">https://leetcode.com/problems/shuffle-string/description/</a>)\n<br>미들러: minimum-suffix-flips (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/minimum-suffix-flips/description/\" target=\"_self\">https://leetcode.com/problems/minimum-suffix-flips/description/</a>)\n<br>챌린저: longest-palindromic-substring (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/longest-palindromic-substring/description/\" target=\"_self\">https://leetcode.com/problems/longest-palindromic-substring/description/</a>) <br>비기너: decode-the-message (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/decode-the-message/description/\" target=\"_self\">https://leetcode.com/problems/decode-the-message/description/</a>)\n<br>미들러: sort-characters-by-frequency (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/sort-characters-by-frequency/description/\" target=\"_self\">https://leetcode.com/problems/sort-characters-by-frequency/description/</a>)\n<br>챌린저: remove-k-digits (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/remove-k-digits/description/\" target=\"_self\">https://leetcode.com/problems/remove-k-digits/description/</a>) <br>비기너: neither-minimum-nor-maximum (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/neither-minimum-nor-maximum/description/\" target=\"_self\">https://leetcode.com/problems/neither-minimum-nor-maximum/description/</a>)\n<br>미들러: top-k-frequent-elements/ (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/top-k-frequent-elements/description/\" target=\"_self\">https://leetcode.com/problems/top-k-frequent-elements/description/</a>)\n<br>챌린저: minimum-lines-to-represent-a-line-chart (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/description/\" target=\"_self\">https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/description/</a>) <br>비기너: find-target-indices-after-sorting-array (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/find-target-indices-after-sorting-array/description/\" target=\"_self\">https://leetcode.com/problems/find-target-indices-after-sorting-array/description/</a>)\n<br>미들러: reordered-power-of-2 (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/reordered-power-of-2/description/\" target=\"_self\">https://leetcode.com/problems/reordered-power-of-2/description/</a>)\n<br>챌린저: append-k-integers-with-minimal-sum (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/append-k-integers-with-minimal-sum/description/\" target=\"_self\">https://leetcode.com/problems/append-k-integers-with-minimal-sum/description/</a>) <br>비기너: Number-of-students-unable-to-eat-lunch (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/description/\" target=\"_self\">https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/description/</a>)\n<br>미들러: find-the-winner-of-the-circular-game (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/find-the-winner-of-the-circular-game/description/\" target=\"_self\">https://leetcode.com/problems/find-the-winner-of-the-circular-game/description/</a>)\n<br>챌린저: minimum-number-of-coins-for-fruits (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/minimum-number-of-coins-for-fruits/description/\" target=\"_self\">https://leetcode.com/problems/minimum-number-of-coins-for-fruits/description/</a>) <br>비기너: number-of-recent-calls (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/number-of-recent-calls/\" target=\"_self\">https://leetcode.com/problems/number-of-recent-calls/</a>)\n<br>미들러: flatten-nested-list-iterator (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/flatten-nested-list-iterator/description/\" target=\"_self\">https://leetcode.com/problems/flatten-nested-list-iterator/description/</a>)\n<br>챌린저: continuous-subarrays (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/continuous-subarrays/description/\" target=\"_self\">https://leetcode.com/problems/continuous-subarrays/description/</a>) <br>비기너: final-prices-with-a-special-discount-in-a-shop (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/description/\" target=\"_self\">https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/description/</a>)\n<br>미들러: Removing-stars-from-a-string (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/removing-stars-from-a-string/description/\" target=\"_self\">https://leetcode.com/problems/removing-stars-from-a-string/description/</a>)\n<br>챌린저: Using-a-robot-to-print-the-lexicographically-smallest-string (<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/usin\" target=\"_self\">https://leetcode.com/problems/usin</a>...\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"99 club 2기 코테 문제 정리","level":1,"id":"99 club 2기 코테 문제 정리"},{"heading":"2024-05-20","level":4,"id":"2024-05-20"},{"heading":"2024-05-21","level":4,"id":"2024-05-21"},{"heading":"2024-05-22","level":4,"id":"2024-05-22"},{"heading":"2024-05-23","level":4,"id":"2024-05-23"},{"heading":"2024-05-24","level":4,"id":"2024-05-24"},{"heading":"2024-05-25","level":4,"id":"2024-05-25"},{"heading":"2024-05-26","level":4,"id":"2024-05-26"},{"heading":"2024-05-27","level":4,"id":"2024-05-27"},{"heading":"2024-05-28","level":4,"id":"2024-05-28"},{"heading":"2024-05-29","level":4,"id":"2024-05-29"},{"heading":"2024-05-30","level":4,"id":"2024-05-30"},{"heading":"2024-06-01","level":4,"id":"2024-06-01"},{"heading":"2024-06-02","level":4,"id":"2024-06-02"},{"heading":"2024-06-03","level":4,"id":"2024-06-03"},{"heading":"2024-06-04","level":4,"id":"2024-06-04"},{"heading":"2024-06-05","level":4,"id":"2024-06-05"},{"heading":"2024-06-06","level":4,"id":"2024-06-06"},{"heading":"2024-06-07","level":4,"id":"2024-06-07"},{"heading":"2024-06-08","level":4,"id":"2024-06-08"},{"heading":"2024-06-09","level":4,"id":"2024-06-09"},{"heading":"2024-06-10","level":4,"id":"2024-06-10"},{"heading":"2024-06-11","level":4,"id":"2024-06-11"},{"heading":"2024-06-12","level":4,"id":"2024-06-12"},{"heading":"2024-06-13","level":4,"id":"2024-06-13"},{"heading":"2024-06-14","level":4,"id":"2024-06-14"},{"heading":"2024-06-15","level":4,"id":"2024-06-15"},{"heading":"2024-06-16","level":4,"id":"2024-06-16"},{"heading":"2024-06-17","level":4,"id":"2024-06-17"},{"heading":"2024-06-18","level":4,"id":"2024-06-18"},{"heading":"2024-06-19","level":4,"id":"2024-06-19"},{"heading":"2024-06-20","level":4,"id":"2024-06-20"},{"heading":"2024-06-21","level":4,"id":"2024-06-21"},{"heading":"2024-06-22","level":4,"id":"2024-06-22"},{"heading":"2024-06-23","level":4,"id":"2024-06-23"},{"heading":"2024-06-24","level":4,"id":"2024-06-24"},{"heading":"2024-06-25","level":4,"id":"2024-06-25"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/99-club-2기-코테-문제-정리.html","pathToRoot":"../../..","attachments":[],"createdTime":1718329059971,"modifiedTime":1719286062109,"sourceSize":11994,"sourcePath":"1. Study/Coding Test/PS/99 club 2기 코테 문제 정리.md","exportPath":"1.-study/coding-test/ps/99-club-2기-코테-문제-정리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/894.-all-possible-full-binary-trees.html":{"title":"894. All Possible Full Binary Trees","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-06<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/all-possible-full-binary-trees/description/\" target=\"_self\">https://leetcode.com/problems/all-possible-full-binary-trees/description/</a>Level: MediumCategory: <br><a data-href=\"Dynamic Programming\" href=\"Dynamic Programming\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">Dynamic Programming</a><br><a data-href=\"Tree\" href=\"Tree\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">Tree</a>Success: ⭕Git: -Given an integer&nbsp;n, return&nbsp;a list of all possible&nbsp;full binary trees&nbsp;with&nbsp;n&nbsp;nodes. Each node of each tree in the answer must have&nbsp;Node.val == 0.Each element of the answer is the root node of one possible tree. You may return the final list of trees in&nbsp;any order.A&nbsp;full binary tree&nbsp;is a binary tree where each node has exactly&nbsp;0&nbsp;or&nbsp;2&nbsp;children.Example 1:<br><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">Input: n = 7<br>\nOutput: <a data-href=\"0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0\" href=\"0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0</a>Example 2:Input: n = 3<br>\nOutput: <a data-href=\"0,0,0\" href=\"0,0,0\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">0,0,0</a>Constraints:\n1 &lt;= n &lt;= 20 한참 헤메다가 쓰는 코드 자체에서 재귀를 하면 좋겠다는 생각.\n이번 문제는 재귀가 반복문보다 깔끔하게 느껴짐…\n/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */\nclass Solution { public List&lt;TreeNode&gt; allPossibleFBT(int n) { // root of (sub)tree TreeNode root = new TreeNode(0); n -= 1; List&lt;TreeNode&gt; trees = new ArrayList&lt;&gt;(); // return when it is edge. if(n == 0) { trees.add(root); return trees; } // children of root for (int i = 1; i &lt;= n-1; i+=2) { TreeNode newRoot = copyTreeNode(root); List&lt;TreeNode&gt; left = allPossibleFBT(i); List&lt;TreeNode&gt; right = allPossibleFBT(n-i); for (TreeNode l:left) { newRoot.left = l; for (TreeNode r:right) { newRoot.right = r; trees.add(newRoot); } } } return trees; } private TreeNode copyTreeNode(TreeNode node) { TreeNode newNode = new TreeNode(0); if (node.left != null) { newNode.left = copyTreeNode(node.left); } if (node.right != null) { newNode.right = copyTreeNode(node.right); } return newNode; }\n}\n복사\n중간에 잘못이해 → TreeNode를 새로 생성해주는 순간을 헷갈림. + 굳이 copy 할 필요도 없음. 이때 만들어진 node는 아직 자식 요소가 하나도 없잖아… 이제 연결해줘야할뿐.\n/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */\nclass Solution { public List&lt;TreeNode&gt; allPossibleFBT(int n) { // root of (sub)tree / return List n -= 1; List&lt;TreeNode&gt; trees = new ArrayList&lt;&gt;(); // return when it is edge. if(n == 0) { trees.add(new TreeNode(0)); return trees; } // children of root for (int i = 1; i &lt;= n-1; i+=2) { List&lt;TreeNode&gt; left = allPossibleFBT(i); List&lt;TreeNode&gt; right = allPossibleFBT(n-i); for (TreeNode l:left) { for (TreeNode r:right) { TreeNode newRoot = new TreeNode(0); newRoot.left = l; newRoot.right = r; trees.add(newRoot); } } } return trees; }\n}\n복사 시간 3ms 더 줄일 수 있을 것 같은데. 아 우와 진짜 dp로 하려면, n에 따른 tree를 기억하고 있어야겠구나! → map사용해서 dp 구현 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ import java.util.*;\nclass Solution { public List&lt;TreeNode&gt; allPossibleFBT(int n) { Map&lt;Integer, List&lt;TreeNode&gt;&gt; map = new HashMap&lt;&gt;(); return solve(n, map); } public List&lt;TreeNode&gt; solve(int n, Map&lt;Integer, List&lt;TreeNode&gt;&gt; map){ // root of (sub)tree / return List n -= 1; List&lt;TreeNode&gt; trees = new ArrayList&lt;&gt;(); // return when it is edge. if(n == 0) { trees.add(new TreeNode(0)); return trees; } if (map.containsKey(n)) { return map.get(n); } // children of root for (int i = 1; i &lt;= n-1; i+=2) { List&lt;TreeNode&gt; left = solve(i, map); List&lt;TreeNode&gt; right = solve(n-i, map); for (TreeNode l:left) { for (TreeNode r:right) { TreeNode newRoot = new TreeNode(0); newRoot.left = l; newRoot.right = r; trees.add(newRoot); } } } map.put(n, trees); return trees; }\n}\n복사\n1ms\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"894. All Possible Full Binary Trees","level":1,"id":"894. All Possible Full Binary Trees"},{"heading":"문제","level":3,"id":"문제"},{"heading":"풀이","level":3,"id":"풀이"},{"heading":"성공","level":4,"id":"성공"},{"heading":"성공2","level":4,"id":"성공2"}],"links":["1.-study/coding-test/ps/ps.html","Dynamic Programming","Tree","0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0","0,0,0"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/894.-all-possible-full-binary-trees.html","pathToRoot":"../../..","attachments":[],"createdTime":1717655095000,"modifiedTime":1717661151414,"sourceSize":6597,"sourcePath":"1. Study/Coding Test/PS/894. All Possible Full Binary Trees.md","exportPath":"1.-study/coding-test/ps/894.-all-possible-full-binary-trees.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1003.-피보나치-함수.html":{"title":"1003. 피보나치 함수","icon":"","description":"NAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.int fibonacci(int n) {\nif (n == 0) {\nprintf(\"0\");\nreturn 0;\n} else if (n == 1) {\nprintf(\"1\");\nreturn 1;\n} else {\nreturn fibonacci(n‐1) + fibonacci(n‐2);\n}\n}fibonacci(3)을 호출하면 다음과 같은 일이 일어난다.\nfibonacci(3)은&nbsp;fibonacci(2)와&nbsp;fibonacci(1)&nbsp;(첫 번째 호출)을 호출한다.\nfibonacci(2)는&nbsp;fibonacci(1)&nbsp;(두 번째 호출)과&nbsp;fibonacci(0)을 호출한다.\n두 번째 호출한&nbsp;fibonacci(1)은 1을 출력하고 1을 리턴한다.\nfibonacci(0)은 0을 출력하고, 0을 리턴한다.\nfibonacci(2)는&nbsp;fibonacci(1)과&nbsp;fibonacci(0)의 결과를 얻고, 1을 리턴한다.\n첫 번째 호출한&nbsp;fibonacci(1)은 1을 출력하고, 1을 리턴한다.\nfibonacci(3)은&nbsp;fibonacci(2)와&nbsp;fibonacci(1)의 결과를 얻고, 2를 리턴한다.\n1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때,&nbsp;fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.첫째 줄에 테스트 케이스의 개수 T가 주어진다.각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.3\n0\n1\n31 0\n0 1\n1 22\n6\n225 8\n10946 17711\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/connotation\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/connotation\" target=\"_self\">connotation</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/doju\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/doju\" target=\"_self\">doju</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/wonrok97\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/wonrok97\" target=\"_self\">wonrok97</a>\n<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/cyj101366\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/cyj101366\" target=\"_self\">cyj101366</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/25\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/25\" target=\"_self\">다이나믹 프로그래밍</a> 다이나믹 프로그래밍 호출이 아니라 출력의 문제임\n(1,0)\n2: 1+0 → (1,1)\n3: 2+1 → (1,2)\n4: 3+2 → (2,3)\n5: 4+3 → (3,5)\n6: 5+4 → (5,8) down-top 방식으로 구현 import sys def fibonacci(): N = int(sys.stdin.readline().rstrip()) dp_0 = [1,0,1] dp_1 = [0,1,1] while N &gt; 0: N -= 1 num = int(sys.stdin.readline().rstrip()) if (num &lt; 3): print(dp_0[num], dp_1[num]) else: zero = 0 one = 0 for i in range(len(dp_0), num+1): dp_0.append(dp_0[i - 1] + dp_0[i - 2]) dp_1.append(dp_1[i - 1] + dp_1[i - 2]) zero = dp_0[i] one = dp_1[i] print(zero, one) if __name__ == \"__main__\": fibonacci()\n복사\n앞선 순서에서 dp list를 채워 두어 len(dp_0)&gt;num+1 인 경우에, for문이 돌아가지 않고 0 0 이 출력됨.\nimport sys def fibonacci(): N = int(sys.stdin.readline().rstrip()) dp_0 = [1,0,1] dp_1 = [0,1,1] while N &gt; 0: N -= 1 num = int(sys.stdin.readline().rstrip()) if (num &lt; len(dp_0)): print(dp_0[num], dp_1[num]) else: zero = 0 one = 0 for i in range(len(dp_0), num+1): dp_0.append(dp_0[i - 1] + dp_0[i - 2]) dp_1.append(dp_1[i - 1] + dp_1[i - 2]) zero = dp_0[i] one = dp_1[i] print(zero, one) if __name__ == \"__main__\": fibonacci()\n복사","aliases":[],"inlineTags":[],"frontmatterTags":["#실버/3"],"headers":[{"heading":"1003. 피보나치 함수","level":1,"id":"1003. 피보나치 함수"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1 복사","level":2,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":2,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":2,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":2,"id":"예제_출력_2 복사"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"1차 실패","level":3,"id":"1차_실패"},{"heading":"2차 성공","level":3,"id":"2차_성공"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1003.-피보나치-함수.html","pathToRoot":"../../..","attachments":[],"createdTime":1711451603170,"modifiedTime":1716651174946,"sourceSize":4401,"sourcePath":"1. Study/Coding Test/PS/1003. 피보나치 함수.md","exportPath":"1.-study/coding-test/ps/1003.-피보나치-함수.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1011.-capacity-to-ship-packages-within-d-days.html":{"title":"1011. Capacity To Ship Packages Within D Days","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-11<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\" target=\"_self\">https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/</a>Level: MediumCategory: <br><a data-href=\"Search\" href=\"Search\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">Search</a>Success: ⭕ +aGit: -A conveyor belt has packages that must be shipped from one port to another within&nbsp;days&nbsp;days.The&nbsp;ith&nbsp;package on the conveyor belt has a weight of&nbsp;weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by&nbsp;weights). We may not load more weight than the maximum weight capacity of the ship.Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within&nbsp;days&nbsp;days.Example 1:Input: weights = [1,2,3,4,5,6,7,8,9,10], days = 5\nOutput: 15\nExplanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n1st day: 1, 2, 3, 4, 5\n2nd day: 6, 7\n3rd day: 8\n4th day: 9\n5th day: 10Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.Example 2:Input: weights = [3,2,2,4,1,4], days = 3\nOutput: 6\nExplanation: A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n1st day: 3, 2\n2nd day: 2, 4\n3rd day: 1, 4Example 3:Input: weights = [1,2,3,1,1], days = 4\nOutput: 3\nExplanation:\n1st day: 1\n2nd day: 2\n3rd day: 3\n4th day: 1, 1Constraints:\n1 &lt;= days &lt;= weights.length &lt;= 5 * 104\n1 &lt;= weights[i] &lt;= 500 <br>\n이게 왜 binary search인가? <a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@soopsaram/Leetcode-1011.-Capacity-To-Ship-Packages-Within-D-Days\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@soopsaram/Leetcode-1011.-Capacity-To-Ship-Packages-Within-D-Days\" target=\"_self\">참고</a> binary search는 두 종류의 문제가 있다. 배열 인덱스로 binary search 하는 경우 -&gt; O(logn)\n어떤 결과 값을 Up &amp; Down 으로 맞추는 경우(주어진 배열을 이용해 계산) -&gt; O(nlogn) 최소 capacity에서 true가 나올때 까지 1개 씩 찾아 올라가면 선형탐색 가능한 최대 capacity에서 반씩 줄여가면서 찾으면 이진탐색 +) 이진 탐색 binary search 할때, l, r에 mid 값 할당해 줄 때 +1, -1을 어떻게 해줘야하는 지 명확하지 않음\n비슷하게 l,r 비교 부등호도 명확하지 않음. (디버거 돌려보면 서 함.)\n이진 탐색 공부해보기 +) 초기값 설정 오류 We have to adjust the low for the binary search depending on the maximum weight that is present in the input, for ex in the case 3, the max weight is 3, we cannot have capacity of two ever transport a weight of 3. class Solution { public int shipWithinDays(int[] weights, int days) { int sum = 0; int max = 0; for (int i=0; i&lt;weights.length; i++) { sum += weights[i]; if (max &lt; weights[i]) max = weights[i]; } int l = max; int r = sum; int mid = (l+r)/2; while (l &lt;= r) { mid = (l+r)/2; if (exceedingDDays(weights, days, mid)) { l = mid + 1; } else { r = mid - 1; } } return l; } public boolean exceedingDDays(int[] weights, int days, int capacity) { int sum = 0; for (int i=0; i&lt;weights.length; i++) { sum += weights[i]; if (sum &gt; capacity) { days -= 1; sum = weights[i]; } if (days &lt;= 0) return true; } return false; } }\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1011. Capacity To Ship Packages Within D Days","level":1,"id":"1011. Capacity To Ship Packages Within D Days"},{"heading":"문제","level":3,"id":"문제"},{"heading":"풀이","level":3,"id":"풀이"}],"links":["1.-study/coding-test/ps/ps.html","Search"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1011.-capacity-to-ship-packages-within-d-days.html","pathToRoot":"../../..","attachments":[],"createdTime":1718091347753,"modifiedTime":1718096887816,"sourceSize":3992,"sourcePath":"1. Study/Coding Test/PS/1011. Capacity To Ship Packages Within D Days.md","exportPath":"1.-study/coding-test/ps/1011.-capacity-to-ship-packages-within-d-days.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1012.-유기농-배추.html":{"title":"1012. 유기농 배추","icon":"","description":"NAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고&nbsp;배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에&nbsp;효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아&nbsp;먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어종성공 → dfs 추가import java.io.*; import java.util.*; public class Main { static int[][] field; static int[][] visited; static final int[] X = {0,0,-1,1}; static final int[] Y = {-1,1,0,0}; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; int M, N, K; int bug; int T = Integer.parseInt(br.readLine()); for (int t = 0; t &lt; T; t++) { // 밭 만들기 st = new StringTokenizer(br.readLine(), \" \"); M = Integer.parseInt(st.nextToken()); N = Integer.parseInt(st.nextToken()); K = Integer.parseInt(st.nextToken()); field = new int[M][N]; visited = new int[M][N]; // 밭 채우기 for (int k = 0; k &lt; K; k++) { st = new StringTokenizer(br.readLine(), \" \"); int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); field[x][y] = 1; } // 밭 탐색 bug = 0; for (int n = 0; n &lt; N; n++) { for (int m = 0; m &lt; M; m++) { if (field[m][n] == 1 &amp;&amp; visited[m][n] == 0) { //bfs(m, n); dfs(m, n); bug++; } visited[m][n] = 1; } } System.out.println(bug); } br.close(); } public static void dfs(int x, int y) { visited[x][y] = 1; int endX = field.length - 1; int endY = field[0].length - 1; for (int i = 0; i &lt; 4; i++) { int nx = x + X[i]; int ny = y + Y[i]; if (nx &gt; endX || ny &gt; endY || nx &lt; 0 || ny &lt; 0) continue; if (field[nx][ny] == 0 || visited[nx][ny] == 1) continue; visited[nx][ny] = 1; dfs(nx, ny); } } public static void bfs(int x, int y) { Queue&lt;List&lt;Integer&gt;&gt; que = new LinkedList&lt;&gt;(); que.offer(new ArrayList(Arrays.asList(x, y))); int endX = field.length - 1; int endY = field[0].length - 1; while (!que.isEmpty()) { List&lt;Integer&gt; nowNode = que.poll(); for (int i = 0; i &lt; 4; i++) { int nx = nowNode.get(0) + X[i]; int ny = nowNode.get(1) + Y[i]; if (nx &gt; endX || ny &gt; endY || nx &lt; 0 || ny &lt; 0) continue; if (field[nx][ny] == 0 || visited[nx][ny] == 1) continue; que.offer(new ArrayList(Arrays.asList(nx, ny))); visited[nx][ny] = 1; } } } }\n복사\n오히려 dfs가 더 간단한것 같기도?\n","aliases":[],"inlineTags":[],"frontmatterTags":["#실버/2"],"headers":[{"heading":"1012. 유기농 배추","level":1,"id":"1012. 유기농 배추"},{"heading":"문제","level":3,"id":"문제"},{"heading":"문제","level":4,"id":"문제"},{"heading":"입력","level":4,"id":"입력"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1012.-유기농-배추.html","pathToRoot":"../../..","attachments":[],"createdTime":1713097672602,"modifiedTime":1719470788760,"sourceSize":5406,"sourcePath":"1. Study/Coding Test/PS/1012. 유기농 배추.md","exportPath":"1.-study/coding-test/ps/1012.-유기농-배추.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1072.-게임.html":{"title":"1072. 게임","icon":"","description":"김형택은 지금 몰래 Spider Solitaire(스파이더 카드놀이)를 하고 있다. 형택이는 이 게임을 이길 때도 있었지만, 질 때도 있었다. 누군가의 시선이 느껴진 형택이는 게임을 중단하고 코딩을 하기 시작했다. 의심을 피했다고 생각한 형택이는 다시 게임을 켰다. 그 때 형택이는 잠시 코딩을 하는 사이에 자신의 게임 실력이 눈에 띄게 향상된 것을 알았다.\n이제 형택이는 앞으로의 모든 게임에서 지지 않는다. 하지만, 형택이는 게임 기록을 삭제 할 수 없기 때문에, 자신의 못하던 예전 기록이 현재 자신의 엄청난 실력을 증명하지 못한다고 생각했다.\n게임 기록은 다음과 같이 생겼다.\n게임 횟수 : X\n이긴 게임 : Y (Z%)\nZ는 형택이의 승률이고, 소수점은 버린다. 예를 들어, X=53, Y=47이라면, Z=88이다.\nX와 Y가 주어졌을 때, 형택이가 게임을 최소 몇 번 더 해야 Z가 변하는지 구하는 프로그램을 작성하시오.\n각 줄에 정수 X와 Y가 주어진다.첫째 줄에 형택이가 게임을 최소 몇 판 더 해야하는지 출력한다. 만약 Z가 절대 변하지 않는다면 -1을 출력한다.\n1 ≤ X ≤ 1,000,000,000\n0 ≤ Y ≤ X\n승률이 변하는 지점을 ‘찾는’ 문제 → 배열 탐색 중 <a data-href=\"이분탐색\" href=\"1.-study/coding-test/algorithm/이분탐색.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">이분탐색</a> 사용기본 문제처럼 굳이 실제 배열을 만들어서 인덱스로 접근하는 등의 방법을 사용하진 않아도 된다.\nhi lo mid 값을 추가 실행 횟수로 설정하여 승률 계산에 사용하는 방법으로 해결함.비교적 큰수를 다루는 문제이면서 나눗셈이 들어가는 문제이다 보니, 컴퓨터 시스템적 제약으로 인한 오류들이 많이 발생했음(overflow나 정밀도 손상과 같은 문제들)\n부동소수점 문제 나눈 값이 소수점 아래로 긴 값이라 저장 가능 범위를 넘어선다면, 소수점 데이터에 오차가 발생\n거기에 100을 곱한다면 오차가 더 커지게 됨.\n→ 100을 먼저 곱하고 나누어서 오차를 줄이는 방법을 사용 정수 오버플로우 위의 문제 해결을 위해 100을 먼저 곱하게 되면, int 형이 수용할 수 없는 값이 생성 될 수 있음.\nint 형이 저장할 수 있는 최댓값이 2,147,483,647인데, y 최댓값 1,000,000,000에 100을 곱하면 overflow가 발생\n→ 자료형을 long으로 변경: 메모리 많이 사용.\n→ double로 계산하고 int로 type casting // 수정 전\nint x = 100;\nint y = 80;\n// ...\nint now = (double) (y+i) / (x+i) * 100; // double로 계산하지 않으면 소숫점 아래는 다 잘려서 잘못된 값이 나옴 // 곱하기 연산을 먼저하는 것으로 수정\nint x = 100;\nint y = 80;\n// ...\nint now = (y+i) * 100 / (x+i) ; // 100을 먼저 곱하면 필요한 부분 만큼(0~100)은 제대로 계산되기 때문에 double로 계산하지 않아도 된다고 생각. // double 형으로 계산\nint x = 100;\nint y = 80;\n// ...\nint now = (int) ((double) (y+i)/(x+i) *100); // 곱하기 연산을 먼저하는 것으로 수정\ndouble x = 100.0;\ndouble y = 80.0;\n// ...\nint now =(int) ((y+i) * 100/(x+i)); 복사해당 주제에 대한 자세한 내용은 다음 링크 참고+)\n승률이 Z보다 작은 경우는 고려하지 않아도됨.\nimport java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] temp = br.readLine().split(\" \"); int X = Integer.parseInt(temp[0]); int Y = Integer.parseInt(temp[1]); int Z = (int) ((double) Y * 100 / X); if (Z == 100) { System.out.println(-1); return; } int lo = 0; int hi = 1000000000; int mid, now; while (lo&lt;hi) { mid = (lo+hi)/2; now = getWinRate(X, Y, mid); if (now == Z) { lo = mid + 1; continue; } if (now &gt; Z) { hi = mid; } } if (getWinRate(X, Y, hi) == Z) System.out.println(-1); else System.out.println(hi); } private static int getWinRate(int x, int y, int i) { return (int) ((double) (y+i) * 100/(x+i)); } }\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1072. 게임","level":1,"id":"1072. 게임"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"제한","level":3,"id":"제한"},{"heading":"입출력","level":3,"id":"입출력"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"정답","level":2,"id":"정답"}],"links":["1.-study/coding-test/algorithm/이분탐색.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1072.-게임.html","pathToRoot":"../../..","attachments":[],"createdTime":1730155421558,"modifiedTime":1730194883194,"sourceSize":5222,"sourcePath":"1. Study/Coding Test/PS/1072. 게임.md","exportPath":"1.-study/coding-test/ps/1072.-게임.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1074.-z.html":{"title":"1074. Z","icon":"","description":"한수는 크기가 2N&nbsp;× 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.<img alt=\"\" src=\"https://u.acmicpc.net/21c73b56-5a91-43aa-b71f-9b74925c0adc/Screen%20Shot%202020-12-02%20at%208.09.46%20AM.png\" referrerpolicy=\"no-referrer\" style=\"width: 150px; max-width: 100%;\" target=\"_self\" class=\"is-unresolved\">N &gt; 1인 경우, 배열을 크기가 2N-1&nbsp;× 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.다음 예는 22&nbsp;× 22&nbsp;크기의 배열을 방문한 순서이다.<br><img alt=\"\" src=\"https://u.acmicpc.net/adc7cfae-e84d-4d5c-af8e-ee011f8fff8f/Screen%20Shot%202020-12-02%20at%208.11.17%20AM.png\" referrerpolicy=\"no-referrer\" style=\"width: 280px; max-width: 100%;\" target=\"_self\" class=\"is-unresolved\">N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.다음은 N=3일 때의 예이다.<br><img alt=\"\" src=\"https://u.acmicpc.net/d3e84bb7-9424-4764-ad3a-811e7fcbd53f/Screen%20Shot%202020-12-30%20at%2010.50.47%20PM.png\" referrerpolicy=\"no-referrer\" style=\"width: 340px; max-width: 100%;\" target=\"_self\" class=\"is-unresolved\">첫째 줄에 정수 N, r, c가 주어진다.r행 c열을 몇 번째로 방문했는지 출력한다.\n1 ≤ N ≤ 15\n0 ≤ r, c &lt; 2N\n2 3 1113 7 7631 0 004 7 76310 511 51126214310 512 512786432\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>잘못된 조건을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/hmw9309\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/hmw9309\" target=\"_self\">hmw9309</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1074. Z","level":1,"id":"1074. Z"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"제한","level":2,"id":"제한"},{"heading":"예제 입력 1 복사","level":2,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":2,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":2,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":2,"id":"예제_출력_2 복사"},{"heading":"예제 입력 3 복사","level":2,"id":"예제_입력_3 복사"},{"heading":"예제 출력 3 복사","level":2,"id":"예제_출력_3 복사"},{"heading":"예제 입력 4 복사","level":2,"id":"예제_입력_4 복사"},{"heading":"예제 출력 4 복사","level":2,"id":"예제_출력_4 복사"},{"heading":"예제 입력 5 복사","level":2,"id":"예제_입력_5 복사"},{"heading":"예제 출력 5 복사","level":2,"id":"예제_출력_5 복사"},{"heading":"예제 입력 6 복사","level":2,"id":"예제_입력_6 복사"},{"heading":"예제 출력 6 복사","level":2,"id":"예제_출력_6 복사"},{"heading":"출처","level":2,"id":"출처"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1074.-z.html","pathToRoot":"../../..","attachments":[],"createdTime":1729150187223,"modifiedTime":1729745129072,"sourceSize":2000,"sourcePath":"1. Study/Coding Test/PS/1074. Z.md","exportPath":"1.-study/coding-test/ps/1074.-z.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1107.-리모컨.html":{"title":"1107. 리모컨","icon":"","description":"NAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>수빈이는 TV를 보고 있다. 수빈이는 채널을 돌리려고 했지만, 버튼을 너무 세게 누르는 바람에, 일부 숫자 버튼이 고장났다.리모컨에는 버튼이 0부터 9까지 숫자, +와 -가 있다. +를 누르면 현재 보고있는 채널에서 +1된 채널로 이동하고, -를 누르면 -1된 채널로 이동한다. 채널 0에서 -를 누른 경우에는 채널이 변하지 않고, 채널은 무한대 만큼 있다.수빈이가 지금 이동하려고 하는 채널은 N이다. 어떤 버튼이 고장났는지 주어졌을 때, 채널 N으로 이동하기 위해서 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오.수빈이가 지금 보고 있는 채널은 100번이다.첫째 줄에 수빈이가 이동하려고 하는 채널 N (0 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 고장난 버튼의 개수 M (0 ≤ M ≤ 10)이 주어진다. 고장난 버튼이 있는 경우에는 셋째 줄에는 고장난 버튼이 주어지며, 같은 버튼이 여러 번 주어지는 경우는 없다.첫째 줄에 채널 N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지를 출력한다.5457\n3\n6 7 86100\n5\n0 1 2 3 40500000\n8\n0 2 3 4 6 7 8 911117100\n3\n1 0 5014124\n051\n9\n1 2 3 4 5 6 7 8 9280000\n2\n8 92228예제 1의 경우 5455++ 또는 5459--\n가장 가까운 곳은 어떻게 고를 것인가? 100에서 +-누르는 수.\n못누르는 버튼 찾기\n위로 가장 가까운것 찾기\n아래로 가자 가까운 것 찾기\n비교\n최솟감 출력 방법 일단 그냥 반복 5676인데\n78가 고장남\n5 → +1\n6 → +1\n7 → 불가능! up: 9\ndown: 6 6 → 앞의 영향을 받음 up인경우: 0\ndown인경우: 9 5676인데\n789가 고장남\n‘’\n‘’\n7 up → 0 → 2번을 7로…?안됨 8로…? 안됨 9로 안됨… 0으로… → 1을 6으로\ndown → ‘’ 6 up → 0\ndown: 9 4321인데\n012가 고장남\n4\n3\n2 up: 3\ndown: 1 안됨 → 0 안됨 → 9 :: 2번 2안됨 → 1 안됨 → … 9 :: 1번 3으로… 1 up: 0\ndown: 9 4421인데\n012가 고장남\n4\n3\n2 up: 3\ndown: 1 안됨 → 0 안됨 → 9 :: 2번 3 1 up: 0\ndown: 9 이거 너무 복잡함\n일단 안전지대를 찾자\n+1 되어서 1이 올라가는 경우되는 경우\n-1 되어서 0이 되어 9로 내려가는 경우\n이 두경우를 표시해두는 거지 flag = “UUDDN” → 위험한 경우 일단 result를 위해 필요한 data 자릿수 + 차이 그냥 아래에서 부터 올라가도 될것같아. 마지막에 그냥 숫자만 바꿔주면 되니까.\n그러려면 change point를 아는게 중요하겠네. import sys def remote_control(): channel = int(sys.stdin.readline().rstrip()) trialList = [abs(channel-100), 0,0] trialList[1] = list(map(int,str(channel))) trialList[2] = trialList[1][:] brokenNum = int(sys.stdin.readline().rstrip()) if brokenNum == 0: print(len(str(channel))) exit() brokenBtns = list(map(int,sys.stdin.readline().split(\" \"))) availableBtns = \"\" for btn in range(10): if btn not in brokenBtns: availableBtns += str(btn) trialList[1] = to_upper_ch(trialList[1], availableBtns) trialList[2] = to_lower_ch(trialList[2], availableBtns) trialList[1] = abs(trialList[1] - channel) + len(str(trialList[1])) trialList[2] = abs(trialList[2] - channel) + len(str(trialList[2])) # T: 정상 / F: 고장 / U: 올림 가능한 경우(가장 가까운 괜찮은 버튼 +1) / D: 내림 가능한 경우 (가장 가까운 괜찮은 버튼 -1)print(trialList) print(min(trialList)) def to_upper_ch(upChannel, availableBtns): idx = len(upChannel) - 1 result = 0 setMinIdx = -1 while idx &gt;= 0: if str(upChannel[idx] % 10) not in availableBtns: # 누를 수 있는 버튼 이 아닌 경우 1씩 올려준다. upChannel[idx] += 1 else: if upChannel[idx] &gt;= 10: # 자릿수 침범한 경우를 따져야함. upChannel[idx] %= 10 # 일의 자릿수만 남기기 setMinIdx = idx # 이 인덱스 아랫자리부터는 최소 숫자로 변경 (자릿수 올림된 수기 때문에 아래를 최대한 작은 수로 맞춰는 것.) if idx == 0: # 1 올려주기 upChannel = [1] + upChannel else: upChannel[idx - 1] = 1 idx -= 1 if setMinIdx != -1: set_min(upChannel, setMinIdx, int(availableBtns[0])) # 이 아래로는 가장 작은 숫자로 맞춤 for n in upChannel: # 숫자로 합치기 result = result * 10 + n return result def to_lower_ch(downChannel, availableBtns): idx = len(downChannel) - 1 result = 0 setMaxIdx = -1 while idx &gt;= 0: if str(downChannel[idx] % 10) not in availableBtns: # 누를 수 있는 버튼 이 아닌 경우 1씩 빼준다. downChannel[idx] -= 1 else: if downChannel[idx] &lt; 0: # 자릿수 침범한 경우를 따져야함. downChannel[idx] %= 10 # 일의 자릿수만 남기기 setMaxIdx = idx # 이 인덱스 아랫자리부터는 최소 숫자로 변경 (자릿수 올림된 수기 때문에 아래를 최대한 작은 수로 맞춰는 것.) if idx == len(downChannel) - 1: # 1 올려주기 downChannel = downChannel[1:] else: downChannel[idx - 1] -= 1 idx -= 1 set_min(downChannel, setMaxIdx, int(availableBtns[-1])) # 이 아래로는 가장 작은 숫자로 맞춤 for n in downChannel: # 숫자로 합치기 result = result * 10 + n return result def set_min(target, idx, num): for i in range(idx+1, len(target)): target[i] = num def set_max(target, idx, num): for i in range(idx+1, len(target)): target[i] = num if __name__ == \"__main__\": remote_control()\n복사\n자릿수를 따질 때는 각자리수 list로 다루는 게 편할듯. 모든 숫자 버튼이 고장난 경우 ✅ 2024-04-04\n고장난 버튼이 없는 경우 ✅ 2024-04-04 위에 둘다 버튼num 받아서 그게 10일때, 0일때 처 0보다 작은 채널로 계산 할 경우 ✅ 2024-04-04 계산 다하고 음수면 빼기 다시 반례 ✅ 2024-04-04\nin: 0 / 2 / 0 1\n답: 3\n실: 1\n문제점: 음수가 나오면 제외하고 최솟값 계산하기로 했는데 로직상 음수가 나올 수 없음 음수가 나오면, 그 자리 빼기 해줌.. 해결: 음수가 나올수 있게 → 내림받을 숫자가 더이상 없으면 그 자릿수를 그냥 삭제해버리는데, len이 1이면 -1로 유지하도록 만듬 내림 부분에 수정안한 오류 ✅ 2024-04-04 4321/3/012 에서 down side에 오류남 -1이 나올 수가 없는데\nidx가 가장 위의 자리를 가리킬 때를 따져야하는데, 1의 자리를 가리킬 때로, 오류를 수정하지 않음. 수정오류: 자리수 침범이 있을 때, 해당 수를 mod를 통해 제대로된 수로 바꾸어 주어야하는데 그 구문을 빼놓 ✅ 2024-04-04 위랑 같은 반례 반례 1555/8/0 1 3 4 5 6 7 9 ✅ 2024-04-04 setmin에 문제가 있어보임. → 숫자버튼으로 ㅣㅇ동한 경우가 2888 임. 2222여야하는데\nsetmin, setmax idx 설정 위치 오류\n하나라도 숫자가 변하면 아래는 바꿔줘야하고\n위에는 지릿구 문제가 생기면 바꿔줘야함\n두개를 구분을 못함.\n또문제 답은 670인데 실제는 671이 나옴… 1은 어디서 나온거야? ✅ 2024-04-04 1555 up 5→8 → 2\n5→8 → 2\n5→8 → 2\n1→2 * down 5→2→8\n5→2→8\n5→2→8\n1→x * 문제 → 자릿수 침범이 일어나면 위에 자릿수도 바뀌기 때문에 set min max idx를 침범을 받은 곳 까지 올려줘야함. 또문제 바꾸었더니 자릿수 에 문제가 생긴듯. (9/5/9 8 7 6 5 → up의 경우 10이 아니라 0이 나옴) ✅ 2024-04-09 또다시 2%로 돌아감 찾은 반례: 199/1/9 → 4인데 14가 나옴.\nup의 겨우에 200이 나와야하는데, 110이 나옴? ✅ 2024-04-09 아 위에 자리수에 +1 해줘야하는데 1로만 만들어버림..! +=오타남… 99933/2/3 9 → 73인데 11050이 나옴. up이 200000이 나와버림..! 100000이 나와야하는데\n자리수 침해 해결하고 나서 1을 자리수만 남길 때 list 의 전체 idx가 변경된 경우에 문제가 생김… Stream은 나온지 얼마 안 된 기능이기 때문에, 내부 최적화가 기존에 비해 부족하다.\n많은 element에 대해 접근이 많은 상황에선 array나 collection가 좋다.\ncollection의 경우 간접적으로 접근하기 때문에, stream보다 빠르긴 해도 array만큼 빠르진 않다.\n한 element에 대해 많은 연산이 필요한 경우 stream이 유리하다.\nimport java.io.*; import java.util.*; public class Main { public static void main(String[] args) throws IOException { // 입력받기 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int channel = Integer.parseInt(br.readLine()); int chLen = (int) (Math.log10(channel) + 1); int M = Integer.parseInt(br.readLine()); // case1: only press plus minus btn int noNumBtn = press_up_and_down(100, channel); /* 극단값 우선 처리 if # of broken = 10; have no choice but to press plus minus btn */ if (M == 10) { System.out.println(noNumBtn); return; } if (M == 0) { System.out.println(Math.min(noNumBtn, chLen)); return; } // 입력 데이터 추가 처리 /// broken List&lt;Integer&gt; broken = new ArrayList&lt;&gt;(); for (String s: br.readLine().split(\" \")) { broken.add(Integer.parseInt(s)); } // case2: 목표 채널보다 위로 가서 -버튼 사용 // case3: 목표 채널 보다 아래로 가서 +버튼 사용 int up = go_to_upperbound(channel, broken); int down = go_to_lowerbound(channel, broken); int numBtn = Math.min(up,down); // 최솟값 출력 System.out.println(Math.min(noNumBtn, numBtn)); } public static int press_up_and_down(int target, int now) { return (now&gt;target? now-target: target-now); } public static int go_to_upperbound(int ch, List&lt;Integer&gt; broken) { int target = ch; int chLen = (int) Math.log10(ch) + 1; int newCh = 0; int btn; for (int i=1; i&lt;=Math.pow(10,chLen-1) ; i*=10) { btn = target % 10; target /= 10; for (int j=0; j&lt;10; j++) { if (!broken.contains(btn)){ newCh += (btn * i); break; } if (j==9) { return ch+100; //noBtn 보다 항상 큰수 } btn++; } } int newChLen = (int) Math.log10(newCh) + 1; return newChLen + press_up_and_down(ch, newCh); } public static int go_to_lowerbound(int ch, List&lt;Integer&gt; broken) { int target = ch; int chLen = (int) Math.log10(ch) + 1; int newCh = ch; int btn; for (int i=1; i&lt;=Math.pow(10,chLen-1); i*=10) { btn = target % (i*10); for (int j=0; j&lt;10; j++) { if (!broken.contains(btn)){ newCh += (btn * i); break; } btn--; if (j==9) { return ch+100; //noBtn 보다 항상 큰수 } if (btn == -1) { btn = 9; target -= 10*i; } } } int numBtn = (int) Math.log10(newCh) + 1; int c = press_up_and_down(ch, newCh); return numBtn + press_up_and_down(ch, newCh); } }\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1107. 리모컨","level":1,"id":"1107. 리모컨"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1 복사","level":2,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":2,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":2,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":2,"id":"예제_출력_2 복사"},{"heading":"예제 입력 3 복사","level":2,"id":"예제_입력_3 복사"},{"heading":"예제 출력 3 복사","level":2,"id":"예제_출력_3 복사"},{"heading":"예제 입력 4 복사","level":2,"id":"예제_입력_4 복사"},{"heading":"예제 출력 4 복사","level":2,"id":"예제_출력_4 복사"},{"heading":"예제 입력 5 복사","level":2,"id":"예제_입력_5 복사"},{"heading":"예제 출력 5 복사","level":2,"id":"예제_출력_5 복사"},{"heading":"예제 입력 6 복사","level":2,"id":"예제_입력_6 복사"},{"heading":"예제 출력 6 복사","level":2,"id":"예제_출력_6 복사"},{"heading":"예제 입력 7 복사","level":2,"id":"예제_입력_7 복사"},{"heading":"예제 출력 7 복사","level":2,"id":"예제_출력_7 복사"},{"heading":"힌트","level":2,"id":"힌트"},{"heading":"풀이","level":1,"id":"풀이"},{"heading":"idea","level":3,"id":"idea"},{"heading":"if 1)","level":3,"id":"if_1)"},{"heading":"if 2)","level":3,"id":"if_2)"},{"heading":"if 3)","level":3,"id":"if_3)"},{"heading":"if 3)","level":3,"id":"if_3)"},{"heading":"다른 방법","level":3,"id":"다른_방법"},{"heading":"refresh","level":3,"id":"refresh"},{"heading":"제출1 → 시간초과","level":3,"id":"제출1_→_시간초과"},{"heading":"제한조건들 체크","level":4,"id":"제한조건들_체크"},{"heading":"자바로 다시 풀기","level":3,"id":"자바로_다시_풀기"},{"heading":"Stream(java stream이 for-loop보다 느린 이유)","level":4,"id":"Stream([java_stream이_for-loop보다_느린_이유](https//brorica.tistory.com/110))"},{"heading":"일단 여기까지 함 keep (예제 6번부터 안됨)","level":4,"id":"일단_여기까지_함_keep_(예제_6번부터_안됨)"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1107.-리모컨.html","pathToRoot":"../../..","attachments":[],"createdTime":1712043893584,"modifiedTime":1720419832044,"sourceSize":13494,"sourcePath":"1. Study/Coding Test/PS/1107. 리모컨.md","exportPath":"1.-study/coding-test/ps/1107.-리모컨.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1157.-단어-공부.html":{"title":"1157. 단어 공부","icon":"","description":"NAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.Mississipi?zZaZzZbaaaA\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/author5\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/author5\" target=\"_self\">author5</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jejeje8\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jejeje8\" target=\"_self\">jejeje8</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/kimhs\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/kimhs\" target=\"_self\">kimhs</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/rnjs4197\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/rnjs4197\" target=\"_self\">rnjs4197</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/102\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/102\" target=\"_self\">구현</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/158\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/158\" target=\"_self\">문자열</a> <br>굳이 BufferedReader를 쓸 필요가 없음… <a data-href=\"BufferedReader\" href=\"1.-study/coding-test/ps/bufferedreader.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">BufferedReader</a>\n//생략 public void Solution2_noBuffer() throws IOException { int[] cntList = new int[65+26]; byte[] inputByteList = new byte[8192]; int max=0; int same=0; InputStream is = System.in; is.read(inputByteList); for (int i=0; i&lt;inputByteList.length; i++) { byte b = inputByteList[i]; System.out.println(b); cntList[b] += 1; } for (int i=65; i&lt;cntList.length; i++) { if(cntList[i] &gt; max) { max = i; same = 0; } else if (cntList[i] == max) { same = 1; } } if (same == 0) { System.out.println(max); }else { System.out.println(\"?\"); } } public static void main(String[] args) throws IOException { new Main().Solution2_noBuffer(); } }\n복사 byte로 받는 걸로 바꾸다가 생긴 문제점… upper case로만 치는 거 어떻게 할건데? <br>다른 사람 풀이의 &amp;31이 그 방법인가 싶은데… <a data-tooltip-position=\"top\" aria-label=\"https://gimkuku0708.tistory.com/19\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://gimkuku0708.tistory.com/19\" target=\"_self\">(C++) 2018 KAKAO BLIND RECRUITMENT[1차] : 뉴스 클러스터링</a> → 3. 알파벳들을 모두 대소문자를 구분없는 숫자로 바꾼다 =&gt; 아스키연산 &amp;31 부분.\nA:65 = 0010 0001\na:97= 0110 0001\n&amp;31 = 0001 1111 = 1+2+4+8+16 = 31 차이가 있는 32bit 자리는 0으로\n쓸데없이 값을 크게하는 64bit자리도으로\n나며지는 1이면 1, 0이면 0으로 출력.\n즉 → 아래 5bit만 살려주겠다! &amp;32 = 0100 0000 → 대소문자 바꾸기. 32bit자리를 크고 꺼주기… 아 이건 AND가 아니라 XOR로 해서 대소문자 바꾸기로 써줄 수 있음.\n주어진 32bit 자리가 1이면 11이라 0 / 0이면 01이라 1 그리고 byte list의 capacity말고, size를 반환하는 방법도 문제. primitive type의 경우에는 length변수만 사용가능한데 이건 capacity를 반환.\n처음에는 while문으로 buffer의 값이 0보다 크면, 으로 했는데 잘 작동 안함\nfor (int i=0;buf[i]&gt;64;i++) 와 같은 방법으로 해결 출력할때는 |64로 대문자로 만들어주기. :런타임 에러&nbsp;(ArrayIndexOutOfBounds)\ninput byte개수가 최대 1000000라는 걸 간과\n:틀","aliases":[],"inlineTags":[],"frontmatterTags":["#java","#브론즈/1"],"headers":[{"heading":"1157. 단어 공부","level":1,"id":"1157. 단어 공부"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":3,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":3,"id":"예제_출력_2 복사"},{"heading":"예제 입력 3 복사","level":3,"id":"예제_입력_3 복사"},{"heading":"예제 출력 3 복사","level":3,"id":"예제_출력_3 복사"},{"heading":"예제 입력 4 복사","level":3,"id":"예제_입력_4 복사"},{"heading":"예제 출력 4 복사","level":3,"id":"예제_출력_4 복사"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"1차 성공공","level":3,"id":"1차_성공공"},{"heading":"2차 실패","level":3,"id":"2차_실패"},{"heading":"3차 실패","level":3,"id":"3차_실패"}],"links":["1.-study/coding-test/ps/ps.html","1.-study/coding-test/ps/bufferedreader.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1157.-단어-공부.html","pathToRoot":"../../..","attachments":[],"createdTime":1715663233721,"modifiedTime":1716651412093,"sourceSize":4267,"sourcePath":"1. Study/Coding Test/PS/1157. 단어 공부.md","exportPath":"1.-study/coding-test/ps/1157.-단어-공부.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1249.-보급로.html":{"title":"1249. 보급로","icon":"","description":"2차 세계 대전에서 연합군과 독일군의 전투가 점점 치열해지고 있다. 전투가 진행중인 지역은 대규모 폭격과 시가전 등으로 인해 도로 곳곳이 파손된 상태이다. 그림 1(a)에서와 같이 도로들은 전투로 인해 트럭이나 탱크와 같은 차량들이 지날 갈 수 없다. 전투에서 승리하기 위해서는 기갑사단과 보급부대가 신속하게 이동하기 위한 도로가 있어야 한다. 공병대는 출발지(S) 에서 도착지(G)까지 가기 위한 도로 복구 작업을 빠른 시간 내에 수행하려고 한다. 도로가 파여진 깊이에 비례해서 복구 시간은 증가한다. 출발지에서 도착지까지 가는 경로 중에 복구 시간이 가장 짧은 경로에 대한 총 복구 시간을 구하시오. 깊이가 1이라면 복구에 드는 시간이 1이라고 가정한다. &nbsp;<img src=\"https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&amp;fileId=AV2XdCCqDhkBBASl\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"> 그림 1 (a) 파손된 도로&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;(b) 지도 형태와 이동 방향지도 정보는 그림1(b)와 같이 2차원 배열 형태로 표시된다. 출발지는 좌상단의 칸(S)이고 도착지는 우하단의 칸(G)가 된다. 이동 경로는 상하좌우 방향으로 진행할 수 있으며, 한 칸씩 움직일 수 있다. 지도 정보에는 각 칸마다 파여진 도로의 깊이가 주어진다. 현재 위치한 칸의 도로를 복구해야만 다른 곳으로 이동할 수 있다. &nbsp;<br><img src=\"https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&amp;fileId=AV2XdHuaDhoBBASl\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">그림 2 지도 정보이동하는 시간에 비해 복구하는데 필요한 시간은 매우 크다고 가정한다. 따라서, 출발지에서 도착지까지 거리에 대해서는 고려할 필요가 없다. 지도 정보는 그림2에서 보듯이 2차원 배열의 형태이다. 출발지(S)와 도착지(G)는 좌상단과 우하단이 되고 입력 데이터에서는 0으로 표시된다. 출발지와 도착지를 제외한 곳이 0인 것은 복구 작업이 불필요한 곳이다. 다음과 같은 지도에서 복구 작업 시간이 최소인 시간은 2이고 회색으로 칠해진 경로가 된다. &nbsp;<br><img src=\"https://swexpertacademy.com/main/common/fileDownload.do?downloadType=CKEditorImages&amp;fileId=AV2Xe9hKDikBBASl\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">[입력] 가장 첫 줄은 전체 테스트케이스의 수이다. 각 테스트 케이스마다 지도의 크기(N x N)가 주어진다. 지도의 크기는 최대 100 x 100이다. 그 다음줄 부터 지도의 크기만큼 2차원 배열 형태의 지도 정보가 주어진다. &nbsp;\n[출력] 각 테스트 케이스의 답을 순서대로&nbsp;출력하며, 각 케이스마다 줄의 시작에 “#C”를 출력하여야 한다. 이때 C는 케이스의 번호이다. 같은 줄에 빈 칸을 하나 두고, 주어진 입력에서 출발지에서 도착지까지 가는 경로 중에 복구 작업에 드는 시간이 가장 작은 경로의 복구 시간을 출력하시오.입력\n10\n4\n0100\n1110\n1011\n1010\n6\n011001\n010100\n010011\n101001\n010101\n111010\n8\n. . .출력\n#1 2\n#2 2\n. . .","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1249. 보급로","level":1,"id":"1249. 보급로"},{"heading":"문제","level":3,"id":"문제"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1249.-보급로.html","pathToRoot":"../../..","attachments":[],"createdTime":1729743804958,"modifiedTime":1729745060659,"sourceSize":3842,"sourcePath":"1. Study/Coding Test/PS/1249. 보급로.md","exportPath":"1.-study/coding-test/ps/1249.-보급로.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1260.-dfs와-bfs.html":{"title":"1260. DFS와 BFS","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-27<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1260\" target=\"_self\">https://www.acmicpc.net/problem/1260</a>Level: s2Category: <br><a data-href=\"BFS, DFS\" href=\"1.-study/coding-test/algorithm/graph/bfs,-dfs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">BFS, DFS</a>Success: ⭕Git: -그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다.&nbsp;정점 번호는 1번부터 N번까지이다.첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.4 5 1\n1 2\n1 3\n1 4\n2 4\n3 41 2 4 3\n1 2 3 45 5 3\n5 4\n5 2\n1 2\n3 4\n3 13 1 2 5 4\n3 1 4 2 51000 1 1000\n999 10001000 999\n1000 999\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/author5\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/author5\" target=\"_self\">author5</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/dfghcvb11\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/dfghcvb11\" target=\"_self\">dfghcvb11</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/doju\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/doju\" target=\"_self\">doju</a>\n<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/doju\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/doju\" target=\"_self\">doju</a>\n<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/pumpyboom\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/pumpyboom\" target=\"_self\">pumpyboom</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/7\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/7\" target=\"_self\">그래프 이론</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/11\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/11\" target=\"_self\">그래프 탐색</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/126\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/126\" target=\"_self\">너비 우선 탐색</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/127\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/127\" target=\"_self\">깊이 우선 탐색</a> visited 초기화 과정이 필요..! → 그냥 2개 만들 → 아니다… flag num을 그냥 parameter로 보내주자.\nimport java.util.*; import java.io.*; public class Main { static int[][] gp; static int[] visited; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); // # of node int M = Integer.parseInt(st.nextToken()); // # of line int V = Integer.parseInt(st.nextToken()); // start node // create graph gp = new int[N+1][N+1]; visited = new int[N+1]; // fill graph for (int m=0; m&lt;M; m++) { st = new StringTokenizer(br.readLine()); int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); gp[x][y] = 1; gp[y][x] = 1; } visited[V] = 1; System.out.println(dfs(V, 1)); visited[V] = 2; System.out.println(bfs(V, 2)); br.close(); } public static String dfs(int now, int flag){ String result = now + \"\"; for (int i=0; i&lt;gp.length; i++) { if (gp[now][i] == 1 &amp;&amp; visited[i] != flag) { visited[i] = flag; result += (\" \" + dfs(i, flag)); } } return result; } public static String bfs(int start, int flag){ Queue&lt;Integer&gt; que = new LinkedList&lt;Integer&gt;(); que.offer(start); String result=\"\"; while (!que.isEmpty()){ int now = que.poll(); result += now + \" \"; for (int i=0; i&lt;gp.length; i++){ if (gp[now][i] == 1 &amp;&amp; visited[i] != flag) { visited[i] = flag; que.offer(i); } } } return result; } }\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1260. DFS와 BFS","level":1,"id":"1260. DFS와 BFS"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":3,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":3,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":3,"id":"예제_출력_2 복사"},{"heading":"예제 입력 3 복사","level":3,"id":"예제_입력_3 복사"},{"heading":"예제 출력 3 복사","level":3,"id":"예제_출력_3 복사"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"}],"links":["1.-study/coding-test/ps/ps.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1260.-dfs와-bfs.html","pathToRoot":"../../..","attachments":[],"createdTime":1719479659408,"modifiedTime":1719483928777,"sourceSize":4661,"sourcePath":"1. Study/Coding Test/PS/1260. DFS와 BFS.md","exportPath":"1.-study/coding-test/ps/1260.-dfs와-bfs.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1302.-deepest-leaves-sum.html":{"title":"1302. Deepest Leaves Sum","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-01<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/deepest-leaves-sum/\" target=\"_self\">https://leetcode.com/problems/deepest-leaves-sum/</a>Level: Medium<br>Category: <a data-href=\"BFS, DFS\" href=\"1.-study/coding-test/algorithm/graph/bfs,-dfs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">BFS, DFS</a>Success: -Git: -Given the&nbsp;root&nbsp;of a binary tree, return&nbsp;the sum of values of its deepest leaves.Example 1:<br><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png\" referrerpolicy=\"no-referrer\" style=\"width: 213px; max-width: 100%;\" target=\"_self\" class=\"is-unresolved\">Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\nOutput: 15Example 2:Input: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\nOutput: 19Constraints:\nThe number of nodes in the tree is in the range&nbsp;[1, 104].\n1 &lt;= Node.val &lt;= 100\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1302. Deepest Leaves Sum","level":1,"id":"1302. Deepest Leaves Sum"},{"heading":"문제","level":3,"id":"문제"}],"links":["1.-study/coding-test/ps/ps.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1302.-deepest-leaves-sum.html","pathToRoot":"../../..","attachments":[],"createdTime":1717242562233,"modifiedTime":1717242720230,"sourceSize":861,"sourcePath":"1. Study/Coding Test/PS/1302. Deepest Leaves Sum.md","exportPath":"1.-study/coding-test/ps/1302.-deepest-leaves-sum.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1309.동물원.html":{"title":"1309.동물원","icon":"","description":"NAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.<br><img alt=\"\" src=\"https://www.acmicpc.net/upload/201004/dnfl.JPG\" referrerpolicy=\"no-referrer\" style=\"width: 164px; max-width: 100%;\" target=\"_self\" class=\"is-unresolved\">이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.441\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/joon8409\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/joon8409\" target=\"_self\">joon8409</a>\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/xhark\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/xhark\" target=\"_self\">xhark</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/25\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/25\" target=\"_self\">다이나믹 프로그래밍</a> brute-force로..는 안될 것같음.\n다이나믹\n와씨 사자를 몇마리 이상 배치해야한다는 말이 없음…\n추가되는 경우의 수 → x/오/왼\\3 → xrl2 → xr2 → xl=&gt; x → 3 / r → 2 / l → 2 (원래 111)\ndp 사용시, 처음에 입력값들을 예외처리로 미리 빼주는 거 잊지 말기.\n아악 나누기 안해줌.\n","aliases":[],"inlineTags":[],"frontmatterTags":["#java","#실버/1"],"headers":[{"heading":"1309.동물원","level":1,"id":"1309.동물원"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1 복사","level":2,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":2,"id":"예제_출력_1 복사"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"","level":3,"id":""},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"1차 실패","level":3,"id":"1차_실패"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1309.동물원.html","pathToRoot":"../../..","attachments":[],"createdTime":1715734399261,"modifiedTime":1716651413330,"sourceSize":2329,"sourcePath":"1. Study/Coding Test/PS/1309.동물원.md","exportPath":"1.-study/coding-test/ps/1309.동물원.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1406.-에디터.html":{"title":"1406. 에디터","icon":"","description":"\nlinkedList로도 풀어보기. ✅ 2024-07-03 NAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-07-03<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://acmicpc.net/problem/1406\" target=\"_self\">https://acmicpc.net/problem/1406</a>Level: s2Category: StackLinkedListSuccess: ⭕한 줄로 된 간단한 에디터를 구현하려고 한다. 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 최대 600,000글자까지 입력할 수 있다.이 편집기에는 '커서'라는 것이 있는데, 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 문장의 맨 뒤(마지막 문자의 오른쪽), 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다.이 편집기가 지원하는 명령어는 다음과 같다.초기에 편집기에 입력되어 있는 문자열이 주어지고, 그 이후 입력한 명령어가 차례로 주어졌을 때, 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 구하는 프로그램을 작성하시오. 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 위치하고 있다고 한다.첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M&nbsp;≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.abcd\n3\nP x\nL\nP yabcdyxabc\n9\nL\nL\nL\nL\nL\nP x\nL\nB\nP yyxabcdmih\n11\nB\nB\nP x\nL\nB\nB\nB\nP y\nD\nD\nP zyxz<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/2\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/2\" target=\"_self\">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/25\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/25\" target=\"_self\">Croatian Highschool Competitions in Informatics</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/51\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/51\" target=\"_self\">2004</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/294\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/294\" target=\"_self\">National Competition #1 - Juniors</a>&nbsp;2번\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/author5\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/author5\" target=\"_self\">author5</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>\n<br>메모리 제한을 수정한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>\n<br>시간 제한을 수정한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a>\n<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/naong606\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/naong606\" target=\"_self\">naong606</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/wkd48632\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/wkd48632\" target=\"_self\">wkd48632</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/175\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/175\" target=\"_self\">자료 구조</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/71\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/71\" target=\"_self\">스택</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/154\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/154\" target=\"_self\">연결 리스트</a> Java 8: 2 초\nJava 8 (OpenJDK): 2 초\nKotlin (JVM): 2 초\nC# 6.0 (Mono): 2 초\nC# 3.0 (Mono): 2 초\nVB.NET 2.0 (Mono): 2 초\nVB.NET 4.0 (Mono): 2 초 시간 제한 때문에 Linked list를 사용하는 게 용이 → 삽입, 삭제에 시간이 덜 듬. 조회의 경우 node를 타고 가야 하기에 시간이 걸림.\n삽입 삭제시 앞뒤로 움직이는 것, → linked\n삽입 삭제 시 뒤에 요소들을 이동시키는 것 → array +) LinkedList는 초기값 설정안\nimport java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); List&lt;String&gt; text = new LinkedList&lt;&gt;(Arrays.asList(br.readLine().split(\"\"))); int end = text.size(); int start = 0; int cursor = end; int M = Integer.parseInt(br.readLine()); for (int m=0; m&lt;M; m++) { String inst = br.readLine(); if (inst.startsWith(\"L\") &amp;&amp; cursor != start) { cursor -= 1; continue; } if (inst.startsWith(\"D\") &amp;&amp; cursor != end) { cursor += 1; continue; } if (inst.startsWith(\"B\") &amp;&amp; cursor != start) { text.remove(cursor-1); cursor -= 1; end -= 1; continue; } if (inst.startsWith(\"P\")) { text.add(cursor, inst.substring(2)); cursor += 1; end += 1; } } System.out.println(String.join(\"\",text)); } }\n복사\n매번 움직이고 추가하는게 아니라, 다 정리해두고 마지막에 차례대로 접근해서 처리해버리는 거 어때? → map 사용\njava map iteration\n// 방법1\nIterator&lt;String&gt; keys = map.keySet().iterator(); while (keys.hasNext()) { String key = keys.next(); System.out.println(String.format(\"키 : %s, 값 : %s\", key, map.get(key))); } // 방법2 for (Map.Entry&lt;String, String&gt; elem : map.entrySet()) { System.out.println(String.format(\"키 : %s, 값 : %s\", elem.getKey(), elem.getValue())); } // 방법3 for (String key : map.keySet()) { System.out.println(String.format(\"키 : %s, 값 : %s\", key, map.get(key))); } 복사 hashmap → 순서보장 안됨 순서보장하려면 → LinkedHashMap 사용 아 map으로 하면 같은 key가 안된다는 단점이 있음…. → multivaluemap의 경우에는 중복 key가 가능 하지만, 순서보장이 안됨. 아니지 순서보장을 할 필요가 없지? stack은 Arrays.asList 말고 addAll(List.of(~))를 사용해야함…\n출력 순서 신경쓰기.\nimport java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); Stack&lt;String&gt; textL = new Stack&lt;&gt;(); Stack&lt;String&gt; textR = new Stack&lt;&gt;(); textL.addAll(List.of(br.readLine().split(\"\"))); String resultL = \"\"; String resultR = \"\"; int M = Integer.parseInt(br.readLine()); for (int m=0; m&lt;M; m++) { String inst = br.readLine(); if (inst.startsWith(\"L\") &amp;&amp; !textL.isEmpty()) { textR.push(textL.pop()); continue; } if (inst.startsWith(\"D\") &amp;&amp; !textR.isEmpty()) { textL.push(textR.pop()); continue; } if (inst.startsWith(\"B\") &amp;&amp; !textL.isEmpty()) { textL.pop(); continue; } if (inst.startsWith(\"P\")) { textL.push(inst.substring(2)); } } while (!textL.isEmpty()) {resultL = textL.pop() + resultL;} while (!textR.isEmpty()) {resultR = resultR + textR.pop();} bw.write(resultL+resultR); br.close(); bw.close(); } }\n복사\nString builder로 reverse하기… <br><a data-tooltip-position=\"top\" aria-label=\"https://onlyfor-me-blog.tistory.com/317\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://onlyfor-me-blog.tistory.com/317\" target=\"_self\">[JAVA] StringBuilder란? StringBuilder 사용법</a> import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); Stack&lt;String&gt; textL = new Stack&lt;&gt;(); Stack&lt;String&gt; textR = new Stack&lt;&gt;(); textL.addAll(List.of(br.readLine().split(\"\"))); int M = Integer.parseInt(br.readLine()); for (int m=0; m&lt;M; m++) { String inst = br.readLine(); if (inst.startsWith(\"L\") &amp;&amp; !textL.isEmpty()) { textR.push(textL.pop()); continue; } if (inst.startsWith(\"D\") &amp;&amp; !textR.isEmpty()) { textL.push(textR.pop()); continue; } if (inst.startsWith(\"B\") &amp;&amp; !textL.isEmpty()) { textL.pop(); continue; } if (inst.startsWith(\"P\")) { textL.push(inst.substring(2)); } } StringBuilder sb = new StringBuilder(); while (!textL.isEmpty()) { sb.append(textL.pop()); } sb.reverse(); while (!textR.isEmpty()) { sb.append(textR.pop()); } bw.write(sb.toString()); br.close(); bw.flush(); bw.close(); } }\n복사\nstring 연산이 꽤나 많이 시간을 잡아먹는 구나,,,, <br><a data-tooltip-position=\"top\" aria-label=\"https://www.tcpschool.com/java/java_collectionFramework_iterator\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.tcpschool.com/java/java_collectionFramework_iterator\" target=\"_self\">ListIterator</a>\nimport java.util.*;\nimport java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); List&lt;String&gt; text = new LinkedList&lt;&gt;(Arrays.asList(br.readLine().split(\"\"))); ListIterator&lt;String&gt; iter = text.listIterator(); while (iter.hasNext()) iter.next(); int M = Integer.parseInt(br.readLine()); for (int m=0; m&lt;M; m++) { String inst = br.readLine(); if (inst.startsWith(\"L\") &amp;&amp; iter.hasPrevious()) { iter.previous(); continue; } if (inst.startsWith(\"D\") &amp;&amp; iter.hasNext()) { iter.next(); continue; } if (inst.startsWith(\"B\") &amp;&amp; iter.hasPrevious()) { iter.previous(); iter.remove(); continue; } if (inst.startsWith(\"P\")) { iter.add(inst.substring(2)); } } bw.write(String.join(\"\",text)); br.close(); bw.flush(); bw.close(); }\n}\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1406. 에디터","level":1,"id":"1406. 에디터"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":3,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":3,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":3,"id":"예제_출력_2 복사"},{"heading":"예제 입력 3 복사","level":3,"id":"예제_입력_3 복사"},{"heading":"예제 출력 3 복사","level":3,"id":"예제_출력_3 복사"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"시간 제한","level":3,"id":"시간_제한"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"실패 → 시간초과 / linked list 사용","level":3,"id":"실패_→_시간초과_/_linked_list_사용"},{"heading":"map","level":3,"id":"map"},{"heading":"오 아냐 stack을 쓰면?","level":3,"id":"오_아냐_stack을_쓰면?"},{"heading":"실패 → 또 시간초과","level":3,"id":"실패_→_또_시간초과"},{"heading":"성공","level":3,"id":"성공"},{"heading":"LinkedList사용 → ListIterator","level":3,"id":"LinkedList사용_→_ListIterator"},{"heading":"성공","level":3,"id":"성공"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1406.-에디터.html","pathToRoot":"../../..","attachments":[],"createdTime":1719987848903,"modifiedTime":1720007233567,"sourceSize":12510,"sourcePath":"1. Study/Coding Test/PS/1406. 에디터.md","exportPath":"1.-study/coding-test/ps/1406.-에디터.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1476.-subrectangle-queries.html":{"title":"1476. Subrectangle Queries","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-14<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/subrectangle-queries/description/\" target=\"_self\">https://leetcode.com/problems/subrectangle-queries/description/</a>Level: MediumCategory: -Success: ⭕Git: -Implement the class&nbsp;SubrectangleQueries&nbsp;which receives a&nbsp;rows x cols&nbsp;rectangle as a matrix of integers in the constructor and supports two methods:1.&nbsp;updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) Updates all values with&nbsp;newValue&nbsp;in the subrectangle whose upper left coordinate is&nbsp;(row1,col1)&nbsp;and bottom right coordinate is&nbsp;(row2,col2).\n2.&nbsp;getValue(int row, int col) Returns the current value of the coordinate&nbsp;(row,col)&nbsp;from&nbsp;the rectangle. Example 1:Input\n[\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\"]<br>\n[<a data-href=\"[1,2,1],[4,3,4],[3,2,1],[1,1,1\" href=\"[1,2,1],[4,3,4],[3,2,1],[1,1,1\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">[1,2,1],[4,3,4],[3,2,1],[1,1,1</a>],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]Output\n[null,1,null,5,5,null,10,5]Explanation<br>\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries(<a data-href=\"1,2,1],[4,3,4],[3,2,1],[1,1,1\" href=\"1,2,1],[4,3,4],[3,2,1],[1,1,1\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">1,2,1],[4,3,4],[3,2,1],[1,1,1</a>);\n// The initial rectangle (4x3) looks like:\n// 1 2 1\n// 4 3 4\n// 3 2 1\n// 1 1 1\nsubrectangleQueries.getValue(0, 2); // return 1\nsubrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);\n// After this update the rectangle looks like:\n// 5 5 5\n// 5 5 5\n// 5 5 5\n// 5 5 5\nsubrectangleQueries.getValue(0, 2); // return 5\nsubrectangleQueries.getValue(3, 1); // return 5\nsubrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);\n// After this update the rectangle looks like:\n// 5 5 5\n// 5 5 5\n// 5 5 5\n// 10 10 10\nsubrectangleQueries.getValue(3, 1); // return 10\nsubrectangleQueries.getValue(0, 2); // return 5 ^ix1\nExample 2:\nInput\n[\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\"]<br>\n[<a data-href=\"[1,1,1],[2,2,2],[3,3,3\" href=\"[1,1,1],[2,2,2],[3,3,3\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">[1,1,1],[2,2,2],[3,3,3</a>],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]\nOutput\n[null,1,null,100,100,null,20]\nExplanation<br>\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries(<a data-href=\"1,1,1],[2,2,2],[3,3,3\" href=\"1,1,1],[2,2,2],[3,3,3\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">1,1,1],[2,2,2],[3,3,3</a>);\nsubrectangleQueries.getValue(0, 0); // return 1\nsubrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);\nsubrectangleQueries.getValue(0, 0); // return 100\nsubrectangleQueries.getValue(2, 2); // return 100\nsubrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);\nsubrectangleQueries.getValue(2, 2); // return 20Constraints:\nThere will be at most&nbsp;500&nbsp;operations considering both methods:&nbsp;updateSubrectangle&nbsp;and&nbsp;getValue.\n1 &lt;= rows, cols &lt;= 100\nrows ==&nbsp;rectangle.length\ncols == rectangle[i].length\n0 &lt;= row1 &lt;= row2 &lt; rows\n0 &lt;= col1 &lt;= col2 &lt; cols\n1 &lt;= newValue, rectangle[i][j] &lt;= 10^9\n0 &lt;= row &lt; rows\n0 &lt;= col &lt; cols 이번에는 간단한 클래스 만들기 문제라서,,, 별로 어렵지 않았다.\n<br>어제 정기세션에서도 느꼈지만, 문제 이해를 돕는 설명을 이렇게 적으면 되겠다. 하는 걸 배움. 다음에 연습해볼것 (참고:<a data-tooltip-position=\"top\" aria-label=\"1476. Subrectangle Queries > ^ix1cra\" data-href=\"1476. Subrectangle Queries#^ix1cra\" href=\"1.-study/coding-test/ps/1476.-subrectangle-queries.html#^ix1cra\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Explanation</a>)\nclass SubrectangleQueries { private int[][] rectangle; public SubrectangleQueries(int[][] rectangle) { this.rectangle = rectangle; } public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) { for (int r=row1; r&lt;=row2; r++) { for (int c=col1; c&lt;=col2; c++){ rectangle[r][c] = newValue; } } } public int getValue(int row, int col) { return rectangle[row][col]; }\n}\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1476. Subrectangle Queries","level":1,"id":"1476. Subrectangle Queries"},{"heading":"문제","level":3,"id":"문제"},{"heading":"풀이","level":3,"id":"풀이"}],"links":["1.-study/coding-test/ps/ps.html","[1,2,1],[4,3,4],[3,2,1],[1,1,1","1,2,1],[4,3,4],[3,2,1],[1,1,1","[1,1,1],[2,2,2],[3,3,3","1,1,1],[2,2,2],[3,3,3","1.-study/coding-test/ps/1476.-subrectangle-queries.html#^ix1cra"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1476.-subrectangle-queries.html","pathToRoot":"../../..","attachments":[],"createdTime":1718329925039,"modifiedTime":1719287207557,"sourceSize":3839,"sourcePath":"1. Study/Coding Test/PS/1476. Subrectangle Queries.md","exportPath":"1.-study/coding-test/ps/1476.-subrectangle-queries.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1541.-잃어버린-괄호.html":{"title":"1541. 잃어버린 괄호","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-28<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1541\" target=\"_self\">https://www.acmicpc.net/problem/1541</a>Level: s2Category: greedySuccess: ⭕Git: -세준이는 양수와 +, -, 그리고 괄호를 가지고&nbsp;식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이&nbsp;연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.첫째 줄에 정답을 출력한다.55-50+40-3510+20+30+4010000009-000090\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>잘못된 조건을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/windflower\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/windflower\" target=\"_self\">windflower</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/124\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/124\" target=\"_self\">수학</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/33\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/33\" target=\"_self\">그리디 알고리즘</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/158\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/158\" target=\"_self\">문자열</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/96\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/96\" target=\"_self\">파싱</a> 뒤에서 괄호 열기 / - 앞에서 괄호 닫기 split() → 괄호안에 정규식이 들어가기 때문에 +를 기준으로 하려면 \\\\+로 해주어야한다.\nimport java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] splitByMinus = br.readLine().split(\"-\"); int result = 0; int sum = 0; for (int i=0; i&lt;splitByMinus.length; i++) { String[] splitByPlus = splitByMinus[i].split(\"\\\\+\"); sum = 0; for (String num : splitByPlus) { sum += Integer.parseInt(num); } if(i == 0) {result += sum; continue;} result -= sum; } System.out.println(result); br.close(); } }\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1541. 잃어버린 괄호","level":1,"id":"1541. 잃어버린 괄호"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":3,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":3,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":3,"id":"예제_출력_2 복사"},{"heading":"예제 입력 3 복사","level":3,"id":"예제_입력_3 복사"},{"heading":"예제 출력 3 복사","level":3,"id":"예제_출력_3 복사"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"성공","level":3,"id":"성공"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1541.-잃어버린-괄호.html","pathToRoot":"../../..","attachments":[],"createdTime":1719556054159,"modifiedTime":1719557288483,"sourceSize":2964,"sourcePath":"1. Study/Coding Test/PS/1541. 잃어버린 괄호.md","exportPath":"1.-study/coding-test/ps/1541.-잃어버린-괄호.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1654.-랜선-자르기.html":{"title":"1654. 랜선 자르기","icon":"","description":"집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이&nbsp;캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다.이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm는&nbsp;버려야 한다. (이미 자른 랜선은 붙일 수 없다.)편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오.첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 2^31-1보다 작거나 같은 자연수이다.첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다.4 11\n802\n743\n457\n539 복사200 복사802cm 랜선에서 4개, 743cm 랜선에서 3개, 457cm 랜선에서 2개, 539cm 랜선에서 2개를 잘라내 모두 11개를 만들 수 있다.\n문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/plzrun\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/plzrun\" target=\"_self\">plzrun</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/skydreamer21\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/skydreamer21\" target=\"_self\">skydreamer21</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/twicedtna\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/twicedtna\" target=\"_self\">twicedtna</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/helloworld123\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/helloworld123\" target=\"_self\">helloworld123</a>\n<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/iriszero\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/iriszero\" target=\"_self\">iriszero</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/12\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/12\" target=\"_self\">이분 탐색</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/170\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/170\" target=\"_self\">매개 변수 탐색</a>\n<br>참고: <a data-tooltip-position=\"top\" aria-label=\"https://st-lab.tistory.com/269\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://st-lab.tistory.com/269\" target=\"_self\">[백준] 1654번 : 랜선 자르기 - JAVA [자바]</a> / <a data-tooltip-position=\"top\" aria-label=\"https://st-lab.tistory.com/267\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://st-lab.tistory.com/267\" target=\"_self\">[백준] 10816번 : 숫자 카드 2 - JAVA [자바]</a>\n길이에대한 이분탐색\n최소길이와 최대길이 정하기 최대: 다 더해서 / 필요한 랜선 최소: 가장 짧은 랜선 / (필요한 랜선수 / 가진 랜선 수) 주의: 2^31-1 → int형 최댓값임 long으로 선언\n이분탐색에서 max 설정할 때 널널하게 +1 꼭 해주기. import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int K = Integer.parseInt(st.nextToken()); // 가지고 있는 랜선 수 int N = Integer.parseInt(st.nextToken()); // 필요한 랜선 수 long[] lines = new long[N]; long sum = 0; for (int k = 0; k &lt; K; k++) { lines[k] = Integer.parseInt(br.readLine()); sum += lines[k]; } // 이진탐색 초기화 long max = (sum/N)+1; long min = 0L; while (min &lt; max) { long now = (max + min) / 2; // now = 이번 loop에 사용한 mid값 int cnt = 0; // now에 따라 생성되는 line개수 for (long line: lines) { // line 개수 세기 cnt += line/now; } /* conut된 line(cnt)와 필요한 line(N) 수를 비교 cnt &lt; N -&gt; 줄 개수가 더 많아져야함 = 줄 길이가 현재(now)보다 무조건 짧아야함. cnt &gt;= N -&gt; 줄 개수가 적어져야함. = 줄 길이가 현재(now)보다 무조건 길어야함 (+1). +) upper bound 방식이므로 N과 cnt가 같은 경우 min으로 설정해줌 upper bound: 기준을 초과한 첫번째 값이 반환되도록 -&gt; 던지는 값은 항상 low */ if (cnt &lt; N) { max = now; } else { min = now + 1; } } System.out.println(min-1); } }\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1654. 랜선 자르기","level":1,"id":"1654. 랜선 자르기"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":3,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1","level":3,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":3,"id":"예제_출력_1"},{"heading":"힌트","level":3,"id":"힌트"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"성공공","level":3,"id":"성공공"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1654.-랜선-자르기.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247523,"modifiedTime":1719816795564,"sourceSize":5348,"sourcePath":"1. Study/Coding Test/PS/1654. 랜선 자르기.md","exportPath":"1.-study/coding-test/ps/1654.-랜선-자르기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/1844.-게임-맵-최단거리.html":{"title":"1844. 게임 맵 최단거리","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-05-31<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/1844\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/1844</a>Level: lv2<br>Category: <a data-href=\"BFS, DFS\" href=\"1.-study/coding-test/algorithm/graph/bfs,-dfs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">BFS, DFS</a>Success: ⭕Git: -ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.<br><img alt=\"최단거리1_sxuruo.png\" src=\"https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dc3a1b49-13d3-4047-b6f8-6cc40b2702a7/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B51_sxuruo.png\" referrerpolicy=\"no-referrer\" style=\"width: 143px; max-width: 100%;\" target=\"_self\" class=\"is-unresolved\">위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.\n아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.\n첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.\n<br><img alt=\"최단거리2_hnjd3b.png\" src=\"https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9d909e5a-ca95-4088-9df9-d84cb804b2b0/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B52_hnjd3b.png\" referrerpolicy=\"no-referrer\" style=\"width: 143px; max-width: 100%;\" target=\"_self\" class=\"is-unresolved\">\n두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.\n<br><img alt=\"최단거리3_ntxygd.png\" src=\"https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4b7cd629-a3c2-4e02-b748-a707211131de/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B53_ntxygd.png\" referrerpolicy=\"no-referrer\" style=\"width: 143px; max-width: 100%;\" target=\"_self\" class=\"is-unresolved\">위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.<br><img alt=\"최단거리4_of9xfg.png\" src=\"https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d963b4bd-12e5-45da-9ca7-549e453d58a9/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B54_of9xfg.png\" referrerpolicy=\"no-referrer\" style=\"width: 141px; max-width: 100%;\" target=\"_self\" class=\"is-unresolved\">게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의&nbsp;최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.\nmaps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다. n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다. maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.\n처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.\n입출력 예 #1\n주어진 데이터는 다음과 같습니다.<br><img alt=\"최단거리6_lgjvrb.png\" src=\"https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/6db71f7f-58d3-4623-9fab-7cd99fa863a5/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B56_lgjvrb.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">캐릭터가 적 팀의 진영까지 이동하는 가장 빠른 길은 다음 그림과 같습니다.<br><img alt=\"최단거리2_hnjd3b (1).png\" src=\"https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d223d017-b3e2-4772-9045-a565133d45ff/%E1%84%8E%E1%85%AC%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A5%E1%84%85%E1%85%B52_hnjd3b%20%281%29.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">따라서 총 11칸을 캐릭터가 지나갔으므로 11을 return 하면 됩니다.입출력 예 #2\n문제의 예시와 같으며, 상대 팀 진영에 도달할 방법이 없습니다. 따라서 -1을 return 합니다.\n최단 거리 구하는 알고리즘: bfs\n재귀에서 목적지에 도착했는지를 가장 먼저 check하고 return해줘야하는 듯. 최단 거리 보장이니까\nimport java.util.*;\nclass Solution { static int[][] offset = {{-1,0}, {1,0}, {0,-1}, {0,1}}; public int solution(int[][] maps) { Queue&lt;int[]&gt; que = new LinkedList&lt;&gt;(); int[][] visited = new int[maps.length][maps[0].length]; que.offer(new int[] {0,0}); bfs(0, 0, que, maps, visited); return 0; } private void bfs(int r, int c, Queue&lt;int[]&gt; que, int[][] maps, int[][] visited) { // 전체 완료 if (que.size() == 0) return ; // 이번 탐색 visited[r][c] = 1; // 인접 node들 que에 삽입 for (int[] o : offset) { int newR = r+o[0]; int newC = c+o[1]; // out of index if (newR &lt; 0 || newC &lt; 0 || newR &gt;= maps.length || newC &gt;= maps[0].length) continue; // invaild node if (maps[newR][newC] == 0 || visited[newR][newC] != 0) continue; que.offer(new int[] {newR, newC}); } // 다음 탐색 int[] newNode = que.poll(); System.out.println(newNode[0] + \" \" + newNode[1]); bfs(newNode[0], newNode[1], que, maps, visited); }\n}\n복사\n여기서 최단거리 측정 logic을 모르겠음.\n구글링 해보니 대부분 visited 배열을 사용.\n재귀보다 반복문이 훨씬 편하네…\n아 바로 전 좌표가 있구나… 그걸로 이전 visit 값 가져오면 되겠구만.\nimport java.util.*;\nclass Solution { static int[][] offset = {{-1,0}, {1,0}, {0,-1}, {0,1}}; public int solution(int[][] maps) { int[][] visited = new int[maps.length][maps[0].length]; visited[0][0] = 1; bfs(maps, visited); int answer = visited[maps.length-1][maps[0].length-1]; if (answer == 0) answer = -1; return answer; } private void bfs(int[][] maps, int[][] visited) { Queue&lt;int[]&gt; que = new LinkedList&lt;&gt;(); que.offer(new int[] {0,0}); while (!que.isEmpty()) { int[] node = que.poll(); int r = node[0]; int c = node[1]; // 인접 node들 que에 삽입 for (int[] o : offset) { int newR = r+o[0]; int newC = c+o[1]; // out of index if (newR &lt; 0 || newC &lt; 0 || newR &gt;= maps.length || newC &gt;= maps[0].length) continue; // invaild node if (maps[newR][newC] == 0 || visited[newR][newC] != 0) continue; que.offer(new int[] {newR, newC}); // visit 처리 visited[newR][newC] = visited[r][c] + 1; } } }\n}\n복사\n왜 최단 거리를 보장하는가. 가장 먼저 도달했을 때의 거리를 visit 배열에 넣어주면, 그 후에 그 node에 접근하는 애들들은 접근부터 불가능함. 최소 거리로 남아있음. 목적지에 도달했을 때 바로 loop 끝내고 돌아가는 것도 가능. → 오히려 시간 줄일 듯.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"1844. 게임 맵 최단거리","level":1,"id":"1844. 게임 맵 최단거리"},{"heading":"문제","level":3,"id":"문제"},{"heading":"문제 설명","level":6,"id":"문제_설명"},{"heading":"제한사항","level":5,"id":"제한사항"},{"heading":"입출력 예","level":5,"id":"입출력_예"},{"heading":"입출력 예 설명","level":5,"id":"입출력_예_설명"},{"heading":"풀이","level":3,"id":"풀이"},{"heading":"bfs 구현","level":4,"id":"bfs_구현"},{"heading":"성공","level":4,"id":"성공"}],"links":["1.-study/coding-test/ps/ps.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1","1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/1844.-게임-맵-최단거리.html","pathToRoot":"../../..","attachments":[],"createdTime":1717120476373,"modifiedTime":1717146877398,"sourceSize":8233,"sourcePath":"1. Study/Coding Test/PS/1844. 게임 맵 최단거리.md","exportPath":"1.-study/coding-test/ps/1844.-게임-맵-최단거리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html":{"title":"2336. Smallest Number in Infinite Set","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-05-25<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/smallest-number-in-infinite-set/description/\" target=\"_self\">https://leetcode.com/problems/smallest-number-in-infinite-set/description/</a><br>Category: <a data-href=\"heap (Priority Queue)\" href=\"heap (Priority Queue)\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">heap (Priority Queue)</a>Level: MediumSuccess: ⭕ +aGit: 추가로 해볼 것:\nYou have a set which contains all positive integers&nbsp;[1, 2, 3, 4, 5, ...].Implement the&nbsp;SmallestInfiniteSet&nbsp;class:\nSmallestInfiniteSet()&nbsp;Initializes the&nbsp;SmallestInfiniteSet&nbsp;object to contain&nbsp;all&nbsp;positive integers.\nint popSmallest()&nbsp;Removes&nbsp;and returns the smallest integer contained in the infinite set.\nvoid addBack(int num)&nbsp;Adds&nbsp;a positive integer&nbsp;num&nbsp;back into the infinite set, if it is&nbsp;not&nbsp;already in the infinite set.\nExample 1:**Input**\n[\"SmallestInfiniteSet\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\"]\n[[], [2], [], [], [], [1], [], [], []]\n**Output**\n[null, null, 1, 2, 3, null, 1, 4, 5]\n복사Explanation\nSmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();\nsmallestInfiniteSet.addBack(2); // 2 is already in the set, so no change is made.\nsmallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set.\nsmallestInfiniteSet.popSmallest(); // return 2, and remove it from the set.\nsmallestInfiniteSet.popSmallest(); // return 3, and remove it from the set.\nsmallestInfiniteSet.addBack(1); // 1 is added back to the set.\nsmallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and\n// is the smallest number, and remove it from the set.\nsmallestInfiniteSet.popSmallest(); // return 4, and remove it from the set.\nsmallestInfiniteSet.popSmallest(); // return 5, and remove it from the set.Constraints:\n1 &lt;= num &lt;= 1000\n<br>At most&nbsp;1000&nbsp;calls will be made&nbsp;in total&nbsp;to&nbsp;popSmallest&nbsp;and&nbsp;addBack.\nHint&nbsp;1Based on the constraints, what is the maximum element that can possibly be popped?Hint&nbsp;2Maintain whether elements are in or not in the set. How many elements do we consider?Similar Questions<a data-tooltip-position=\"top\" aria-label=\"https://leetcode.com/problems/first-missing-positive/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://leetcode.com/problems/first-missing-positive/\" target=\"_self\">First Missing Positive</a>\nleet는 처음이라 문제 보는 법이 어려움. 특히 input 부분은 아직도 모르겠다. infinity set이란 걸 어떻게 만들지 당황했는데, 아래 제한 사항을 살펴보니 입력되는 num이 1000 이하였음 → 1~1000까지 힙 만들기.\nempty check 또한 할 필요 없음 → infinity set이며 최대 pop 호출 건수가 1000번이기 때문에.\n<br>이전 <a data-tooltip-position=\"top\" aria-label=\"42626. 더맵게\" data-href=\"42626. 더맵게\" href=\"1.-study/coding-test/ps/42626.-더맵게.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">heap 문제</a>에서는 add를 사용했는데 대신 offer를사용 add(): 우선순위 큐에 원소를 추가. 큐가 꽉 찬 경우&nbsp;에러 발생\noffer(): 우선순위 큐에 원소를 추가. 값 추가 실패 시&nbsp;false를 반환 priority queue에서 값을 조회하는 함수 peek()\n<br><a href=\".?query=tag:질문/코딩테스트\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#질문/코딩테스트\">#질문/코딩테스트</a>\npriority queue의 capacity 문제 → 잘모르겠음.\nimport java.util.*; class SmallestInfiniteSet { private PriorityQueue&lt;Integer&gt; sis; public SmallestInfiniteSet() { sis = new PriorityQueue&lt;&gt;(1000); for (int i=1; i&lt;=1000; i++) { sis.offer(i); } } public int popSmallest() { return sis.poll(); } public void addBack(int num) { Integer minInSet = sis.peek(); if (minInSet == null || minInSet &gt; num) { // minInSet == null -&gt; queue is empty sis.offer(num); } }\n}\n복사[\"SmallestInfiniteSet\",\"popSmallest\",\"addBack\",\"popSmallest\",\"popSmallest\",\"popSmallest\",\"addBack\",\"addBack\",\"popSmallest\",\"popSmallest\"] [[],[],[1],[],[],[],[2],[3],[],[]] Use Testcase Output [null,1,null,1,2,3,null,null,2,4]\n복사\npop은 smallest number만 가능하기 때문에, (작은 순서대로 숫자가 사라지니) addBack의 할 때, 해당 숫자가 set에 존재하는 지를 set 가장 작은 숫자를 조회에서 확인 할 수 있다고 생각했음 즉, set에 들어있는 숫자는 건너뛰는 경우없이 촘촘히 채워져 있다고 생각\n하지만, 123이 빠진 와중에 2가 addBack을 통해 추가되면, 3은 기존 확인 방법에서 제외되지만 사실 추가될 수 있는 상태 해결: includes? (아 요즘 js를 많이 썼더니….) 말고 contains import java.util.*; class SmallestInfiniteSet { private PriorityQueue&lt;Integer&gt; sis; public SmallestInfiniteSet() { sis = new PriorityQueue&lt;&gt;(1000); for (int i=1; i&lt;=1000; i++) { sis.offer(i); } } public int popSmallest() { return sis.poll(); } public void addBack(int num) { if (!sis.contains(num)){ sis.offer(num); } }\n}\n복사\n시간이 66ms → 조금 줄이고 싶음\ncontains()… 아까부터 맘에 안듦. TreeSet 사용하면 중복 없고, 자동 정렬 가능! contains() 체크 안하고 그냥 추가 가능. import java.util.*; class SmallestInfiniteSet { private TreeSet&lt;Integer&gt; sis; public SmallestInfiniteSet() { sis = new TreeSet&lt;&gt;(); for (int i=1; i&lt;=1000; i++) { sis.add(i); } } public int popSmallest() { return sis.pollFirst(); } public void addBack(int num) { sis.add(num); }\n}\n복사\n시간이 반절 정도 줌.\n처음에 1000개 들어가 배열 사용하지 않는 것도 방법일듯…! class SmallestInfiniteSet { HashSet&lt;Integer&gt; remov; int i; public SmallestInfiniteSet() { remov=new HashSet(); i=1; } public int popSmallest() { while(remov.contains(i)){ i++; } remov.add(i); return i++; } public void addBack(int num) { if(remov.contains(num)){ remov.remove(num); if(i&gt;num){ i=num; } } } }\n복사","aliases":[],"inlineTags":["#질문/코딩테스트"],"frontmatterTags":[],"headers":[{"heading":"2336. Smallest Number in Infinite Set","level":1,"id":"2336. Smallest Number in Infinite Set"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"wrong answer","level":3,"id":"wrong_answer"},{"heading":"Accepted","level":3,"id":"Accepted"},{"heading":"다른 사람 풀이","level":3,"id":"다른_사람_풀이"}],"links":["1.-study/coding-test/ps/ps.html","heap (Priority Queue)","1.-study/coding-test/ps/42626.-더맵게.html","?query=tag:%EC%A7%88%EB%AC%B8/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html","pathToRoot":"../../..","attachments":["1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html"],"createdTime":1716644611253,"modifiedTime":1717120412817,"sourceSize":6611,"sourcePath":"1. Study/Coding Test/PS/2336. Smallest Number in Infinite Set.md","exportPath":"1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/2805.-나무-자르기.html":{"title":"2805. 나무 자르기","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-29<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/2805\" target=\"_self\">https://www.acmicpc.net/problem/2805</a>Level: s2Category: 매개 변수 탐색이분탐색Success: ⭕상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를&nbsp;이용해서 나무를 구할것이다.목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.4 7\n20 15 10 17155 20\n4 42 40 26 4636<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/45\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/45\" target=\"_self\">Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/17\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/17\" target=\"_self\">Croatian Open Competition in Informatics</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/19\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/19\" target=\"_self\">COCI 2011/2012</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/72\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/72\" target=\"_self\">Contest #5</a>&nbsp;2번\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/csehydrogen\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/csehydrogen\" target=\"_self\">csehydrogen</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/upple1\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/upple1\" target=\"_self\">upple1</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/vyu\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/vyu\" target=\"_self\">vyu</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jongseo_park\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jongseo_park\" target=\"_self\">jongseo_park</a>\n<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/rdd6584\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/rdd6584\" target=\"_self\">rdd6584</a>\n<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/tncks0121\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/tncks0121\" target=\"_self\">tncks0121</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/12\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/12\" target=\"_self\">이분 탐색</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/170\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/170\" target=\"_self\">매개 변수 탐색</a> 왜 이게 이진탐색?\n다 더하고 하나씩 빼가면서 보기… 어때?\nimport java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); // 나무 수 int M = Integer.parseInt(st.nextToken()); // 나무 길이 st = new StringTokenizer(br.readLine()); int[] trees = new int[N]; int sum = 0; for (int n = 0; n &lt; N; n++) { trees[n] = Integer.parseInt(st.nextToken()); sum += trees[n]; } Arrays.sort(trees); // 이진탐색 초기화 int l = 0; int r = N - 1; } }\n복사\n<br>\n일단 여기까지 하고 직전문제 풀고오기 <a data-href=\"1654. 랜선 자르기\" href=\"1.-study/coding-test/ps/1654.-랜선-자르기.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1654. 랜선 자르기</a> 최대: 가장 큰 나무 최소: 0 sort를 해야할까? → 하는 게 좋을 듯, tree 길이 배열을 거꾸로 돌려서 나무 길이가 칼 위치보다 낮아지면, 반복문 종료하기. import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); // 나무 수 int M = Integer.parseInt(st.nextToken()); // 나무 길이 st = new StringTokenizer(br.readLine()); int[] trees = new int[N]; for (int n = 0; n &lt; N; n++) { trees[n] = Integer.parseInt(st.nextToken()); } Arrays.sort(trees); // 이진탐색 초기화 int hi = trees[N-1]+1; int lo = 0; while (lo &lt; hi) { int now = (hi+lo) / 2; long sum = 0; for (int n=N-1; n&gt;=0; n--){ if (trees[n] &lt; now) break; sum += (trees[n] - now); } if (sum &lt; M) { hi = now; } else { lo = now + 1; } } System.out.println(lo-1); } } 복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"2805. 나무 자르기","level":1,"id":"2805. 나무 자르기"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":3,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":3,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":3,"id":"예제_출력_2 복사"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"}],"links":["1.-study/coding-test/ps/ps.html","1.-study/coding-test/ps/1654.-랜선-자르기.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/2805.-나무-자르기.html","pathToRoot":"../../..","attachments":[],"createdTime":1719660408892,"modifiedTime":1719987897919,"sourceSize":6162,"sourcePath":"1. Study/Coding Test/PS/2805. 나무 자르기.md","exportPath":"1.-study/coding-test/ps/2805.-나무-자르기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/10025.-게으른-백곰.html":{"title":"10025. 게으른 백곰","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-07-08<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/10025\" target=\"_self\">https://www.acmicpc.net/problem/10025</a>Level: s3Category: -Success: -더운 여름날 동물원의 백곰 앨버트는 너무 더워서 꼼짝도 하기 싫다.&nbsp;다행히도 사육사들이 앨버트의 더위를 식히기 위해 얼음이 담긴 양동이들을 가져다 주었다.&nbsp;앨버트가 가장 적은 거리만 움직이고도 최대한 많은 얼음으로 더위를 식힐 수 있도록 도와주자.우리 안은 1차원 배열로 생각하며, 총 N(1 ≤ N ≤ 100000)개의 얼음 양동이들이 xi(0 ≤ xi&nbsp;≤ 1,000,000)좌표마다 놓여 있고&nbsp;각 양동이 안에는 gi(1 ≤ gi&nbsp;≤ 10,000)씩의 얼음이 들어 있다.&nbsp;일단 앨버트가 자리를 잡으면 그로부터 좌우로 K(1 ≤&nbsp;K ≤ 2,000,000) 만큼 떨어진 양동이까지 닿을 수 있다. 앨버트는 양동이가 놓여 있는 자리에도 자리잡을 수 있다. 모든 얼음 양동이의 위치는 다르다.앨버트가 최적의 자리를 골랐을 때 얼음의 합을 구하시오. 즉, 얼음들의 합의 최댓값을 구해야 한다.첫 줄에 정수 N과 K가 들어온다.&nbsp;둘째 줄부터 N째 줄까지, 공백을 사이에 두고 각 양동이의 얼음의 양을 나타내는 gi와 양동이의 좌표를 나타내는 xi가 주어진다.앨버트가 택한 최적 위치로부터 K만큼 떨어진 거리 내에 있는 얼음들의 합(최댓값)을 출력한다.4 3\n4 7\n10 15\n2 2\n5 111앨버트가&nbsp;x=4에 자리를 잡으면 x=1, x=2, x=7에 있는 얼음 양동이에 닿을 수 있다.<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/2\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/2\" target=\"_self\">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/106\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/106\" target=\"_self\">USA Computing Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/281\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/281\" target=\"_self\">2013-2014 Season</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/296\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/296\" target=\"_self\">USACO March 2014 Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/1243\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/1243\" target=\"_self\">Bronze</a>&nbsp;2번\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/pjw\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/pjw\" target=\"_self\">pjw</a>\n<br>잘못된 번역을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/swh98\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/swh98\" target=\"_self\">swh98</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/139\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/139\" target=\"_self\">누적 합</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/80\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/80\" target=\"_self\">두 포인터</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/68\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/68\" target=\"_self\">슬라이딩 윈도우</a>\n4Byte * 1,000,000 = 4,000,000Byte = 4,000 KB = 4MB이다. 메모리 용량이 충분하기 때문에 1000001칸 배열을 만들어서 얼음 양을 저장한다.\npointer1(p1)은 부분합을 구하는 시작 index이자, 다음 부분합에서 빠져야하는 idx값이다.\npointer2(p2)는 부분합의 끝을 알리는 index이므로, 현재 부분합에는 포함되지 않는다. (다음 부분합에 포함된다.) 처음에 배열 크기를 N의 최대 크기로 잡음. (X)\nN은 양동이의 개수이므로, 우리 크기와 밀접한 관련을 가지기는 어렵다.\n대신 g_i의 경우가 배열 내에 양동이의 위치이므로, 유효한 배열의 크기와 밀접한 관련이 있다.\nimport java.io.*; import java.util.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); // 양동이 개수 int K = Integer.parseInt(st.nextToken()); // 움직일 수 있는 거리. int move = 2 * K + 1; int allIce = 0; int len = 0; int[] pen = new int[1000001]; for (int n=0; n&lt;N; n++) { st = new StringTokenizer(br.readLine()); int ice = Integer.parseInt(st.nextToken()); int idx = Integer.parseInt(st.nextToken()); pen[idx] = ice; allIce += ice; if (idx &gt; len) len = idx; } len++; if (len &lt;= move) { System.out.println(allIce); return; } int p1 = 0; // pointer 1 int p2 = move; // pointer 2 int sum = 0; // 부분합 초기화 for (int i=p1; i&lt;(p2); i++) { sum += pen[i]; } int max = sum; // 부분합의 최댓값 구하기. for (int i=1; i&lt;(len-(move)); i++) { sum -= pen[p1]; sum += pen[p2]; p1++; p2++; if (sum &gt; max) max = sum; } System.out.println(max); } }\n복사\n배열 생성을 위한 for문에서, 첫 부분합 범위에 속하는 값을 sum에 더해주기 유효한 배열길이(len)&lt; 이동가능 거리(move)일 경우 그냥 전체 얼음개수를 출력해주는 연산을 지워도 될 듯. 아래와 같이 첫 부분합 생성이 끝나면, 그때부터 값 빼주는 연산 진행. for (int i = 0; i &lt;= 1000000; i++) { if(i-K&gt;=0) sum -= ice[i - K]; sum += ice[i]; max = Math.max(max,sum); }\n복사import java.io.*; import java.util.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine()); int N = Integer.parseInt(st.nextToken()); // 양동이 개수 int K = Integer.parseInt(st.nextToken()); int move = 2 * K + 1; // 움직일 수 있는 전체 거리. int[] pen = new int[1000001]; int len = 0; int sum = 0; for (int n=0; n&lt;N; n++) { st = new StringTokenizer(br.readLine()); int ice = Integer.parseInt(st.nextToken()); int idx = Integer.parseInt(st.nextToken()); pen[idx] = ice; if (idx &gt; len) len = idx; // 유효한 배열 크기 구하기 if (idx &lt; move) sum += ice; // 초기 부분합 구하기 } len++; int p1 = 0; // pointer 1 int p2 = move; // pointer 2 int max = sum; // 부분합의 최댓값 구하기. for (int i=1; i&lt;(len-(move)); i++) { sum -= pen[p1]; sum += pen[p2]; p1++; p2++; if (sum &gt; max) max = sum; } System.out.println(max); } }\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"10025. 게으른 백곰","level":1,"id":"10025. 게으른 백곰"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":3,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"힌트","level":3,"id":"힌트"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"메모리 용량 체크","level":4,"id":"메모리_용량_체크"},{"heading":"p1, p2 정의","level":4,"id":"p1,_p2_정의"},{"heading":"배열 크기 헷갈림","level":4,"id":"배열_크기_헷갈림"},{"heading":"1차 성공","level":3,"id":"1차_성공"},{"heading":"for문 3개를 2개로 줄이기.","level":4,"id":"for문_3개를_2개로_줄이기."},{"heading":"성공2","level":3,"id":"성공2"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/10025.-게으른-백곰.html","pathToRoot":"../../..","attachments":[],"createdTime":1720420099601,"modifiedTime":1720424580500,"sourceSize":7490,"sourcePath":"1. Study/Coding Test/PS/10025. 게으른 백곰.md","exportPath":"1.-study/coding-test/ps/10025.-게으른-백곰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/11047.-동전-0.html":{"title":"11047. 동전 0","icon":"","description":"<a href=\".?query=tag:코딩테스트\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#코딩테스트\">#코딩테스트</a><br>\n<a href=\".?query=tag:실버/4\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#실버/4\">#실버/4</a> 준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai&nbsp;≤ 1,000,000, A1&nbsp;= 1, i&nbsp;≥ 2인 경우에&nbsp;Ai는 Ai-1의 배수)첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.10 4200\n1\n5\n10\n50\n100\n500\n1000\n5000\n10000\n50000610 4790\n1\n5\n10\n50\n100\n500\n1000\n5000\n10000\n5000012\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/ai4youej\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/ai4youej\" target=\"_self\">ai4youej</a>\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/33\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/33\" target=\"_self\">그리디 알고리즘</a>\nimport sys def coin_0(): N, total = map(int, sys.stdin.readline().split()) coin = [] now = 0 cnt = 0 for _ in range(N): coin.append(int(sys.stdin.readline().rstrip())) for v in reversed(coin): while now + v &lt;= total: cnt += 1 now += v if now == total: print(cnt) break if __name__ == \"__main__\": coin_0()\n복사\n생각해보니 굳이 반복문 돌릴 필요 없음, 나누기로 해결 가능\nimport sys def coin_0(): N, total = map(int, sys.stdin.readline().split()) coin = [] now = 0 cnt = 0 for _ in range(N): coin.append(int(sys.stdin.readline().rstrip())) for v in reversed(coin): temp = (total - now) // v cnt += temp now += v * temp if now == total: print(cnt) break if __name__ == \"__main__\": coin_0() 복사 종류를 무한으로 쓸 수 있는 건 쉬운데, 종류별로 갯수가 정해져있는 건 까다로움… <br>\n일전에 실패했던 배낭문제(<a data-href=\"12865. 평범한 배낭\" href=\"1.-study/coding-test/ps/12865.-평범한-배낭.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">12865. 평범한 배낭</a>)와 이문제 (<a data-href=\"11047. 동전 0\" href=\"1.-study/coding-test/ps/11047.-동전-0.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">11047. 동전 0</a>) 그리고 동전이 배수가 아닌 경우의 차이가 뭘까. 내생각 ","aliases":[],"inlineTags":["#코딩테스트","#실버/4"],"frontmatterTags":[],"headers":[{"heading":"11047. 동전 0","level":1,"id":"11047. 동전 0"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":3,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":3,"id":"예제_출력_2 복사"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"1차 시간초과","level":3,"id":"1차_시간초과"},{"heading":"2차 성공","level":3,"id":"2차_성공"},{"heading":"질문(11047. 동전 0)","level":3,"id":"질문([[11047._동전_0]])"}],"links":["?query=tag:%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8","?query=tag:%EC%8B%A4%EB%B2%84/4","1.-study/coding-test/ps/11047.-동전-0.html","1.-study/coding-test/ps/12865.-평범한-배낭.html","1.-study/coding-test/ps/11047.-동전-0.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/11047.-동전-0.html","pathToRoot":"../../..","attachments":[],"createdTime":1709787932535,"modifiedTime":1709789606212,"sourceSize":2649,"sourcePath":"1. Study/Coding Test/PS/11047. 동전 0.md","exportPath":"1.-study/coding-test/ps/11047.-동전-0.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/11279.-최대-힙.html":{"title":"11279. 최대 힙","icon":"","description":"<a href=\".?query=tag:코딩테스트\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#코딩테스트\">#코딩테스트</a><br>\n<a href=\".?query=tag:실버/2\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#실버/2\">#실버/2</a>널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.\n배열에 자연수 x를 넣는다.\n배열에서 가장 큰 값을 출력하고,&nbsp;그 값을 배열에서 제거한다.\n프로그램은 처음에 비어있는 배열에서 시작하게 된다.첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 231보다 작다.입력에서 0이 주어진 횟수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.13\n0\n1\n2\n0\n0\n3\n2\n1\n0\n0\n0\n0\n00\n2\n1\n3\n2\n1\n0\n0\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/dantebald\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/dantebald\" target=\"_self\">dantebald</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/spotky1004\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/spotky1004\" target=\"_self\">spotky1004</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/1927\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1927\" target=\"_self\">1927번. 최소 힙</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/11286\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/11286\" target=\"_self\">11286번. 절댓값 힙</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/175\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/175\" target=\"_self\">자료 구조</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/59\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/59\" target=\"_self\">우선순위 큐</a> Java 8: 2 초\nJava 8 (OpenJDK): 2 초\nJava 11: 2 초\nKotlin (JVM): 2 초 오 이거 우선순위 큐 아닌가\n어떻게 구현 했었지… deque없이 하려면 list에서는 가장 뒤에 걸 지웠을 때 시간복잡도가 작으니(남은 값들 옮길 필요 없음.) 오름차순으로 정렬.\nimport sys def max_heap(): N = int(sys.stdin.readline().rstrip()) lst = [] while N &gt; 0: N -= 1 x = int(sys.stdin.readline().rstrip()) if x != 0: lst.append(x) else: if len(lst) != 0: lst.sort() print(lst.pop()) else: print(0) if __name__ == \"__main__\": max_heap()\n복사\n결과: 시간초과… <br>\n<a data-tooltip-position=\"top\" aria-label=\"https://yoongrammer.tistory.com/81\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://yoongrammer.tistory.com/81\" target=\"_self\">[자료구조] 우선순위 큐 (Priority Queue) 개념 및 구현</a> 오 힙으로 구현해야하는데, 트리 다 까먹었는데…. 파이썬 heap관련 모듈: heapq import sys, heapq def max_heap(): N = int(sys.stdin.readline().rstrip()) heap = [] while N &gt; 0: N -= 1 x = int(sys.stdin.readline().rstrip()) if x != 0: heapq.heappush(heap, -x) else: if len(heap) != 0: print(-heapq.heappop(heap)) else: print(0) if __name__ == \"__main__\": max_heap() 복사","aliases":[],"inlineTags":["#코딩테스트","#실버/2"],"frontmatterTags":[],"headers":[{"heading":"11279. 최대 힙","level":1,"id":"11279. 최대 힙"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"출처","level":3,"id":"출처"},{"heading":"비슷한 문제","level":3,"id":"비슷한_문제"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"시간 제한","level":3,"id":"시간_제한"},{"heading":"풀이","level":2,"id":"풀이"}],"links":["?query=tag:%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8","?query=tag:%EC%8B%A4%EB%B2%84/2"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/11279.-최대-힙.html","pathToRoot":"../../..","attachments":[],"createdTime":1709347419168,"modifiedTime":1709349350796,"sourceSize":3822,"sourcePath":"1. Study/Coding Test/PS/11279. 최대 힙.md","exportPath":"1.-study/coding-test/ps/11279.-최대-힙.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/11561.-징검다리.html":{"title":"11561. 징검다리","icon":"","description":"승택이는 강을 건너려 한다.승택이는 수영을 못하기 때문에, 강에 놓인 징검다리를 밟고 건너갈 것이다.승택이는 수영은 못하지만 제자리뛰기는 정말 잘한다. 원하는 어느 곳으로든지 점프해서 바로 갈 수가 있다.승택이는 이제 강의 한쪽 변 앞에 서 있다.강엔 1번부터 시작해 2번, 3번, ... , N번 징검다리가 차례대로 놓여 있다.강의 폭이 넓은 탓에 징검다리의 수는 엄청나게 많다.이 징검다리를 모두 밟고 싶지는 않았던 승택이는 제자리뛰기 실력을 발휘해 적절한 개수의 징검다리만을 밟고 가기로 했다.물론 강 건너편으로 바로 점프하는 것도 가능하지만, 더 재미있게 강을 건너기 위해 승택이는 다음과 같은 규칙을 정했다.\n첫 징검다리는 점프해서 아무 것이나 밟을 수 있다. 이 점프가 첫 점프이다.\n두 번째 점프부터는 이전에 점프한 거리보다 1 이상 더 긴 거리를 뛰어야만 한다.\nN번 징검다리는 반드시 밟아야 한다.\nN번 징검다리를 밟은 후 강 건너로 이동할 땐 점프를 하지 않으므로 위의 규칙이 적용되지 않는다.\n승택이가 위의 규칙을 지키며 강을 건널 때, 밟을 수 있는 징검다리의 최대 수는 몇 개일까?첫째 줄에 테스트 케이스의 수 T가 주어진다.각 테스트 케이스는 정수 한 개로 이루어져 있으며, 징검다리의 총 수 N을 의미한다. (1 ≤ N ≤ )각 테스트 케이스마다 한 줄에 승택이가 밟을 수 있는 최대 징검다리 수를 출력한다.입력 값이 까지 갈 수 있다는 뜻은 int에서는 overflow 발생한다는 뜻이다. int는 10자리 숫자자까지(대략 2,000,000,000) 반 수용 가능하다. 따라서 long 자료형을 사용해 입력값을 받아야한다.문제에서는 제약조건을 만족하면서 밟을 수 있는 최대 징검다리의 개수를 물어보고 있으므로 승택이 뛰어넘는 징검다리 간격을 매 회 1씩 증가한다는 것으로 고정할 수 있다.이에 따라 징검다리 개수를 으로 두고, 승철이 총 번 징검다리를 건넌다고 했을 때, 남아있는 징검다리의 숫자를 이라고 하자.라는 식이 도출된다.남아있는 징검다리의 숫자인 은 다음 그림에서 표현한 것과 같다. 즉 이 13인 경우, 총 4번을 뛰어넘으면 3칸()이 남아 5칸을 뛰어넘을 수 없다. 대신 4번째로 딛는 곳을 4가 아닌 깃발로 변경하면 된다.\n<img alt=\"Pasted image 20241030171506.png\" src=\"5.-file/image/pasted-image-20241030171506.png\" target=\"_self\">\n따라서 은 0보다 크거나 같아야하고, 이를 수식으로 표현하면 다음과 같다. 해당 방정식을 만족하는 값 중 최대값은이고, 이때, 값이 음수가 될 수는 없으므로\n이것이 문제의 조건을 만족하는 값이다.따라서 코드에서는 이 식을 사용해주면 된다.import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(br.readLine()); for (int i=0; i &lt; T; i++) { long N = Long.parseLong(br.readLine()); System.out.println(getNumOfJump(N)); } } private static int getNumOfJump(long n){ int k = (int) ((double) ((-1 + Math.sqrt(8*n+1)))/2); return k; } }\n복사기본적인 lower bound와 다르게, target값 이상이 처음 등장하는 위치를 반환하는 게 아니라, 아래 그림과 같이 target값을 초과하는 값 바로 전 위치를 반환해야한다. (105가 아니라 91을 선택해야하는 이유에 대해선 위에 이미 설명해두었다.)<br><img alt=\"Pasted image 20241030173905.png\" src=\"5.-file/image/pasted-image-20241030173905.png\" target=\"_self\">\nwhile 조건문 : lo &lt; hi → lo + 1 &lt; hi\ncase 1: N 값과 일치하는 값이 있는 경우. → now == n break하고 mid값 반환 case 2: N 값을 초과하는 경우 → now &gt; n hi에 mid 값 할당. case 3: N 값 미만인 경우 → now &lt; n lo에 mid값 할당 → 해당 mid(= k)가 반환되어야할 값일 수도 있기 때문에. mid + 1을 할당 할 수 없음\n<br>다만 그렇게 되면 무한 루프에 걸릴 수 있기 때문에 (<a data-href=\"이분탐색\" href=\"1.-study/coding-test/algorithm/이분탐색.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">이분탐색</a> 참고) 애당초 lo &lt; hi로 상정해 두었던 조건문을 lo + 1 &lt; hi로 수정 import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(br.readLine()); for (int i=0; i &lt; T; i++) { long N = Long.parseLong(br.readLine()); System.out.println(getNumOfJump(N)); } } private static long getNumOfJump(long n){ long hi = 1000000000; long lo = 1; long mid, now; while (lo + 1 &lt; hi) { mid = (hi+lo)/2; now = mid*(mid+1) / 2; if (now == n) { lo = mid; break; } if (now &lt; n) { lo = mid; continue; } if (now &gt;= n) { hi = mid; } } return lo; }\n} ```\n→ 이 로직은 (쫌 짜잘하긴 하지만) 처음 hi값을 탐색하지 못하기 때문에 문제가 생길 수 있다. n과 now가 일치하는 케이스(case1)에 해당하면서 처음`hi` 값이 정답인 경우 오답을 반환하게 되는 것이다.\n예를 들어 `lo = 0; hi = 4;`으로 초기화하고, `N = 10`일때, 답이 4가 나와야 하지만 3이 나온다. `hi` 값을 탐색할 기회가 없는 것이다. (이걸 알게된 이유는, 탐색범위를 줄여보겠다고 위에서 썼던 수식을 가져다가 hi에 대입했더니(지금 생각해보면 이 경우 그냥 hi가 정답이다….) 문제가 생겨서이다.) 단순히 범위를 넓게 잡거나(위의 코드처럼 `1000000000` || `Long.MAX_VALUE`처럼) 아니면 다른 사람들이 푼 대로, `while` 조건문을 (`lo&lt;=hi)`로 하고(`lo`, `hi` 갱신 값도 맞게 바꿔야함.) `lo`를 초기화하는 경우에 그 때 `mid`값을 다른 변수에 저장해 두는 것이다. ```java\nprivate static long getNumOfJump2(long n) { long hi = (long) Math.sqrt(2 * n); long lo = 1; long mid, now, ans=0; while (lo &lt;= hi) { mid = (hi + lo) / 2; now = mid * (mid + 1) / 2; if (now == n) { ans = mid; break; } if (now &lt; n) { lo = mid+1; ans = mid; continue; } if (now &gt;= n) { hi = mid-1; } } return ans;\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"11561. 징검다리","level":1,"id":"11561. 징검다리"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제","level":3,"id":"예제"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"이분탐색 풀이","level":3,"id":"이분탐색_풀이"}],"links":["1.-study/coding-test/algorithm/이분탐색.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/11561.-징검다리.html","pathToRoot":"../../..","attachments":["5.-file/image/pasted-image-20241030171506.png","5.-file/image/pasted-image-20241030173905.png"],"createdTime":1730239826270,"modifiedTime":1730334066965,"sourceSize":7881,"sourcePath":"1. Study/Coding Test/PS/11561. 징검다리.md","exportPath":"1.-study/coding-test/ps/11561.-징검다리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/11724.-연결-요소의-개수.html":{"title":"11724. 연결 요소의 개수","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-07-01<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/11724\" target=\"_self\">https://www.acmicpc.net/problem/11724</a>Level: s2Category: <br><a data-href=\"BFS, DFS\" href=\"1.-study/coding-test/algorithm/graph/bfs,-dfs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">BFS, DFS</a>Success: ⭕ +aGit: -방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.첫째 줄에 연결 요소의 개수를 출력한다.6 5\n1 2\n2 5\n5 1\n3 4\n4 626 8\n1 2\n2 5\n5 1\n3 4\n4 6\n5 4\n2 4\n2 31\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/seoo2001\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/seoo2001\" target=\"_self\">seoo2001</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/YunGoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/YunGoon\" target=\"_self\">YunGoon</a>\n<br>잘못된 조건을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/songjuh\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/songjuh\" target=\"_self\">songjuh</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/7\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/7\" target=\"_self\">그래프 이론</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/11\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/11\" target=\"_self\">그래프 탐색</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/126\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/126\" target=\"_self\">너비 우선 탐색</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/127\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/127\" target=\"_self\">깊이 우선 탐색</a>\nimport java.util.*; import java.io.*; public class Main { static int[][] gp; static int[] visited; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] line = br.readLine().split(\" \"); int N = Integer.parseInt(line[0]); // node 개수 int M = Integer.parseInt(line[1]); // 간선 개수 gp = new int[N + 1][N + 1]; visited = new int[N + 1]; for (int m = 0; m &lt; M; m++) { line = br.readLine().split(\" \"); int x = Integer.parseInt(line[0]); int y = Integer.parseInt(line[1]); gp[x][y] = 1; gp[y][x] = 1; } int cnt = 0; for (int n = 1; n &lt;= N; n++) { if (visited[n] == 0) { dfs(n); cnt ++; } } System.out.println(cnt); } static void dfs(int N) { visited[N] = 1; for (int i = 1; i &lt; gp.length; i++) { if (gp[N][i] == 1 &amp;&amp; visited[i] == 0) dfs(i); } } }\n복사bfs로도 풀어보기..","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"11724. 연결 요소의 개수","level":1,"id":"11724. 연결 요소의 개수"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":3,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":3,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":3,"id":"예제_출력_2 복사"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"}],"links":["1.-study/coding-test/ps/ps.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/11724.-연결-요소의-개수.html","pathToRoot":"../../..","attachments":[],"createdTime":1719819070201,"modifiedTime":1719824553068,"sourceSize":3192,"sourcePath":"1. Study/Coding Test/PS/11724. 연결 요소의 개수.md","exportPath":"1.-study/coding-test/ps/11724.-연결-요소의-개수.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/12865.-평범한-배낭.html":{"title":"12865. 평범한 배낭","icon":"","description":"<a href=\".?query=tag:코딩테스트\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#코딩테스트\">#코딩테스트</a><br>\n<a href=\".?query=tag:골드/5\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#골드/5\">#골드/5</a>이 문제는 아주 평범한 배낭에 관한 문제이다.한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.입력으로 주어지는 모든 수는 정수이다.한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.4 7\n6 13\n4 8\n3 6\n5 1214\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/Acka\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/Acka\" target=\"_self\">Acka</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/kpqi5858\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/kpqi5858\" target=\"_self\">kpqi5858</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/leedongbin\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/leedongbin\" target=\"_self\">leedongbin</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/riroan\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/riroan\" target=\"_self\">riroan</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/skyoliver\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/skyoliver\" target=\"_self\">skyoliver</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/25\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/25\" target=\"_self\">다이나믹 프로그래밍</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/148\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/148\" target=\"_self\">배낭 문제</a> 다이나믹 프로그래밍 문제 → 최적부분구조를 어떻게 증명할것인가… → 안될 것같은데 반례: (가치,무게) → (1, 1) (2, 1) (3, 1) (4, 1) (5, 4) / 최대 무게 4 인경우\n가치 5를 선택하는 것보다, 가치 4321을 선택하는 것이 더 큼. 단순히 무게가 초과하지 않는 한 가치가 높은 것부터 선택한다는 풀이는 잘못됨. (무게-가치)로 판단을 해볼까? → 안\n```python\nimport sys def backpack():\nN, K = map(int, sys.stdin.readline().split()) cnt = 0\nresult = 0\ninDict = {} while N &gt; 0:\nN -= 1\nw, v = map(int, sys.stdin.readline().split())\nif v - w not in inDict:\ninDict[v - w] = [w, v]\nelse:\ninDict[v - w] lst = sorted(inDict.keys(), key=lambda x: -x) for k, v in inDict.items():\nif v[0] &gt; K:\ncontinue result += v[1]\nK -= v[0] print(result) if name == \"main\":\nbackpack()- 같은 key에 추가… 하려면 복잡.. - 그냥 일단 다 돌려보자. 가능한 조합을 다? 시간 절대 안될 것같은데…\n- 복사","aliases":[],"inlineTags":["#코딩테스트","#골드/5"],"frontmatterTags":[],"headers":[{"heading":"12865. 평범한 배낭","level":1,"id":"12865. 평범한 배낭"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1 복사","level":2,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":2,"id":"예제_출력_1 복사"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"}],"links":["?query=tag:%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8","?query=tag:%EA%B3%A8%EB%93%9C/5"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/12865.-평범한-배낭.html","pathToRoot":"../../..","attachments":[],"createdTime":1709616141175,"modifiedTime":1709619282299,"sourceSize":3094,"sourcePath":"1. Study/Coding Test/PS/12865. 평범한 배낭.md","exportPath":"1.-study/coding-test/ps/12865.-평범한-배낭.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/15969.-행복.html":{"title":"15969. 행복","icon":"","description":"NAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>코이 초등학교에 새로 부임하신 교장 선생님은 어린 학생들의 행복감과 학생들의 성적 차이 관계를 알아보기로 했다. 그래서 이전 성적을 조사하여 학생 들의 시험 점수 차이 변화를 알아보려고 한다.예를 들어서 2016년 학생 8명의 점수가 다음과 같다고 하자.27, 35, 92, 75, 42, 53, 29, 87그러면 가장 높은 점수는 92점이고 가장 낮은 점수는 27점이므로 점수의 최대 차이는 65이다. 한편 2017년 학생 8명의 점수가 다음과 같았다.85, 42, 79, 95, 37, 11, 72, 32이때 가장 높은 점수는 95점이고 가장 낮은 점수는 11점이므로 점수의 최대 차이는 84이다.N명 학생들의 점수가 주어졌을 때, 가장 높은 점수와 가장 낮은 점수의 차이를 구하는 프로그램을 작성하시오표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 학생 수&nbsp;N이 주어진다. 다음 줄에는&nbsp;N명의 학생 점수가 공백 하나를 사이에 두고 주어진다.표준 출력으로 가장 높은 점수와 가장 낮은 점수의 차이를 출력한다.모든 서브태스크에서 2 ≤&nbsp;N&nbsp;≤ 1,000이고 입력되는 학생들의 점수는 0 이상 1,000 이하의 정수이다.학생 수가 2명인 경우만 존재한다.점수가 낮은 점수부터 높은 점수까지 순서대로 주어진다.원래의 제약 조건 이외에 아무 제약 조건이 없다.5\n27 35 92 75 42658\n85 42 79 95 37 11 72 3284<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/2\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/2\" target=\"_self\">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/55\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/55\" target=\"_self\">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/427\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/427\" target=\"_self\">KOI 2018</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/1894\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/1894\" target=\"_self\">초등부</a>&nbsp;1번\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/124\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/124\" target=\"_self\">수학</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/102\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/102\" target=\"_self\">구현</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/121\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/121\" target=\"_self\">사칙연산</a> <br>파이썬의 map(int, 어쩌구.split())을 java에서 사용하고 싶음… → <a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@suyyeon/JAVA-String-%EB%B0%B0%EC%97%B4%EC%9D%84-int-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@suyyeon/JAVA-String-%EB%B0%B0%EC%97%B4%EC%9D%84-int-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0\" target=\"_self\">[JAVA] String 배열을 int 배열로 변환하기</a>\nint[] gradeList = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n복사import java.io.*; import java.util.Arrays; public class Main { public void Solution() throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] gradeList = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray(); int max = -1; int min = 1001; for(int grade: gradeList) { if (grade &gt; max) { max = grade; } if (grade &lt; min) { min = grade; } } System.out.println(max-min); br.close(); } public static void main(String[] args) throws IOException { new Main().Solution(); } }\n복사\n이거 parsed int를 각각에서 하면 조금 시간을 줄일 수있지 않을까? → 와안전 조금 주넼ㅋㅋㅋ\npublic void Solution2_time() throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); String[] gradeList = br.readLine().split(\" \"); int max = -1; int min = 1001; for(String grade: gradeList) { int gradeInt = Integer.parseInt(grade); if (gradeInt &gt; max) { max = gradeInt; } if (gradeInt &lt; min) { min = gradeInt; } } System.out.println(max-min); br.close(); }\n복사","aliases":[],"inlineTags":[],"frontmatterTags":["#java","#브론즈/2"],"headers":[{"heading":"15969. 행복","level":1,"id":"15969. 행복"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"제한","level":2,"id":"제한"},{"heading":"서브태스크 1 (23점)","level":2,"id":"서브태스크_1_(23점)"},{"heading":"서브태스크 2 (29점)","level":2,"id":"서브태스크_2_(29점)"},{"heading":"서브태스크 3 (48점)","level":2,"id":"서브태스크_3_(48점)"},{"heading":"예제 입력 1 복사","level":2,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":2,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":2,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":2,"id":"예제_출력_2 복사"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"1차 성공","level":3,"id":"1차_성공"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/15969.-행복.html","pathToRoot":"../../..","attachments":[],"createdTime":1715732231782,"modifiedTime":1716651412737,"sourceSize":4706,"sourcePath":"1. Study/Coding Test/PS/15969. 행복.md","exportPath":"1.-study/coding-test/ps/15969.-행복.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/24228.-젓가락.html":{"title":"24228. 젓가락","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-28<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/24228\" target=\"_self\">https://www.acmicpc.net/problem/24228</a>Level: s4Category: 수학비둘기집 원리Success: ⭕Git: -젓가락통에&nbsp;𝑁&nbsp;종류의 젓가락이 종류별로 충분히 많이 들어있다. 당신은 이 젓가락통에서 무작위로 젓가락을 뽑아서&nbsp;𝑅개의 짝을 맞춰야 한다.&nbsp;최악의 경우 몇 개의 젓가락을 뽑아야 하는가?두 개의 정수&nbsp;𝑁,𝑅이 주어진다.&nbsp;(1≤𝑁,𝑅≤1018) 최악의 경우 뽑아야 하는 젓가락의 개수를 출력한다.2 13<br><img src=\"https://upload.acmicpc.net/c59e0233-6568-4aaa-91a1-e11c602a392d/-/preview/\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">2개만 뽑으면 짝이 0개일 가능성이 있다. 반면에 3개를 뽑으면 모든 경우에 대해서 짝이 최소 1개는 맞춰진다.<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/5\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/5\" target=\"_self\">University</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/409\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/409\" target=\"_self\">경인지역 6개대학 연합</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/2984\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/2984\" target=\"_self\">shake! 2021</a>&nbsp;A번\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/Coxie\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/Coxie\" target=\"_self\">Coxie</a>\n<br>문제를 검수한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/rhs0266\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/rhs0266\" target=\"_self\">rhs0266</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/spectaclehong\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/spectaclehong\" target=\"_self\">spectaclehong</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/124\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/124\" target=\"_self\">수학</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/189\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/189\" target=\"_self\">비둘기집 원리</a> N개중 1개 → 그외에 젓가락 → 그외의 젓가락 → (N-1번) → 짝 1개 → 2개 → 3개 → … → N개 N개를 뽑음. → A 젓가락 짝을 맞춤 → A젓가락 1개 뽑음 → A젓가락 두번째로 짝을 맞춤 N + (2*R) - 1 경우의 수 문제가 아니라 횟문제. 입력값을 int로 변환할때, 문제가 생김… 입력값이 최대 10^18이므로(2^31-1 보다 큼) long 타입으로 변수를 선언 import java.util.*;\nimport java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] line = br.readLine().split(\" \"); long N = Long.parseLong(line[0]); long R = Long.parseLong(line[1]); System.out.println(N + (R * 2) -1); br.close(); }\n}\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"24228. 젓가락","level":1,"id":"24228. 젓가락"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1 복사","level":2,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":2,"id":"예제_출력_1 복사"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"성공","level":3,"id":"성공"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/24228.-젓가락.html","pathToRoot":"../../..","attachments":[],"createdTime":1719554136584,"modifiedTime":1719557281531,"sourceSize":2842,"sourcePath":"1. Study/Coding Test/PS/24228. 젓가락.md","exportPath":"1.-study/coding-test/ps/24228.-젓가락.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/30804.-과일-탕후루.html":{"title":"30804. 과일 탕후루","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-07-03<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/30804\" target=\"_self\">https://www.acmicpc.net/problem/30804</a>Level: s2Category: two pointerSuccess: two pointer 공부하고 풀기은하는 긴 막대에&nbsp;개의 과일이 꽂혀있는 과일 탕후루를 만들었습니다. 과일의 각 종류에는&nbsp;부터&nbsp;까지의 번호가 붙어있고, 앞쪽부터 차례로번 과일이 꽂혀있습니다. 과일 탕후루를 다 만든 은하가 주문을 다시 확인해보니 과일을 두 종류 이하로 사용해달라는 요청이 있었습니다.탕후루를 다시 만들 시간이 없었던 은하는, 막대의 앞쪽과 뒤쪽에서 몇 개의 과일을 빼서 두 종류 이하의 과일만 남기기로 했습니다. 앞에서&nbsp;개, 뒤에서&nbsp;개의 과일을 빼면&nbsp;번 과일, 총&nbsp;개가 꽂혀있는 탕후루가 됩니다.&nbsp;&nbsp; 이렇게 만들 수 있는 과일을 두 종류 이하로 사용한 탕후루 중에서, 과일의 개수가 가장 많은 탕후루의 과일 개수를 구하세요.첫 줄에 과일의 개수&nbsp;𝑁이 주어집니다.&nbsp;(1≤𝑁≤200000) 둘째 줄에 탕후루에 꽂힌 과일을 의미하는&nbsp;개의 정수&nbsp;이 공백으로 구분되어 주어집니다.&nbsp; 문제의 방법대로 만들 수 있는 과일을 두 종류 이하로 사용한 탕후루 중에서, 과일의 개수가 가장 많은 탕후루의 과일 개수를 첫째 줄에 출력하세요.5\n5 1 1 2 14과일을 앞에서&nbsp;개, 뒤에서&nbsp;개의 과일을 빼면 남은 과일은&nbsp;번 과일이 꽂혀있는 탕후루가 됩니다. 과일의 개수는&nbsp;개입니다.3\n1 1 13탕후루가 이미 두 종류 이하의 과일로만 이루어져 있습니다.9\n1 2 3 4 5 6 7 8 92과일을 앞에서&nbsp;개, 뒤에서&nbsp;개의 과일을 빼면 남은 과일은&nbsp;번 과일이 꽂혀있는 탕후루가 됩니다. 과일의 개수는&nbsp;개입니다.<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/45\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/45\" target=\"_self\">Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/859\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/859\" target=\"_self\">solved.ac</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/1003\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/1003\" target=\"_self\">solved.ac Grand Arena #3</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/4059\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/4059\" target=\"_self\">Division 2</a>&nbsp;C번<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/45\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/45\" target=\"_self\">Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/859\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/859\" target=\"_self\">solved.ac</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/1003\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/1003\" target=\"_self\">solved.ac Grand Arena #3</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/4060\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/4060\" target=\"_self\">Division 1</a>&nbsp;A번\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/cologne\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/cologne\" target=\"_self\">cologne</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/havana723\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/havana723\" target=\"_self\">havana723</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/solvedac\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/solvedac\" target=\"_self\">solvedac</a>\n<br>문제를 검수한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/cologne\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/cologne\" target=\"_self\">cologne</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/cozyyg\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/cozyyg\" target=\"_self\">cozyyg</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/gs18115\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/gs18115\" target=\"_self\">gs18115</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/moonrabbit2\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/moonrabbit2\" target=\"_self\">moonrabbit2</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/seonah\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/seonah\" target=\"_self\">seonah</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/102\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/102\" target=\"_self\">구현</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/125\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/125\" target=\"_self\">브루트포스 알고리즘</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/80\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/80\" target=\"_self\">두 포인터</a>\nimport java.sql.SQLOutput; import java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); String[] temp = br.readLine().split(\" \"); List&lt;Integer&gt; stick = new LinkedList&lt;&gt;(); Map&lt;Integer, Integer&gt; fruit = new HashMap&lt;&gt;(); for (int n=0; n&lt;N; n++) { int key = Integer.parseInt(temp[n]); stick.add(key); if (fruit.containsKey(key)) { fruit.replace(key, fruit.get(key)); } else { fruit.put(key, 1); } } ListIterator&lt;Integer&gt; front = stick.listIterator(); ListIterator&lt;Integer&gt; back = stick.listIterator(N-1); int max = 0; int all = N; for (int i=0; i&lt;N; i++) { int nowF = front.next(); for (int j=0; j&lt;N; j++) { int } } } }\n복사\n바뀌는 부분에 인덱스를 요소로 가진 리스트를 따로 만들어 두는 거 어때?\n이중 포문 싫음.\nimport java.util.*; import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); String[] stick = br.readLine().split(\" \"); List&lt;Integer&gt; change = new ArrayList&lt;&gt;(); String before = \"0\"; String bbefore = \"0\"; for (int n=0; n&lt;N; n++) { if (!before.equals(stick[n])) { if (!bbefore.equals(stick[n])) { change.add(n); } bbefore = before; before = stick[n]; } } change.add(N); if (change.size() &lt; 3) { System.out.println(N); return; } int max = 0; for (int i=0; i&lt;change.size()-2; i++) { int p1 = change.get(i); int p2 = change.get(2+i); if (p2-p1 &gt; max) max = p2-p1; } System.out.println(max); } }\n복사 하나가 아니라 총 2개 까지 가능이니까, 동일한 과일끼리 연결되있는 것을 한 덩어리로 칠때, i 번째 덩어리의 과일이, i-1번째 덩어리의 과일과는 다르지만, i-2번째 덩어리 과일과는 동일 할 수도 있음. 그래서 before, bbefore 두개 체크하기로 했는데 이게 문제가 있는 듯. 그냥 map으로 과일 종류랑 같이 저장하는 거 어때? 순서대로 정렬하려면 linkedhashmap 쓰거나, hashmap에서 key set으로 정렬. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"30804. 과일 탕후루","level":1,"id":"30804. 과일 탕후루"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":3,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":3,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":3,"id":"예제_출력_2 복사"},{"heading":"예제 입력 3 복사","level":3,"id":"예제_입력_3 복사"},{"heading":"예제 출력 3 복사","level":3,"id":"예제_출력_3 복사"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"실패패","level":3,"id":"실패패"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/30804.-과일-탕후루.html","pathToRoot":"../../..","attachments":[],"createdTime":1720007296449,"modifiedTime":1720671742800,"sourceSize":6801,"sourcePath":"1. Study/Coding Test/PS/30804. 과일 탕후루.md","exportPath":"1.-study/coding-test/ps/30804.-과일-탕후루.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/42626.-더맵게.html":{"title":"42626. 더맵게","icon":"","description":"<a data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">1. Study/Coding Test/PS/PS.md</a>매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)\n복사Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.\nLeo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.\nscoville의 길이는 2 이상 1,000,000 이하입니다.\nK는 0 이상 1,000,000,000 이하입니다.\nscoville의 원소는 각각 0 이상 1,000,000 이하입니다.\n모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다. 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\n새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5\n가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]\n스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.\n새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13\n가진 음식의 스코빌 지수 = [13, 9, 10, 12]\n모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.\n<br>참고: <a data-tooltip-position=\"top\" aria-label=\"https://wrtn.ai/chat/u/65d591e80c06023ae70af73a/c/66508d0cdd60135f5bf99c8e?type=u\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://wrtn.ai/chat/u/65d591e80c06023ae70af73a/c/66508d0cdd60135f5bf99c8e?type=u\" target=\"_self\">뤼튼</a>\n: if (minA == null || minB == null) {\nnull과 int를 비교하여 생긴 문제.\n원래 목적: 우선순위 큐에서 poll()은 첫 번째 값을 반환하고&nbsp;제거, 비어있으면&nbsp;null을 반환하기 때문에 반환값이 null인 경우를 체크하려고 했다.\n우선순위 큐에 담겨있는 값은 Integer라서 Integer 대신 int 사용. → 이유: 익숙해서… 문제: int는 reference type이 아닌 primitive type이기 때문에 null이 안 됨…\n해결방안 int 대신 Integer(wrapper class) 사용 /*\n목표: 모든 음식의 스코빌 지수 &gt; K;\n방법: 스코빌 지수가 가장 낮은 두개의 음식으로 새 음식을 만들기; - 최소 힙 이용(by 우선순위 큐)\n*/ import java.util.*;\nclass Solution { public int solution(int[] scoville, int K) { PriorityQueue&lt;Integer&gt; hp = new PriorityQueue&lt;&gt;(); for (int s: scoville) { hp.add(s); } int cnt = 0; Integer minA; Integer minB; while (true) { minA = hp.poll(); minB = hp.poll(); if (minA == null || minB == null) { return -1; } if (minA &gt;= K) { return cnt; } int newFood = minA + (minB * 2); hp.add(newFood); cnt += 1; } }\n}\n복사\n정확성 테스트 3개 정도 실패\n원인 <br>16, 22, 23 문제는 제공된 scoville이 2개인 경우에 대한 테스트입니다. (<a data-tooltip-position=\"top\" aria-label=\"https://school.programmers.co.kr/questions/50794\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/questions/50794\" target=\"_self\">질문글 참고</a> / <a data-href=\"42626. 더맵게#테스트 케이스 추가 팁\" href=\"1.-study/coding-test/ps/42626.-더맵게.html#테스트_케이스_추가_팁\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">42626. 더맵게 &gt; 테스트 케이스 추가 팁</a>)\nnull check가 먼저 이루어지면서 문제가 생김 → 새로 뽑은 수가 null인데 이미, 조건(K 이상)을 만족했을 때\n단순히 null 체크와 조건 체크 순서를 바꾸면 minA가 null일 때 문제가 생김. 수 하나는 무조건 큐에 추가되기 때문에 minA가 null일 리는 없음\n처음 주어지는 input도 2개 이상. /*\n목표: 모든 음식의 스코빌 지수 &gt; K;\n방법: 스코빌 지수가 가장 낮은 두개의 음식으로 새 음식을 만들기; - 최소 힙 이용(by 우선순위 큐)\n*/ import java.util.*;\nclass Solution { public int solution(int[] scoville, int K) { PriorityQueue&lt;Integer&gt; hp = new PriorityQueue&lt;&gt;(); for (int s: scoville) { hp.add(s); } int cnt = 0; Integer minA; Integer minB; while (true) { // 가장 스코빌 지수가 낮은 음식 2개 minA = hp.poll(); minB = hp.poll(); // 조건 체크1 (문제 조건상 항상 minA != null 만족) if (minA &gt;= K) { return cnt; } // 조건 체크2 if (minB == null) { return -1; } // 새로운 음식 추가 및, 시도 횟수 늘리기. int newFood = minA + (minB * 2); hp.add(newFood); cnt += 1; } }\n}\n복사\n기본 테스트 케이스: 문제에서 주어진 예제 테스트 케이스부터 실행해 보세요.\n경계값 테스트: 입력 값의 최소, 최대 경계에서의 동작을 확인하세요. 예를 들어, 비밀번호의 길이가 최대(6자리) 또는 최소(1자리)일 때의 동작을 확인해 보세요.\n특별한 경우 테스트: 일반적이지 않은 입력값이나 특별한 상황에서의 동작을 확인해 보세요. 예를 들어, DB가 비어있는 경우나, 같은 비밀번호를 가진 여러 회원이 있는 경우 등입니다.\n랜덤한 테스트: 여러 다양한 입력 조건에서의 동작을 확인하기 위해 랜덤한 입력값을 사용한 테스트 케이스를 추가해 보세요.\n순차적 테스트: 입력값이 특정 순서에 따라 동작을 확인하는 테스트 케이스를 추가해 보세요. 예를 들어, DB에 회원 정보가 아이디 순서나 비밀번호 순서에 따라 정렬된 경우 등입니다\n","aliases":[],"inlineTags":[],"frontmatterTags":["#java","#programmers","#lv2"],"headers":[{"heading":"42626. 더맵게","level":1,"id":"42626. 더맵게"},{"heading":"문제 설명","level":2,"id":"문제_설명"},{"heading":"제한 사항","level":3,"id":"제한_사항"},{"heading":"입출력 예","level":3,"id":"입출력_예"},{"heading":"입출력 예 설명","level":3,"id":"입출력_예_설명"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"오류: bad operand types for binary operator '=='","level":3,"id":"오류_bad_operand_types_for_binary_operator_'\\=='"},{"heading":"실패","level":3,"id":"실패"},{"heading":"+) 테스트 케이스 추가 팁:","level":4,"id":"+)_테스트_케이스_추가_팁"}],"links":["1.-study/coding-test/ps/ps.html","1.-study/coding-test/ps/42626.-더맵게.html#테스트_케이스_추가_팁"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/42626.-더맵게.html","pathToRoot":"../../..","attachments":[],"createdTime":1716551190919,"modifiedTime":1717120436046,"sourceSize":6592,"sourcePath":"1. Study/Coding Test/PS/42626. 더맵게.md","exportPath":"1.-study/coding-test/ps/42626.-더맵게.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/42746.-가장-큰-수.html":{"title":"42746. 가장 큰 수","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-05-26<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42746\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42746</a><br>Category: <a data-href=\"Sort\" href=\"Sort\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">Sort</a>Success: -Git: -0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.\nnumbers의 길이는 1 이상 100,000 이하입니다.\nnumbers의 원소는 0 이상 1,000 이하입니다.\n정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다. 가장 앞자리 숫자끼리 비교해야함. String으로 바꿔서 인덱스로 접근 숫자가 같은 경우 다음 숫자를 비교 다음 숫자가 없을 경우 다른 요소의 첫번째 숫자와 비교. (이때는 비교중인 상대 정수도 포함.) 필요 없겠다. 이미 큰 수는 앞에서 사용했으니까. String으로 만들어 정렬하면 그냥 되지 않을까? 3,30,34,5,9 -&gt; 9,5,34,3(3),30\n이런식으로 정렬되도록 comparator 구 convert int[] to String[], 간단한 버전 <br><a data-tooltip-position=\"top\" aria-label=\"https://makemepositive.tistory.com/6\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://makemepositive.tistory.com/6\" target=\"_self\">[Java] String to Integer, Integer to String — 성장을 공유하는 개발자</a> comparator vs comparable <br><a data-tooltip-position=\"top\" aria-label=\"https://st-lab.tistory.com/243\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://st-lab.tistory.com/243\" target=\"_self\">자바 [JAVA] - Comparable 과 Comparator의 이해</a> import java.util.*; class Solution { public String solution(int[] numbers) { String answer = \"\"; String[] strNums = Arrays.stream(numbers) .mapToObj(String::valueOf) .toArray(String[]::new); Arrays.sort(strNums, new BigNumComparator()); for (String str: strNums) { answer += str; } return answer; }\n} class BigNumComparator implements Comparator&lt;String&gt; { public int compare(String s1, String s2) { int i = 0; while (i &lt; Math.max(s1.length(), s2.length())) { char c1, c2; if (i &lt; s1.length()) c1 = s1.charAt(i); else c1 = s1.charAt(s1.length() - 1); if (i &lt; s2.length()) c2 = s2.charAt(i); else c2 = s2.charAt(s2.length() - 1); if (c1 - c2 == 0) i += 1; else return -(c1-c2); } return 0; }\n}\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"42746. 가장 큰 수","level":1,"id":"42746. 가장 큰 수"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제 설명","level":5,"id":"문제_설명"},{"heading":"제한 사항","level":5,"id":"제한_사항"},{"heading":"입출력 예","level":5,"id":"입출력_예"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"정보","level":3,"id":"정보"},{"heading":"실패","level":3,"id":"실패"}],"links":["1.-study/coding-test/ps/ps.html","Sort"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/42746.-가장-큰-수.html","pathToRoot":"../../..","attachments":[],"createdTime":1716720709099,"modifiedTime":1717120388344,"sourceSize":3065,"sourcePath":"1. Study/Coding Test/PS/42746. 가장 큰 수.md","exportPath":"1.-study/coding-test/ps/42746.-가장-큰-수.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/42747.-h-index.html":{"title":"42747. H-Index","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-05-27<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42747\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42747</a>Level: lv2<br>Category: <a data-href=\"Sort\" href=\"Sort\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">Sort</a>Success: Git: -<br>H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과<a data-tooltip-position=\"top\" aria-label=\"https://school.programmers.co.kr/learn/courses/30/lessons/42747#fn1\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42747#fn1\" target=\"_self\">1</a>에 따르면, H-Index는 다음과 같이 구합니다.어떤 과학자가 발표한 논문&nbsp;n편 중,&nbsp;h번 이상 인용된 논문이&nbsp;h편 이상이고 나머지 논문이 h번 이하 인용되었다면&nbsp;h의 최댓값이 이 과학자의 H-Index입니다.어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.\n과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.\n논문별 인용 횟수는 0회 이상 10,000회 이하입니다.\n이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다.<br>힌트가 필요한가요? [코딩테스트 연습 힌트 모음집]으로 오세요! →&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://school.programmers.co.kr/learn/courses/14743?itm_content=lesson42747\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/14743?itm_content=lesson42747\" target=\"_self\">클릭</a>※ 공지 - 2019년 2월 28일 테스트 케이스가 추가되었습니다.\nArrays.sort(citations, Collections.reverseOrder()); 사용 불가 primitive type이라 comparator가 없음.\nArrays.sort() vs Collections.sort() <br><a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@minizero0/Arrays.sort%EC%99%80-Collections.sort\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@minizero0/Arrays.sort%EC%99%80-Collections.sort\" target=\"_self\">Arrays.sort()와 Collections.sort()</a> ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"42747. H-Index","level":1,"id":"42747. H-Index"},{"heading":"문제 설명","level":6,"id":"문제_설명"},{"heading":"제한사항","level":5,"id":"제한사항"},{"heading":"입출력 예","level":5,"id":"입출력_예"},{"heading":"입출력 예 설명","level":5,"id":"입출력_예_설명"},{"heading":"문제가 잘 안풀린다면😢","level":5,"id":"문제가_잘_안풀린다면😢"},{"heading":"풀이","level":3,"id":"풀이"}],"links":["1.-study/coding-test/ps/ps.html","Sort"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/42747.-h-index.html","pathToRoot":"../../..","attachments":[],"createdTime":1716813153943,"modifiedTime":1717120369198,"sourceSize":2210,"sourcePath":"1. Study/Coding Test/PS/42747. H-Index.md","exportPath":"1.-study/coding-test/ps/42747.-h-index.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/42839.-소수-찾기.html":{"title":"42839. 소수 찾기","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-05-29<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42839\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42839</a>Level: lv2<br>Category: <a data-href=\"Search\" href=\"Search\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">Search</a>Success: -Git: -한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.\nnumbers는 길이 1 이상 7 이하인 문자열입니다.\nnumbers는 0~9까지 숫자만으로 이루어져 있습니다.\n\"013\"은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.\n예제 #1\n[1, 7]으로는 소수 [7, 17, 71]를 만들 수 있습니다.예제 #2\n[0, 1, 1]으로는 소수 [11, 101]를 만들 수 있습니다.\n11과 011은 같은 숫자로 취급합니다. 다 만들고 체크…. 해도 되려나?\n만들기는 몇중 for문을 해야하는 거야? → 굳이 만들고 다시 돌릴 필요 없을 듯.\n중복 체크 11 == 011 → int로 바꾸면 될일.\n정렬해두고 앞이랑 같으면 탐색하지 않고 넘어가는 걸로. 소수 판별: java의 isPrime() 함수…! (있는지 몰랐다… 파이썬은 없었던거 같은데…)\n소수 판변부분이 간단하니까 그냥 바로바로 체크해서 넘어가도 될듯.\nint cnt = 0;\nint loop = numbers.length;\nprivate void countPrime (int[] numList, String offset){ private int[] newNumList = new int[]; for (int num : numList) { if (num.isPrime()) cnt += 1; for(String o : offset) { newNumList.push(num*10 +o); } } if (loop != 0) countPrime(newNumList, offset); else return;\n} 복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"42839. 소수 찾기","level":1,"id":"42839. 소수 찾기"},{"heading":"문제","level":3,"id":"문제"},{"heading":"문제 설명","level":6,"id":"문제_설명"},{"heading":"제한사항","level":5,"id":"제한사항"},{"heading":"입출력 예","level":5,"id":"입출력_예"},{"heading":"입출력 예 설명","level":5,"id":"입출력_예_설명"},{"heading":"풀이","level":3,"id":"풀이"}],"links":["1.-study/coding-test/ps/ps.html","Search"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/42839.-소수-찾기.html","pathToRoot":"../../..","attachments":[],"createdTime":1716949533159,"modifiedTime":1717120295200,"sourceSize":2185,"sourcePath":"1. Study/Coding Test/PS/42839. 소수 찾기.md","exportPath":"1.-study/coding-test/ps/42839.-소수-찾기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/42842.-카펫.html":{"title":"42842. 카펫","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"42842. 카펫","level":1,"id":"42842. 카펫"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/42842.-카펫.html","pathToRoot":"../../..","attachments":[],"createdTime":1716862229737,"modifiedTime":1730155389162,"sourceSize":49,"sourcePath":"1. Study/Coding Test/PS/42842. 카펫.md","exportPath":"1.-study/coding-test/ps/42842.-카펫.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/42860.-조이스틱.html":{"title":"42860. 조이스틱","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-04<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42860\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42860</a>Level: lv2Category: greedySuccess: -Git: -조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.\nex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA조이스틱을 각 방향으로 움직이면 아래와 같습니다.▲ - 다음 알파벳\n▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)\n◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)\n▶ - 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 이동하면 첫 번째 문자에 커서)\n복사예를 들어 아래의 방법으로 \"JAZ\"를 만들 수 있습니다.- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.\n- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.\n- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.\n따라서 11번 이동시켜 \"JAZ\"를 만들 수 있고, 이때가 최소 이동입니다.\n복사만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.\nname은 알파벳 대문자로만 이루어져 있습니다.\nname의 길이는 1 이상 20 이하입니다.\n/** * 그냥 차례대로... */\nclass Solution { public int solution(String name) { int row_cnt = name.length() -1; int col_cnt = 0; for (int i=0; i&lt;name.length(); i++) { col_cnt += Math.min(91 - ((int) name.charAt(i)), ((int) name.charAt(i)) - 65); System.out.println(Math.min(91 - ((int) name.charAt(i)), ((int) name.charAt(i)) - 65)); } return row_cnt + col_cnt; }\n}\n복사\n이렇게 작성하는 코드가 더 간단해보여서 좌우로 커서 움직이는 걸 그냥 name 길이로 넣어줬는데, 이러면 뒤에 굳이 안바꿔도 되는 문자열이 위치했을 때 문제가 생김.\n좌우움직임을 안 신경씀…\n/** * 그냥 차례대로... */\nclass Solution { public int solution(String name) { int row_min = name.length(); int row_max = 0; int col_cnt = 0; for (int i=0; i&lt;name.length(); i++) { int ascii = (int) name.charAt(i); // col col_cnt += Math.min(91 - ascii, ascii - 65); // row if (i != 0 &amp;&amp; ascii != 65) { if (row_min &gt; i) row_min = i; if (row_max &lt; i) row_max = i; } } int answer = col_cnt + Math.min(name.length() - row_min, row_max); return answer; }\n}\n복사\n반례:|\"BBABAAAABBBAAAABABB\" 〉 26| //27 출력\n어머. 시작 위치를 마음대로 할 수 있는건가? → 아님\n/** * 그냥 차례대로... */\nclass Solution { public int solution(String name) { // initial state int len = name.length(); int rowL = 0; // 왼쪽으로 갔을 때 가장 끝 인덱스 (오른쪽에서 가장 가까운 변할 문자) int rowR = 0; // 오른쪽으로 갔을 때 가장 끝 인덱스 (왼쪽에서 가장 가까운 변할 문자) for (int i=len-1; i &gt;= 0; i--) { if (name.charAt(i) != 'A') { rowR = i-len; break; } } System.out.println(\"init: \" + rowL +\", \" + rowR); int row_cnt = len; int col_cnt = 0; for (int i=0; i&lt;len; i++) { int ascii = (int) name.charAt(i); // col col_cnt += Math.min(91 - ascii, ascii - 65); System.out.println(Math.min(91 - ascii, ascii - 65)); // row //// check rowL for now if (rowL%len &lt;= i) { for (int j=i+1; j&lt;i+len; j++) { int idx = j% len; if (name.charAt(idx) != 'A') { rowL = j; break; } } } //// min value of row int distanceToR = len + rowR - i; int distanceToL = i + len -rowL; int rowMin = Math.min(distanceToR, distanceToL); if (rowMin &lt; row_cnt) row_cnt = rowMin; System.out.println(\"point: \" + rowR + \" | \" + rowL); System.out.println(\"distance: \"+distanceToR + \" | \" + distanceToL); System.out.println(); //// check rowR for next if (ascii != 65) rowR = i; } return col_cnt + row_cnt; }\n}\n복사 완전 잘못이해 했어요… 시작은 0에서 왔다리 갔다리를 할 수 있는 거였을 뿐임. 경우의 수가 왼쪽으로만 가는 경우\n오른쪽으로만 가능 경우\n(짧은) 오른쪽 다녀와서 왼쪽으로 가는 경우\n(짧은) 왼쪽 다녀와서 오른쪽으로 가능 경우 구체적인 수치… 다 구해서 비교..?\n관점을 ‘나눠지는 부분’에 두는 게 좋을 듯. ABAAAABB 오왼왼왼\n오오오오오오오 ABAAABBA 오왼왼왼왼\n오오오오오오 → A가 있는 곳에서 나누어짐 +) 시작이 A와 접해있는지. → 한쪽방향으로만 이동해도 범위가 줄어들 가능성이 큼.\n반대의 경우에는 한쪽방향으로만 이동하면 이동범위가 줄어들 수 없음 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"42860. 조이스틱","level":1,"id":"42860. 조이스틱"},{"heading":"문제","level":3,"id":"문제"},{"heading":"문제 설명","level":5,"id":"문제_설명"},{"heading":"제한 사항","level":5,"id":"제한_사항"},{"heading":"입출력 예","level":5,"id":"입출력_예"},{"heading":"풀이","level":3,"id":"풀이"},{"heading":"실패 → 59","level":4,"id":"실패_→_59"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/42860.-조이스틱.html","pathToRoot":"../../..","attachments":[],"createdTime":1717488213595,"modifiedTime":1717560532355,"sourceSize":6074,"sourcePath":"1. Study/Coding Test/PS/42860. 조이스틱.md","exportPath":"1.-study/coding-test/ps/42860.-조이스틱.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/42885.-구명보트.html":{"title":"42885. 구명보트","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-05<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/42885\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/42885</a>Level: lv2Category: greedySuccess: ⭕Git: -무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대&nbsp;2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.\n무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.\n각 사람의 몸무게는 40kg 이상 240kg 이하입니다.\n구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.\n구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.\nimport java.util.*; class Solution { public int solution(int[] people, int limit) { int answer = 0; Arrays.sort(people); int ir = 0; for (int i=people.length-1; i&gt;=0; i--) { // 가장 많이 가져가는 걸 일단 목표로 해보자. int inBoat = people[i]; while (inBoat &lt;= limit) { int possible = limit - inBoat; if (people[ir] &lt;= possible) { inBoat += people[ir]; ir += 1; continue; } break; } answer += 1; System.out.println(inBoat); if (ir &gt;= i) { break; } } return answer; }\n}\n복사 후반부 문제들 다 틀림 → 런타임 에러 시간 부족도 해결해야 함 아놔… 2명씩 밖에 탈 수 없고 라네… import java.util.*; class Solution { public int solution(int[] people, int limit) { int answer = 0; Arrays.sort(people); int ir = 0; for (int i=people.length-1; i&gt;=0; i--) { // 사용한 건 -1fh qkRnrl // 가장 많이 가져가는 걸 일단 목표로 해보자. int inBoat = people[i]; int possible = limit - inBoat; if (possible &gt;= people[ir]) { ir += 1; } answer += 1; if (ir &gt;= i) { break; } } return answer; }\n} 복사\nQ: 문제 풀이 아이디어가\n(1) 가장 무거운 사람 + (추가로 태울 수 있다면) 가장 가벼운 사람인데..\n저는 (2) 가장 무거운 사람 + 추가로 태울 수 있는 사람 중 가장 무거운 사람\n이 정답일 거라고 생각했거든요 ((2)도 효율성 제외하면 테케가 다 맞긴 합니다)\n(1)이 왜 정답인지 직관적으로 이해가 잘 되지 않습니다\n혹시 이유를 설명해주실 분 계실까요 A: 저도 그렇게 생각했다가, 어차피 한 배에 두 명 밖에 못태우기 때문에 꼭 두번째 무거운 사람을 뽑아야 할 이유가 없기 때문에 구현이 간단한 (1)번 아이디어로 한다고 생각했어요.\n예를 들어 [40,30,20,10]의 무게 사람이 있고 보트의 최대 무게가 70인 상황을 가정했을때, 40과 같이 태울 사람을 뽑을때 두번째로 무거운 30을 뽑아도 어차피 가벼운 사람 [20, 10] 두명이서 두 번째 보트를 타야하기 때문에 처음에 뽑을 때 굳이 가벼운 사람을 아껴둘 필요가 없다.(?) 라고 생각했어요.\n만약에 보트 당 탈 수 있는 사람 수에 제한이 없으면, 공간을 처음부터 최대한 빡빡히 넣어서 두번째 보트를 꾸릴때 더 많은 명수를 넣을 수 있다는 이득을 취할 수 있기 때문에 (2)번 아이디어로 풀어야 하겠죠.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"42885. 구명보트","level":1,"id":"42885. 구명보트"},{"heading":"문제","level":3,"id":"문제"},{"heading":"문제 설명","level":6,"id":"문제_설명"},{"heading":"제한사항","level":5,"id":"제한사항"},{"heading":"입출력 예","level":5,"id":"입출력_예"},{"heading":"풀이","level":3,"id":"풀이"},{"heading":"실패","level":4,"id":"실패"},{"heading":"성공","level":3,"id":"성공"},{"heading":"+) 참고할 QnA","level":6,"id":"+)_참고할_QnA"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/42885.-구명보트.html","pathToRoot":"../../..","attachments":[],"createdTime":1717560281740,"modifiedTime":1717655089794,"sourceSize":4867,"sourcePath":"1. Study/Coding Test/PS/42885. 구명보트.md","exportPath":"1.-study/coding-test/ps/42885.-구명보트.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/43165.-타겟넘버.html":{"title":"43165. 타겟넘버","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-05-31<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/43165\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/43165</a>Level: lv2<br>Category: <a data-href=\"BFS, DFS\" href=\"1.-study/coding-test/algorithm/graph/bfs,-dfs.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">BFS, DFS</a>Success: ⭕Git: -n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n복사사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.\n주어지는 숫자의 개수는 2개 이상 20개 이하입니다.\n각 숫자는 1 이상 50 이하인 자연수입니다.\n타겟 넘버는 1 이상 1000 이하인 자연수입니다.\n입출력 예 #1문제 예시와 같습니다.입출력 예 #2+4+1-2+1 = 4\n+4-1+2-1 = 4\n복사\n총 2가지 방법이 있으므로, 2를 return 합니다. 특정 알고리즘을 사용한다기보단, 문제 해결에 초점을 맞추는 게 더 효율적일 때도 있음.\n<br>파라미터로 넘기기 귀찮아서 전역변수를 종종 썼었는데 좋지 않은 습관임 (<a data-tooltip-position=\"top\" aria-label=\"https://jaehoney.tistory.com/75\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://jaehoney.tistory.com/75\" target=\"_self\">참고</a>)\nclass Solution { public int solution(int[] numbers, int target) { int idx = 0; int cnt = checkTarget(numbers, target, 0, 0); return cnt; } private int checkTarget(int [] numbers, int target, int idx, int num) { if (idx == numbers.length) { if (num == target) return 1; else return 0; } return checkTarget(numbers, target, idx+1, num+numbers[idx]) + checkTarget(numbers, target, idx+1, num-numbers[idx]); }\n}\n복사\n파라미터가 많을 때는 여기서 기본적인 실수를 많이 함… 잘 체크하기.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"43165. 타겟넘버","level":1,"id":"43165. 타겟넘버"},{"heading":"문제","level":3,"id":"문제"},{"heading":"문제 설명","level":6,"id":"문제_설명"},{"heading":"제한사항","level":5,"id":"제한사항"},{"heading":"입출력 예","level":5,"id":"입출력_예"},{"heading":"입출력 예 설명","level":5,"id":"입출력_예_설명"},{"heading":"풀이","level":3,"id":"풀이"}],"links":["1.-study/coding-test/ps/ps.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/43165.-타겟넘버.html","pathToRoot":"../../..","attachments":[],"createdTime":1717117448306,"modifiedTime":1717121517595,"sourceSize":2457,"sourcePath":"1. Study/Coding Test/PS/43165. 타겟넘버.md","exportPath":"1.-study/coding-test/ps/43165.-타겟넘버.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/49191.-순위.html":{"title":"49191. 순위","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-06-13<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/49191\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/49191</a>Level: lv3Category: <br><a data-href=\"Graph\" href=\"1.-study/coding-test/algorithm/graph/graph.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Graph</a>Success: ⭕Git: -n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.\n선수의 수는 1명 이상 100명 이하입니다.\n경기 결과는 1개 이상 4,500개 이하입니다.\nresults 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다.\n모든 경기 결과에는 모순이 없습니다.\n2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다.\n5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.\n<br>내가 모르는 알고리즘임. 구글링 → <a data-tooltip-position=\"top\" aria-label=\"https://chanhuiseok.github.io/posts/algo-50/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://chanhuiseok.github.io/posts/algo-50/\" target=\"_self\">플로이드 - 워</a>\nclass Solution { public int solution(int n, int[][] results) { int answer = 0; int[][] rank = new int[n][n]; for (int[] r: results) { // 초기 배열 rank[r[0]-1][r[1]-1] = 1; // 이겼을때 rank[r[1]-1][r[0]-1] = -1; // 졌을때 } for (int k=0; k&lt;n; k++) { // k = 중간노드 역할 for (int i=0; i&lt;n; i++) { for (int j=0; j&lt;n; j++) { if (rank[i][k]==-1 &amp;&amp; rank[k][j]==-1) { // i는 k한테 졌고, k는 j한테 졌을 때 =&gt; i&lt;k&lt;j = i&lt;j rank[i][j] = -1; rank[j][i] = 1; } } } } for (int i=0; i&lt;n; i++) { int zero = 1; // 자기자신과의 승률만 0인 경우 해당 player의 순위를 명확히 알 수 있음 for (int j=0; j&lt;n; j++) { if (rank[i][j] == 0) zero -= 1; } if (zero == 0) answer += 1; } return answer; }\n}\n복사\n처음에는 1,1일 때 1지정 -1,-1일때 -1 지정 따로해주려고 했지만, 생각해보니 그럴 필요없음… 이긴쪽(1) 반대편이 무조건 진쪽(-1)이니까\n정확하게 순위를 매길 수 있는 선수의 수 = rank 배열이 다 찼을때.\n+) 위상정렬?+) bfs, dfs는 사실 같음.. 재귀로 푸냐, 큐로 푸냐.. / 재귀로 푸는(dfs)는 안되는 문제들도 있음..\nbfs가 제일간단하고 빠르고 대중적…","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"49191. 순위","level":1,"id":"49191. 순위"},{"heading":"문제","level":3,"id":"문제"},{"heading":"문제 설명","level":6,"id":"문제_설명"},{"heading":"제한사항","level":5,"id":"제한사항"},{"heading":"입출력 예","level":5,"id":"입출력_예"},{"heading":"입출력 예 설명","level":5,"id":"입출력_예_설명"},{"heading":"풀이","level":3,"id":"풀이"},{"heading":"성공","level":4,"id":"성공"}],"links":["1.-study/coding-test/ps/ps.html","1.-study/coding-test/algorithm/graph/graph.html","4, 3], [4, 2], [3, 2], [1, 2], [2, 5"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/49191.-순위.html","pathToRoot":"../../..","attachments":[],"createdTime":1718280612048,"modifiedTime":1718286867387,"sourceSize":3466,"sourcePath":"1. Study/Coding Test/PS/49191. 순위.md","exportPath":"1.-study/coding-test/ps/49191.-순위.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/84512.-모음사전.html":{"title":"84512. 모음사전","icon":"","description":"\nNAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a>\nDate: 2024-04-20<br>Link: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://school.programmers.co.kr/learn/courses/30/lessons/84512\" target=\"_self\">https://school.programmers.co.kr/learn/courses/30/lessons/84512</a>Level: lv2<br>Category: <a data-href=\"Search\" href=\"Search\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">Search</a>Success: Git: -사전에 알파벳 모음 'A', 'E', 'I', 'O', 'U'만을 사용하여 만들 수 있는, 길이 5 이하의 모든 단어가 수록되어 있습니다. 사전에서 첫 번째 단어는 \"A\"이고, 그다음은 \"AA\"이며, 마지막 단어는 \"UUUUU\"입니다.단어 하나 word가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째 단어인지 return 하도록 solution 함수를 완성해주세요.\nword의 길이는 1 이상 5 이하입니다.\nword는 알파벳 대문자 'A', 'E', 'I', 'O', 'U'로만 이루어져 있습니다.\n입출력 예 #1사전에서 첫 번째 단어는 \"A\"이고, 그다음은 \"AA\", \"AAA\", \"AAAA\", \"AAAAA\", \"AAAAE\", ... 와 같습니다. \"AAAAE\"는 사전에서 6번째 단어입니다.입출력 예 #2\"AAAE\"는 \"A\", \"AA\", \"AAA\", \"AAAA\", \"AAAAA\", \"AAAAE\", \"AAAAI\", \"AAAAO\", \"AAAAU\"의 다음인 10번째 단어입니다.입출력 예 #3\"I\"는 1563번째 단어입니다.입출력 예 #4\"EIO\"는 1189번째 단어입니다. 만들고 탐색하거나…. 이건 tree인데… 깊이 우선 탐색\ntree\nroot\na e i o u\na e i o u\n… 근데 다 탐색 안하고 level 별로 자식 개수가 정해져 있으니까, 그냥 그거 더하면 안되나? ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"84512. 모음사전","level":1,"id":"84512. 모음사전"},{"heading":"문제","level":3,"id":"문제"},{"heading":"문제 설명","level":6,"id":"문제_설명"},{"heading":"제한사항","level":5,"id":"제한사항"},{"heading":"입출력 예","level":5,"id":"입출력_예"},{"heading":"입출력 예 설명","level":5,"id":"입출력_예_설명"},{"heading":"풀이","level":3,"id":"풀이"}],"links":["1.-study/coding-test/ps/ps.html","Search"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/84512.-모음사전.html","pathToRoot":"../../..","attachments":[],"createdTime":1716862229737,"modifiedTime":1716864631873,"sourceSize":1839,"sourcePath":"1. Study/Coding Test/PS/84512. 모음사전.md","exportPath":"1.-study/coding-test/ps/84512.-모음사전.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/개인정보-수집-유효기간.html":{"title":"개인정보 수집 유효기간","icon":"","description":"Site: 프로그래머스\n난이도: Lv 1\n다시풀기: No\n분류: 2023, Blind Recruitment, kakao\n생성 일시: 2023년 3월 10일 오후 4:36def solution(today, terms, privacies): answer = [] # terms to Dict terms_dict = {} for i in terms: cate = i.split()[0] term = int(i.split()[1]) terms_dict[cate] = term # privacies date processing num = 0 for i in privacies: num += 1 date, cate = map(str, i.split()) py, pm, pd = map(int, date.split('.')) ty, tm, td = map(int, today.split('.')) due_month = (pm + terms_dict[cate]) % 12 due_year = py + ((pm + terms_dict[cate]) // 12) if due_month == 0: due_month = 12 due_year -= 1 # print((pm + terms_dict[cate]) // 12) print(due_month, due_year) if due_year &lt; ty: answer.append(num) elif due_year &gt; ty: None else: if due_month &lt; tm: answer.append(num) elif due_month &gt; tm: None else: if pd &lt;= td: answer.append(num) return answer\n복사: 이걸 쓸 수도 있지 않았을까?\ndatetime.timedelta(days=0,&nbsp;seconds=0,&nbsp;microseconds=0,&nbsp;milliseconds=0,&nbsp;minutes=0,&nbsp;hours=0,&nbsp;weeks=0) 시간계산\nyears가 없네…\n주의: overflow datetime.fromisoformat(string) string 객체를 datetime 형식으로 변환 def to_days(date): year, month, day = map(int, date.split(\".\")) return year * 28 * 12 + month * 28 + day def solution(today, terms, privacies): months = {v[0]: int(v[2:]) * 28 for v in terms} today = to_days(today) expire = [ i + 1 for i, privacy in enumerate(privacies) if to_days(privacy[:-2]) + months[privacy[-1]] &lt;= today ] return expire\n복사\n자주 쓰는 코드 따로 function으로 빼줘서 간다하게하기\n간단하게 사용하는 for문 기억해두기 (꼭?)\n# 예시\n[i for i in list()]\n{j:j for j in list()}\n복사 def solution(today, terms, privacies): answer = [] termdict = {} for term in terms: t = term.split(' ') termdict[t[0]] = int(t[1]) * 28 t = today.split('.') d = 28 * 12 * int(t[0]) + 28 * int(t[1]) + int(t[2]) for p in range(len(privacies)): pret = privacies[p].split(' ') t = pret[0].split('.') nd = 28 * 12 * int(t[0]) + 28 * int(t[1]) + int(t[2]) if termdict[pret[1]] + nd &lt;= d: answer.append(p + 1) return answer\n복사\nday가 딱 28일로 통일되어 있으니, ‘년월일’이 아니라 숫자 하나로 통합해서 비교를 한번만 하면되겠네.\n위의 코드도 그 방법인데 이게 더 직관적이었음..\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"개인정보 수집 유효기간","level":1,"id":"개인정보 수집 유효기간"},{"heading":"나의 코드","level":2,"id":"나의_코드"},{"heading":"datetime module -link","level":3,"id":"datetime_module_[-link](https//docs.python.org/ko/3/library/datetime.html)"},{"heading":"남의 코드","level":2,"id":"남의_코드"},{"heading":"abstraction","level":3,"id":"abstraction"},{"heading":"새로운 방법: 시간을 다 합쳐서 정수로 표현","level":3,"id":"새로운_방법_시간을_다_합쳐서_정수로_표현"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/개인정보-수집-유효기간.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247669,"modifiedTime":1709035530317,"sourceSize":3160,"sourcePath":"1. Study/Coding Test/PS/개인정보 수집 유효기간.md","exportPath":"1.-study/coding-test/ps/개인정보-수집-유효기간.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/계단-오르기.html":{"title":"계단 오르기","icon":"","description":"ID: 2579\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/2579\" target=\"_self\">https://www.acmicpc.net/problem/2579</a>\n난이도: 실버 3\n다시풀기: Yes\n메모: 끝나는거 기준으로 dp 다시 만들어 보기\n생성 일시: 2023년 8월 27일 오후 9:01계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다. &lt;그림 1&gt;과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://upload.acmicpc.net/7177ea45-aa8d-4724-b256-7b84832c9b97/-/preview/\" target=\"_self\">https://upload.acmicpc.net/7177ea45-aa8d-4724-b256-7b84832c9b97/-/preview/</a>&lt;그림 1&gt;예를 들어 &lt;그림 2&gt;와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면 총 점수는 10 + 20 + 25 + 20 = 75점이 된다.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://upload.acmicpc.net/f00b6121-1c25-492e-9bc0-d96377c586b0/-/preview/\" target=\"_self\">https://upload.acmicpc.net/f00b6121-1c25-492e-9bc0-d96377c586b0/-/preview/</a>&lt;그림 2&gt;계단 오르는 데는 다음과 같은 규칙이 있다.\n계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.\n연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.\n마지막 도착 계단은 반드시 밟아야 한다.\n따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.입력의 첫째 줄에 계단의 개수가 주어진다.둘째 줄부터 한 줄에 하나씩 제일 아래에 놓인 계단부터 순서대로 각 계단에 쓰여 있는 점수가 주어진다. 계단의 개수는 300이하의 자연수이고, 계단에 쓰여 있는 점수는 10,000이하의 자연수이다.첫째 줄에 계단 오르기 게임에서 얻을 수 있는 총 점수의 최댓값을 출력한다.6\n10\n20\n15\n25\n10\n20 복사75 복사<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/2\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/2\" target=\"_self\">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/55\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/55\" target=\"_self\">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/57\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/57\" target=\"_self\">한국정보올림피아드시․도지역본선</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/70\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/70\" target=\"_self\">지역본선 2006</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/367\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/367\" target=\"_self\">초등부</a>&nbsp;4번\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/cjswodmlskfk\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/cjswodmlskfk\" target=\"_self\">cjswodmlskfk</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/eric00513\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/eric00513\" target=\"_self\">eric00513</a> 그냥 다 찾아서 최대값\n트리를 만들까? 이진 트리 만들 수 있을 것같은데. 트리 만들고 탐색을 할때, import sys class Node: def __init__(self, parent, id, val): self.parent = parent self.id = id self.element = val self.left = None self.right = None class Tree: def __init__(self, id): self.root = Node(None, id, num_list[id]) build_tree(self.root, 0) def build_tree(node, num): id = node.id sum = node.element + num if id == N: val_list.append(sum) elif id == N-1: if node.parent == None or node.id == node.parent.id + 2: node.left = Node(node, id + 1, num_list[id + 1]) build_tree(node.left, sum) else: if node.parent == None or node.id == node.parent.id + 2: node.left = Node(node, id + 1, num_list[id + 1]) node.right = Node(node, id + 2, num_list[id + 2]) build_tree(node.left, sum) build_tree(node.right, sum) else: node.right = Node(node, id + 2, num_list[id + 2]) build_tree(node.right, sum) N = int(sys.stdin.readline().rstrip())\nnum_list = [0]\nval_list = [] for i in range(N): num_list.append(int(sys.stdin.readline().rstrip())) if N &gt;= 2: stair_route_one = build_tree(Tree(1).root, 0) stair_route_two = build_tree(Tree(2).root, 0)\nelse: stair_route_one = build_tree(Tree(1).root, 0) print(max(val_list))\n복사 재귀로 짰는데, 메모리 초과… dp 문제라네… dp 어떻게 해야할까. 2로끝 1,2 3 끝 1,3\n2,3 4끝 2,4 → 1,2\n3,4 → 1,3 5Rmx 3,5 → 1,3|2,3\n4,5 → 2,4 복사복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"계단 오르기","level":1,"id":"계단 오르기"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/계단-오르기.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247654,"modifiedTime":1709035530323,"sourceSize":5003,"sourcePath":"1. Study/Coding Test/PS/계단 오르기.md","exportPath":"1.-study/coding-test/ps/계단-오르기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/괄호.html":{"title":"괄호","icon":"","description":"<a href=\".?query=tag:코딩테스트\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#코딩테스트\">#코딩테스트</a><br>\n<a href=\".?query=tag:실버/4\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#실버/4\">#실버/4</a>괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다.&nbsp;여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다.&nbsp;입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다.&nbsp;출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다.&nbsp;6\n(())())\n(((()())()\n(()())((()))\n((()()(()))(((())))()\n()()()()(()()())()\n(()((())()(NO\nNO\nYES\nNO\nYES\nNO3\n((\n))\n())(()NO\nNO\nNO<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/1\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/1\" target=\"_self\">ICPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/7\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/7\" target=\"_self\">Regionals</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/42\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/42\" target=\"_self\">Asia Pacific</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/211\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/211\" target=\"_self\">Korea</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/256\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/256\" target=\"_self\">Nationwide Internet Competition</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/1081\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/1081\" target=\"_self\">Daejeon Nationalwide Internet Competition 2012</a>&nbsp;G번\n<br>데이터를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/marona\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/marona\" target=\"_self\">marona</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/175\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/175\" target=\"_self\">자료 구조</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/158\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/158\" target=\"_self\">문자열</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/71\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/71\" target=\"_self\">스택</a>\nPython에서 strip()을 이용하면 문자열에서 특정 문자를 제거할 수 있습니다. Java 등의 다른 언어들도 strip()을 제공하며, 기능은 모두 비슷합니다.Python의 String은 다음 함수를 제공합니다.strip([chars]) : 인자로 전달된 문자를 String의 왼쪽과 오른쪽에서 제거합니다. lstrip([chars]) : 인자로 전달된 문자를 String의 왼쪽에서 제거합니다. rstrip([chars]) : 인자로 전달된 문자를 String의 오른쪽에서 제거합니다. 인자를 전달하지 않을 수도 있으며, 인자를 전달하지 않으면 String에서 공백을 제거합니다.()를 공백으로 대체하는 걸 반복하다가 없으면 no 출력하는방식이. 더 빠르네. n + (n-2) + (n-4) + ... + 0 -&gt; n*(1/2)n인데....내가 결과적으로 한 방식은, 조금 더 생각해서 합칠 수 있는 걸 합쳐야 했어. 더하고 빼다가, -1이 나오면 멈추는 방식으로.while이 for 보다 빠른가봐... (40 vs 44) 꼭 for일 필요 없는거.(그러니까, 리스트 item들 한바퀴돌리면서 사용해야하는 경우 말고, 그냥 숫자만큼 반복은 while이 빠르네...)","aliases":[],"inlineTags":["#코딩테스트","#실버/4"],"frontmatterTags":[],"headers":[{"heading":"괄호","level":1,"id":"괄호"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1 복사","level":2,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":2,"id":"예제_출력_1 복사"},{"heading":"예제 입력 2 복사","level":2,"id":"예제_입력_2 복사"},{"heading":"예제 출력 2 복사","level":2,"id":"예제_출력_2 복사"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"메모","level":2,"id":"메모"}],"links":["?query=tag:%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8","?query=tag:%EC%8B%A4%EB%B2%84/4"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/괄호.html","pathToRoot":"../../..","attachments":[],"createdTime":1709347290016,"modifiedTime":1709347314904,"sourceSize":3925,"sourcePath":"1. Study/Coding Test/PS/괄호.md","exportPath":"1.-study/coding-test/ps/괄호.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/기본.html":{"title":"기본","icon":"","description":"다시풀기: No\n생성 일시: 2023년 4월 11일 오후 1:50복사복사복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"기본","level":1,"id":"기본"},{"heading":"문제","level":2,"id":"문제"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/기본.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247637,"modifiedTime":1709035530338,"sourceSize":178,"sourcePath":"1. Study/Coding Test/PS/기본.md","exportPath":"1.-study/coding-test/ps/기본.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/나는야-포켓몬-마스터-이다솜.html":{"title":"나는야 포켓몬 마스터 이다솜","icon":"","description":"ID: 1620\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1620\" target=\"_self\">https://www.acmicpc.net/problem/1620</a>\n난이도: 실버 4\n다시풀기: No\n분류: 자료구조, 해시를 사용한 집합과 맵\n생성 일시: 2023년 7월 29일 오전 12:40<br><img alt=\"https://www.acmicpc.net/upload/201004/p1.PNG\" src=\"https://www.acmicpc.net/upload/201004/p1.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으로 가야겠어.(뚜벅 뚜벅)얏! 꼬렛이다. 꼬렛? 귀여운데, 나의 첫 포켓몬으로 딱 어울린데? 내가 잡고 말겠어. 가라! 몬스터볼~(펑!) 헐랭... 왜 안 잡히지?ㅜㅜ 몬스터 볼만 던지면 되는 게 아닌가...ㅜㅠ(터벅터벅)어? 누구지?<br><img alt=\"https://www.acmicpc.net/upload/201004/p2.PNG\" src=\"https://www.acmicpc.net/upload/201004/p2.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">오박사 : 나는 태초마을의 포켓몬 박사 오민식 박사라네. 다솜아, 포켓몬을 잡을 때는, 일단 상대 포켓몬의 체력을 적당히 바닥으로 만들어놓고 몬스터 볼을 던져야 한단다. 자, 내 포켓몬 이상해꽃으로 한번 잡아보렴. 포켓몬의 기술을 쓰는 것을 보고 포켓몬을 줄지 안줄지 결정을 하겠네. 자 한번 해보아라. 다솜아.이다솜 : 이상해꽃이라...음.. 꽃이니깐 왠지 햇빛을 받아서 공격을 할 것 같은데... 음... 이상해꽃! 햇빛공격!!!(꼬렛이 이상해꽃에게 공격을 받아 체력이 25 감소했다.) &nbsp;&nbsp; 가라! 몬스터 볼!!! &nbsp;&nbsp; (꼬렛을 잡았습니다.) &nbsp;&nbsp; 야호! 신난다. 꼬렛을 잡았다.오박사 : 오우!! 방금 쓴 공격은 솔라빔이라고 하네.. 어떻게 공격을 한 건가? 솔라빔이란 공격에 대해서 공부를 한 건가?이다솜 : 꽃이니깐 왠지 햇빛을 제대로 받으면 광합성을 해서 음.. 그냥 그럴 것 같아서요 ☞☜오박사 : 다른 아이들은 넝쿨채찍이나, 나뭇잎 공격을 하는데, 다솜이는 역시 뭔가 다르구나. 그럼 나와 함께 연구소로 가자꾸나. 내가 포켓몬을 한 마리 줄 테니, 너의 꿈을 펼쳐보아라. 꿈은 이루어진단다.이다솜 : 네! 오박사님, 고마워요.ㅜㅜ오박사 : 가자. 나의 연구소는 너의 옆집의 아랫집이란다. 같이 가도록하자. 지금 포켓몬을 주마.이다솜 : 네. 야호!!'<br><img alt=\"https://www.acmicpc.net/upload/201004/p3.PNG\" src=\"https://www.acmicpc.net/upload/201004/p3.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">오영식 : 어? 오박사님 얘는 누구인가요?<br><img alt=\"https://www.acmicpc.net/upload/201004/p4.PNG\" src=\"https://www.acmicpc.net/upload/201004/p4.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">오박사 : 얘는 너의 라이벌이 될 친구 이다솜이라고 하네. 자, 포켓몬을 한 마리 골라보도록 해봐라 다솜아. 레이디퍼스트 네가 먼저 골라봐라.이다솜 : 저는 생각해둔 포켓몬이 있어요. 피카츄 골라도 될까요?오박사 : 그래 여기 피카츄가 한 마리 있단다. 피카츄를 가져가거라.오영식 : 그럼 저는 이브이를 가져가겠어요. 그럼 나중에 보자 이다솜.이다솜 : 그럼 꼬렛을 다시 잡으러 가야겠다. 영식아, 그리고 민식박사님 빠잉!<br><img alt=\"https://www.acmicpc.net/upload/201004/p5.PNG\" src=\"https://www.acmicpc.net/upload/201004/p5.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이다솜 : 피카츄 공격!<br><img alt=\"https://www.acmicpc.net/upload/201004/p6.PNG\" src=\"https://www.acmicpc.net/upload/201004/p6.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">가라 몬스터 볼!<br><img alt=\"https://www.acmicpc.net/upload/201004/p7.PNG\" src=\"https://www.acmicpc.net/upload/201004/p7.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이다솜 : 야호! 신난다. 꼬렛을 잡았다!!!!!이다솜 : 그럼! 일단 사천왕을 이기고 오겠어!<br><img alt=\"https://www.acmicpc.net/upload/201004/p8.PNG\" src=\"https://www.acmicpc.net/upload/201004/p8.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이다솜 : 여기가 사천왕과 대결하려면 가야하는 곳인가..<br><img alt=\"https://www.acmicpc.net/upload/201004/p9.PNG\" src=\"https://www.acmicpc.net/upload/201004/p9.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">경비원 : 사천왕과 대결을 하려면, 마을의 체육관 리더를 이겨서 배지를 8개를 모아야 한다네... 배지를 모아서 오도록 하게이다솜 : 잉ㅠㅜ... 그럼 배지부터 모아야 하는구나ㅠㅜㅠㅜ 나쁘당 그냥 좀 봐주지..&lt;1 년 후&gt;그동안의 줄거리 : 이다솜은 일단 상록 숲의 체육관 리더에게 도전을 했다. 하지만 상록숲 체육관의 리더는 실종된 상태. 따라서 회색마을부터 도전하기로 했다. 체육관의 리더를 이기면서, 로켓단을 해체시키기도 하고, 여러 가지 사건도 있었다. 결국 전설의 포켓몬도 잡고, 이제 사천왕을 이기려고 도전하기로 했다. 사천왕은 모두 가볍게 이기고, 이제 마지막 라이벌 오!영!식! 이다.<br><img alt=\"https://www.acmicpc.net/upload/201004/pa.PNG\" src=\"https://www.acmicpc.net/upload/201004/pa.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">오영식 : 훗. 1년 전의 그 이다솜이 사천왕을 이기고 현재 포켓몬 마스터인 나에게 덤벼? 어디 한번 덤벼보시지.이다솜 : 헐랭... 나를 우습게보네.... 한번 두고 보시지! 그럼 대결이닷!<br><img alt=\"https://www.acmicpc.net/upload/201004/pb.PNG\" src=\"https://www.acmicpc.net/upload/201004/pb.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img alt=\"https://www.acmicpc.net/upload/201004/pc.PNG\" src=\"https://www.acmicpc.net/upload/201004/pc.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img alt=\"https://www.acmicpc.net/upload/201004/pd.PNG\" src=\"https://www.acmicpc.net/upload/201004/pd.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img alt=\"https://www.acmicpc.net/upload/201004/pe.PNG\" src=\"https://www.acmicpc.net/upload/201004/pe.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img alt=\"https://www.acmicpc.net/upload/201004/pf.PNG\" src=\"https://www.acmicpc.net/upload/201004/pf.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img alt=\"https://www.acmicpc.net/upload/201004/pg.PNG\" src=\"https://www.acmicpc.net/upload/201004/pg.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img alt=\"https://www.acmicpc.net/upload/201004/ph.PNG\" src=\"https://www.acmicpc.net/upload/201004/ph.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\"><br><img alt=\"https://www.acmicpc.net/upload/201004/pi.PNG\" src=\"https://www.acmicpc.net/upload/201004/pi.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이다솜 : 휴... 이겼다.오영식 : 내가 지다니 분하다. ㅜㅜ오박사 : 그럼 다솜아 이제 진정한 포켓몬 마스터가 되기 위해 도감을 완성시키도록 하여라. 일단 네가 현재 가지고 있는 포켓몬 도감에서 포켓몬의 이름을 보면 포켓몬의 번호를 말하거나, 포켓몬의 번호를 보면 포켓몬의 이름을 말하는 연습을 하도록 하여라. 나의 시험을 통과하면, 내가 새로 만든 도감을 주도록 하겠네.첫째 줄에는 도감에 수록되어 있는 포켓몬의 개수 N이랑 내가 맞춰야 하는 문제의 개수 M이 주어져. N과 M은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수인데, 자연수가 뭔지는 알지? 모르면 물어봐도 괜찮아. 나는 언제든지 질문에 답해줄 준비가 되어있어.둘째 줄부터 N개의 줄에 포켓몬의 번호가 1번인 포켓몬부터 N번에 해당하는 포켓몬까지 한 줄에 하나씩 입력으로 들어와. 포켓몬의 이름은 모두 영어로만 이루어져있고, 또, 음... 첫 글자만 대문자이고, 나머지 문자는 소문자로만 이루어져 있어. 아참! 일부 포켓몬은 마지막 문자만 대문자일 수도 있어. 포켓몬 이름의 최대 길이는 20, 최소 길이는 2야. 그 다음 줄부터 총 M개의 줄에 내가 맞춰야하는 문제가 입력으로 들어와. 문제가 알파벳으로만 들어오면 포켓몬 번호를 말해야 하고, 숫자로만 들어오면, 포켓몬 번호에 해당하는 문자를 출력해야해. 입력으로 들어오는 숫자는 반드시 1보다 크거나 같고, N보다 작거나 같고, 입력으로 들어오는 문자는 반드시 도감에 있는 포켓몬의 이름만 주어져. 그럼 화이팅!!!첫째 줄부터 차례대로 M개의 줄에 각각의 문제에 대한 답을 말해줬으면 좋겠어!!!. 입력으로 숫자가 들어왔다면 그 숫자에 해당하는 포켓몬의 이름을, 문자가 들어왔으면 그 포켓몬의 이름에 해당하는 번호를 출력하면 돼. 그럼 땡큐~<br><img alt=\"https://www.acmicpc.net/upload/201004/pn.PNG\" src=\"https://www.acmicpc.net/upload/201004/pn.PNG\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이게 오박사님이 나에게 새로 주시려고 하는 도감이야. 너무 가지고 싶다ㅠㅜ. 꼭 만점을 받아줬으면 좋겠어!! 파이팅!!!26 5\nBulbasaur\nIvysaur\nVenusaur\nCharmander\nCharmeleon\nCharizard\nSquirtle\nWartortle\nBlastoise\nCaterpie\nMetapod\nButterfree\nWeedle\nKakuna\nBeedrill\nPidgey\nPidgeotto\nPidgeot\nRattata\nRaticate\nSpearow\nFearow\nEkans\nArbok\nPikachu\nRaichu\n25\nRaichu\n3\nPidgey\nKakuna 복사Pikachu\n26\nVenusaur\n16\n14 복사\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/frogyou2330\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/frogyou2330\" target=\"_self\">frogyou2330</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/175\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/175\" target=\"_self\">자료 구조</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/136\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/136\" target=\"_self\">해시를 사용한 집합과 맵</a> 단어랑 숫자를 전부 생각해야해\ntag를 보면, dictionary를 사용해야하는 듯 key를 알파벳 첫자로 하는 경우. 근데 내가 생각한대로면 그냥, 데이터를 2군데에 저장하는 건데. list → index가 숫자 그대로 / dictionary → 첫글자를 key로 ⇒ 최대 2만개.\n100으로 나눴을 때, 나머지를 index로 하는 list에 dictionary값 저장 이거를 N을 기준으로 해보자.\nN의 절반을 기준으로 나누기. 첫글자 ascii code를 index로 하는 list에, key가 숫자인 dictionary값 (혹은 index가 숫자인 list)저장 이건 worst로, 다 같은 알파벳으로 시작하면,,, key(숫자)로 접근할때는 O(n)이지만, value를 기준으로 하면 다 돌아야함.. 숫자로 시작할 때보다(mode 쓰면 분포가 고름)더 에바. 그러니까. 숫자로 들어왔을 때, 문자를 출력해야하고\n문자로 들어왔을 때, 숫자를 출력해야한다고.\n첫번째는 간단해, 그냥 숫자를 index로 해서 list를 만들면 되니까.\n두번째는 ascii를 index로 하는 list에 문자:숫자형태의 dictionary만들기. 아니지 굳이 그럴 필요 없이 그냥 dictionary만 쓰면 됨.\nimport sys def solution(): N, M = map(int, sys.stdin.readline().rstrip().split()) mod_num = N//2 eng_list = {} num_list = [0]*(N+1) for num in range(N): name = sys.stdin.readline().rstrip() idx = num + 1 num_list[idx] = name eng_list[name] = idx for _ in range(M): question = sys.stdin.readline().rstrip() if ord('A') &lt;= ord(question[0]) &lt;= ord('Z'): print(eng_list[question]) else: print(num_list[int(question)]) if __name__ == \"__main__\": solution()\n복사import sys def solution(): lines = sys.stdin.read().splitlines() N, M = map(int, lines[0].split()) encyclopedia = { name: str(index + 1) for index, name in enumerate(lines[1:N + 1]) } print(\"\\n\".join(encyclopedia[exam] if exam.isalpha() else lines[int(exam)] for exam in lines[N + 1:])) solution()\n복사아 이게 바로 splitlines()로 input 다 받아서 바로 num_list로 만들어버렸네","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"나는야 포켓몬 마스터 이다솜","level":1,"id":"나는야 포켓몬 마스터 이다솜"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"제출","level":2,"id":"제출"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/나는야-포켓몬-마스터-이다솜.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247622,"modifiedTime":1709035530352,"sourceSize":11487,"sourcePath":"1. Study/Coding Test/PS/나는야 포켓몬 마스터 이다솜.md","exportPath":"1.-study/coding-test/ps/나는야-포켓몬-마스터-이다솜.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/나이순-정렬.html":{"title":"나이순 정렬","icon":"","description":"ID: 10814\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/10814\" target=\"_self\">https://www.acmicpc.net/problem/10814</a>\n난이도: 실버 5\n다시풀기: No\n분류: 정렬\n생성 일시: 2023년 4월 12일 오후 1:05온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000)둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.첫째 줄부터 총 N개의 줄에 걸쳐 온라인 저지 회원을 나이 순, 나이가 같으면 가입한 순으로 한 줄에 한 명씩 나이와 이름을 공백으로 구분해 출력한다.3\n21 Junkyu\n21 Dohyun\n20 Sunyoung 복사20 Sunyoung\n21 Junkyu\n21 Dohyun 복사\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/97\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/97\" target=\"_self\">정렬</a> import sys def solution(): N = int(sys.stdin.readline().rstrip()) result = \"\" lst = [] while N&gt;0: N-=1 age, name = sys.stdin.readline().split() lst.append([age, \" \"+name+\"\\n\"]) lst.sort(key=lambda x:x[0]) for i in lst: result += \"\".join(i) print(result[:-1])\nif __name__ == \"__main__\": solution()\n복사\ndata_list.sort(key=lambda x : len(x)) x의 길이를 기준으로 오름차순으로 정렬해주세요. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"나이순 정렬","level":1,"id":"나이순 정렬"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/나이순-정렬.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247593,"modifiedTime":1709035530357,"sourceSize":2155,"sourcePath":"1. Study/Coding Test/PS/나이순 정렬.md","exportPath":"1.-study/coding-test/ps/나이순-정렬.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/다이나믹프로그래밍(dp).html":{"title":"다이나믹프로그래밍(DP)","icon":"","description":"ID: 0\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://hongjw1938.tistory.com/47\" target=\"_self\">https://hongjw1938.tistory.com/47</a>\n다시풀기: No\n분류: 다이나믹 프로그래밍\n생성 일시: 2023년 8월 18일 오후 3:59\n참고: BFS\n하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 것\n큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용 = 기억하며 풀기\n일반적인 재귀(Naive Recursion) 방식 또한 DP와 매우 유사 동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능\n<br>이진 탐색(<a data-tooltip-position=\"top\" aria-label=\"https://hongjw1938.tistory.com/40?category=884192\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://hongjw1938.tistory.com/40?category=884192\" target=\"_self\">참고</a>)와&nbsp;피보나치 수열의 경우를 비교해 보자. 이진 탐색은 특정 데이터를 정렬된 배열 내에서 그 위치를 찾기 때문에 그 위치를 찾은 후 바로 반환할 뿐 그것을 재사용하는 과정을 거치지 않는다. 반면, 피보나치 수열은 f(n) = f(n-1) + f(n-2) 인데, 아래와 같은 트리 구조로 함수가 호출되게 된다.\nf(3), f(2), f(1)과 같이 동일한 부분 문제가 중복 부분 문제에서 구한 최적 결과가 전체 문제에서도 동일하게 적용되어 결과가 변하지 않을 때 DP를 사용할 수 있게 된다.\n이름에서 보이듯이,&nbsp;아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식이다.메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고 dp[n]을 목표 상태라고 하자. Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.이는 dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해&nbsp;위에서 부터 바로 호출을 시작하여 dp[0]의 상태까지 내려간 다음 해당&nbsp;결과 값을 재귀를 통해 전이시켜 재활용하는 방식이다.피보나치의 예시처럼, f(n) = f(n-2) + f(n-1)의 과정에서 함수 호출 트리의 과정에서 보이듯, n=5일 때, f(3), f(2)의 동일한 계산이 반복적으로 나오게 된다.이 때, 이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 그래서 가장 최근의 상태 값을 메모해 두었다고 하여&nbsp;Memoization&nbsp;이라고 부른다.\"Untitled\"이(가) 생성되지 않았습니다. 클릭하여 생성합니다.%20d88c8563b44f47958703582cec841bfb/Untitled.png)Q. Divide and Conquer(분할 정복)와 차이점은?분할 정복과&nbsp;동적 프로그래밍은&nbsp;주어진 문제를 작게 쪼개서 하위 문제로 해결하고 연계적으로 큰 문제를 해결한다는 점은 같다.차이점은, 분할 정복은 분할된 하위 문제가 동일하게 중복이 일어나지 않는 경우에 쓰며, 동일한 중복이 일어나면 동적 프로그래밍을 쓴다는 것이다.\n피보나치 구현에 재귀를 활용했다면 시간복잡도는&nbsp;O(2^n)이지만, 동적 계획법을 활용하면 O(N)으로 해결할 수 있다.\n## Bottom-up\ndef dp_fibonacci(x): dp = [0,1] + ([0]*(x-1)) for i in range(2, len(dp)): dp[i] = dp[i-1] + dp[i-2] print(dp[x]) print(dp) dp_fibonacci(100)\n복사","aliases":[],"inlineTags":[],"frontmatterTags":["#정리"],"headers":[{"heading":"다이나믹프로그래밍(DP)","level":1,"id":"다이나믹프로그래밍(DP)"},{"heading":"다이나믹 프로그래밍","level":1,"id":"다이나믹_프로그래밍"},{"heading":"조건","level":1,"id":"조건"},{"heading":"1) Overlapping Subproblems(겹치는 부분 문제)","level":2,"id":"**1)_Overlapping_Subproblems(겹치는_부분_문제)**"},{"heading":"2) Optimal Substructure(최적 부분 구조)","level":2,"id":"**2)_Optimal_Substructure(최적_부분_구조)**"},{"heading":"종류","level":1,"id":"종류"},{"heading":"Bottom-Up 방식","level":2,"id":"**Bottom-Up_방식**"},{"heading":"Top-Down 방식","level":2,"id":"**Top-Down_방식**"},{"heading":"참고","level":1,"id":"참고"},{"heading":"실습: fibonacci","level":1,"id":"실습_fibonacci"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/다이나믹프로그래밍(dp).html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247581,"modifiedTime":1715664413637,"sourceSize":3646,"sourcePath":"1. Study/Coding Test/PS/다이나믹프로그래밍(DP).md","exportPath":"1.-study/coding-test/ps/다이나믹프로그래밍(dp).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/단어정렬.html":{"title":"단어정렬","icon":"","description":"ID: 1181\nSite: 백준\n난이도: 실버 5\n다시풀기: No\n분류: 문자열, 정렬\n생성 일시: 2023년 4월 11일 오후 1:52\n중복 제거 → set(순서 없음, 중복없음.)을 사용하려 했으나, 순서 없음이 헷갈릴 것 같아서 다른 방법 생각.\n사전식 배열 → 그냥 글자끼리 compare해도 가능 ⇒ 그런데 이방법은 길이와 관계가 없음.\n그러면 입력 받으면서 길이로 나누고(2d array? dict?)\n그 안에서 비교를 하자.\nimport sys def solution(): N = int(sys.stdin.readline().rstrip()) lst = [[] for _ in range(50)] while N &gt; 0: N-=1 word = sys.stdin.readline().rstrip() lst[len(word)-1].append(word) for i in lst: i.sort() for j in i: print(j) if __name__ == \"__main__\": solution()\n복사\n중복제거를 하지 않았어…\n다 compare하는 방식으로 돌리기에는 코드가 복잡하고\n넣을때마다 있는지 없는지 확인하기에는 음…\n오! set을 쓰면 되겠다.\nimport sys def solution(): N = int(sys.stdin.readline().rstrip()) lst = [set() for _ in range(50)] while N &gt; 0: N-=1 word = sys.stdin.readline().rstrip() lst[len(word)-1].add(word) for i in lst: k = list(i) k.sort() for j in k: print(j) if __name__ == \"__main__\": solution()\n복사\n더 줄일 수 있는데,,, 50,60대로…\n아…! set도 sort가능이네? 순서 없음인데? 대신 set.sort()는 안됨 똑같은디….\n아…! print를 반복하는 것도 실행시간에 영향을 줄 수 있음.. set(순서없음, 중복 없음)은 append가 아니라, add를 쓴다.\nset도 sort 할 수 있다. 대신 i.sort()는 list 전용이다. → 원본값을 수정함으로 빠름\nsorted()는 다 사용 가능 +) set은 mutable, tuple은 수정이 어려움. → 그냥 ()는 tuple이다.\n여러번의 print()보다 join을 사용한 한번의 print() 더 빠르다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"단어정렬","level":1,"id":"단어정렬"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"1차","level":3,"id":"1차"},{"heading":"2차 → 성공(72ms)","level":3,"id":"2차_→_성공(72ms)"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/단어정렬.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247568,"modifiedTime":1709035530372,"sourceSize":2190,"sourcePath":"1. Study/Coding Test/PS/단어정렬.md","exportPath":"1.-study/coding-test/ps/단어정렬.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/덩치.html":{"title":"덩치","icon":"","description":"ID: 7568\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/7568\" target=\"_self\">https://www.acmicpc.net/problem/7568</a>\n난이도: 실버 5\n다시풀기: No\n분류: 구현, 브루트포스 알고리즘\n생성 일시: 2023년 4월 12일 오전 11:10우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다. 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다. 두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때 x &gt; p 그리고 y &gt; q 이라면 우리는 A의 덩치가 B의 덩치보다 \"더 크다\"고 말한다. 예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면 A의 덩치가 B보다 큰 셈이 된다. 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다. 예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로, \"덩치\"로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 \"큰 덩치\"의 사람의 수로 정해진다. 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다. 이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다. 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다. 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다. 그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다. 위 경우에 3등과 4등은 존재하지 않는다. 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서 각 사람의 덩치 등수를 계산하여 출력해야 한다.첫 줄에는 전체 사람의 수 N이 주어진다. 그리고 이어지는 N개의 줄에는 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다. 단, 각 덩치 등수는 공백문자로 분리되어야 한다.\n2 ≤ N ≤ 50\n10 ≤ x, y ≤ 200\n5\n55 185\n58 183\n88 186\n60 175\n46 155 복사2 2 1 2 5 복사<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/2\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/2\" target=\"_self\">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/55\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/55\" target=\"_self\">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/57\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/57\" target=\"_self\">한국정보올림피아드시․도지역본선</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/214\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/214\" target=\"_self\">지역본선 2013</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/912\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/912\" target=\"_self\">초등부</a>&nbsp;2번\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/apjw6112\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/apjw6112\" target=\"_self\">apjw6112</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/eric00513\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/eric00513\" target=\"_self\">eric00513</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/genius0412\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/genius0412\" target=\"_self\">genius0412</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jung2381187\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jung2381187\" target=\"_self\">jung2381187</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/seecimi\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/seecimi\" target=\"_self\">seecimi</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/rea9lizer\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/rea9lizer\" target=\"_self\">rea9lizer</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/thebjko\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/thebjko\" target=\"_self\">thebjko</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/102\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/102\" target=\"_self\">구현</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/125\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/125\" target=\"_self\">브루트포스 알고리즘</a> 그냥 brute-force로 해보지 뭐.\n튜플을 사용해도 되겠구나!\nimport sys def solution(): N = int(sys.stdin.readline().rstrip()) cnt = N result = [] lst = [] # input 받아서 키, 몸무게 list 생성 while cnt &gt;0: cnt-=1 x, y = map(int,sys.stdin.readline().rstrip().split(\" \")) lst.append((x,y)) # 등수 구하기 for i in lst: rank = 1 for j in lst: if i[0] &lt; j[0] and i[1] &lt; j[1]: rank += 1 result.append(str(rank)) cnt += 1 print(\" \".join(result)) if __name__ == \"__main__\": solution()\n복사\njoin은 list의 요소가 str이어야함.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"덩치","level":1,"id":"덩치"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"제한","level":2,"id":"제한"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/덩치.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247549,"modifiedTime":1709035530386,"sourceSize":4627,"sourcePath":"1. Study/Coding Test/PS/덩치.md","exportPath":"1.-study/coding-test/ps/덩치.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/듣보잡.html":{"title":"듣보잡","icon":"","description":"ID: 1764\nSite: 백준\nURL: acmicpc.net/problem/1764\n난이도: 실버 4\n다시풀기: No\n분류: 문자열, 자료구조, 정렬, 해시를 사용한 집합과 맵\n생성 일시: 2023년 8월 3일 오후 11:51김진영이 듣도 못한 사람의 명단과, 보도 못한 사람의 명단이 주어질 때, 듣도 보도 못한 사람의 명단을 구하는 프로그램을 작성하시오.첫째 줄에 듣도 못한 사람의 수 N, 보도 못한 사람의 수 M이 주어진다. 이어서 둘째 줄부터 N개의 줄에 걸쳐 듣도 못한 사람의 이름과, N+2째 줄부터 보도 못한 사람의 이름이 순서대로 주어진다. 이름은 띄어쓰기 없이 알파벳 소문자로만 이루어지며, 그 길이는 20 이하이다. N, M은 500,000 이하의 자연수이다.듣도 못한 사람의 명단에는 중복되는 이름이 없으며, 보도 못한 사람의 명단도 마찬가지이다.듣보잡의 수와 그 명단을 사전순으로 출력한다.3 4\nohhenrie\ncharlie\nbaesangwook\nobama\nbaesangwook\nohhenrie\nclinton 복사2\nbaesangwook\nohhenrie 복사\n문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/author5\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/author5\" target=\"_self\">author5</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/175\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/175\" target=\"_self\">자료 구조</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/158\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/158\" target=\"_self\">문자열</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/97\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/97\" target=\"_self\">정렬</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/136\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/136\" target=\"_self\">해시를 사용한 집합과 맵</a> 앞에 피카츄 문제랑 비슷\nimport sys def solution(): N, M = map(int,sys.stdin.readline().rstrip().split()) see_dict = {} result_list = [] for _ in range(N): name = sys.stdin.readline().rstrip() see_dict[name] = 1 for _ in range(M): qes = sys.stdin.readline().rstrip() if see_dict.get(qes) == 1: result_list.append(qes) result_list.sort() print(len(result_list)) print(\"\\n\".join(result_list)) if __name__ == \"__main__\": solution()\n복사import sys\nn, m = map(int, input().split())\nnameList = sys.stdin.read().splitlines()\nhearset = set(nameList[:n])\nseeset = set(nameList[n:])\nret = list(hearset &amp; seeset)\nret.sort()\nprint(len(ret))\nfor i in ret: print(i)\n복사\n교집합 기호 그냥 사용하는 방법도 있네.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"듣보잡","level":1,"id":"듣보잡"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/듣보잡.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247536,"modifiedTime":1709035530400,"sourceSize":2612,"sourcePath":"1. Study/Coding Test/PS/듣보잡.md","exportPath":"1.-study/coding-test/ps/듣보잡.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/로프.html":{"title":"로프","icon":"","description":"ID: 2217\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/2217\" target=\"_self\">https://www.acmicpc.net/problem/2217</a>\n난이도: 실버 4\n다시풀기: Yes\n분류: 그리디 알고리즘, 수학, 정렬\n생성 일시: 2023년 8월 7일 오후 11:25\n💡 2217-1 파일 계속 틀려서… 딴 코드 참고한건데.N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.첫째 줄에 답을 출력한다.2\n10\n15 복사20 복사\n<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/bububu111\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/bububu111\" target=\"_self\">bububu111</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/kdk8361\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/kdk8361\" target=\"_self\">kdk8361</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/roy752\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/roy752\" target=\"_self\">roy752</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/124\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/124\" target=\"_self\">수학</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/33\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/33\" target=\"_self\">그리디 알고리즘</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/97\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/97\" target=\"_self\">정렬</a> 받아서\nsort해서\n자기보다 큰 rope 다 사용하는 걸로 해서 값 계산해서\nmax값 찾아서\n근데 시간이 좀 김…\n복사복사복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"로프","level":1,"id":"로프"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/로프.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247510,"modifiedTime":1709035530415,"sourceSize":2325,"sourcePath":"1. Study/Coding Test/PS/로프.md","exportPath":"1.-study/coding-test/ps/로프.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/마인크래프트.html":{"title":"마인크래프트","icon":"","description":"ID: 18111\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/18111\" target=\"_self\">https://www.acmicpc.net/problem/18111</a>\n난이도: 실버 2\n다시풀기: Yes\n분류: 구현, 브루트포스 알고리즘\n생성 일시: 2023년 7월 24일 오후 3:18팀 레드시프트는&nbsp;대회 준비를 하다가 지루해져서 샌드박스 게임인 ‘마인크래프트’를 켰다. 마인크래프트는 1 ×&nbsp;1 ×&nbsp;1(세로, 가로, 높이) 크기의 블록들로 이루어진 3차원 세계에서 자유롭게 땅을 파거나 집을 지을 수 있는 게임이다.목재를 충분히 모은 lvalue는 집을 짓기로 하였다. 하지만 고르지 않은 땅에는 집을 지을 수 없기 때문에 땅의 높이를 모두 동일하게 만드는 ‘땅 고르기’&nbsp;작업을 해야 한다.lvalue는 세로&nbsp;N, 가로&nbsp;M&nbsp;크기의 집터를 골랐다. 집터 맨 왼쪽 위의 좌표는 (0, 0)이다. 우리의 목적은 이 집터 내의 땅의 높이를 일정하게 바꾸는 것이다. 우리는 다음과 같은 두 종류의 작업을 할 수 있다.\n좌표 (i,&nbsp;j)의 가장 위에 있는 블록을 제거하여 인벤토리에 넣는다.\n인벤토리에서 블록 하나를 꺼내어 좌표 (i,&nbsp;j)의 가장 위에 있는 블록 위에 놓는다.\n1번 작업은 2초가 걸리며, 2번 작업은 1초가 걸린다. 밤에는 무서운 몬스터들이 나오기 때문에 최대한 빨리 땅 고르기 작업을 마쳐야 한다. ‘땅 고르기’&nbsp;작업에 걸리는 최소 시간과 그 경우 땅의 높이를 출력하시오.단, 집터 아래에 동굴 등 빈 공간은 존재하지 않으며, 집터 바깥에서 블록을 가져올 수 없다. 또한, 작업을 시작할 때 인벤토리에는&nbsp;B개의 블록이 들어 있다. 땅의 높이는 256블록을 초과할 수 없으며, 음수가 될 수 없다.첫째 줄에&nbsp;N, M,&nbsp;B가 주어진다. (1&nbsp;≤&nbsp;M,&nbsp;N&nbsp;≤ 500, 0 ≤&nbsp;B&nbsp;≤&nbsp;6.4 × 107)둘째 줄부터&nbsp;N개의 줄에 각각&nbsp;M개의 정수로 땅의 높이가 주어진다. (i&nbsp;+ 2)번째 줄의&nbsp;(j&nbsp;+ 1)번째 수는 좌표 (i,&nbsp;j)에서의 땅의 높이를 나타낸다. 땅의 높이는 256보다 작거나 같은 자연수 또는 0이다.첫째 줄에 땅을 고르는 데 걸리는 시간과 땅의 높이를 출력하시오. 답이 여러 개 있다면 그중에서 땅의 높이가 가장 높은 것을 출력하시오.3 4 99\n0 0 0 0\n0 0 0 0\n0 0 0 1 복사2 0 복사맨 오른쪽 아래의 블록을 제거하면 모두 높이가 0으로 고른 상태가 된다. 따라서 블럭을 한 번 제거하는 시간 2초가 소요된다.3 4 1\n64 64 64 64\n64 64 64 64\n64 64 64 63 복사1 64 복사<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://upload.acmicpc.net/50e6d9c5-2294-4bb5-826b-bb0fd3bc67f7/-/preview/\" target=\"_self\">https://upload.acmicpc.net/50e6d9c5-2294-4bb5-826b-bb0fd3bc67f7/-/preview/</a>인벤토리에 블록이 하나 있기 때문에, 맨 오른쪽 아래에 블록을 하나 채우면 된다.3 4 0\n64 64 64 64\n64 64 64 64\n64 64 64 63 복사22 63 복사인벤토리가 비어 있기 때문에, 맨 오른쪽 아래를 제외한 모든 좌표에서 블록을 하나씩 제거해야 한다.<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/5\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/5\" target=\"_self\">University</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/83\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/83\" target=\"_self\">서강대학교</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/693\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/693\" target=\"_self\">2019 Sogang Programming Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/2128\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/2128\" target=\"_self\">Champion</a>&nbsp;B번\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/hp3265\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/hp3265\" target=\"_self\">hp3265</a>\n<br>문제를 검수한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/shiftpsh\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/shiftpsh\" target=\"_self\">shiftpsh</a>\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/lvalue\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/lvalue\" target=\"_self\">lvalue</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/102\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/102\" target=\"_self\">구현</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/125\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/125\" target=\"_self\">브루트포스 알고리즘</a>\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"마인크래프트","level":1,"id":"마인크래프트"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"예제 입력 3","level":2,"id":"예제_입력_3"},{"heading":"예제 출력 3","level":2,"id":"예제_출력_3"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/마인크래프트.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247496,"modifiedTime":1709035530422,"sourceSize":4273,"sourcePath":"1. Study/Coding Test/PS/마인크래프트.md","exportPath":"1.-study/coding-test/ps/마인크래프트.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/바이러스.html":{"title":"바이러스","icon":"","description":"ID: 2606\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/2606\" target=\"_self\">https://www.acmicpc.net/problem/2606</a>\n난이도: 실버 3\n다시풀기: No\n분류: 그래프 이론, 그래프 탐색, 깊이 우선 탐색, 너비 우선 탐색\n생성 일시: 2023년 8월 19일 오후 7:24신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.예를 들어 7대의 컴퓨터가 &lt;그림 1&gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.<br><img alt=\"https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png\" src=\"https://www.acmicpc.net/upload/images/zmMEZZ8ioN6rhCdHmcIT4a7.png\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하인 양의 정수이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.7\n6\n1 2\n2 3\n1 5\n5 2\n5 6\n4 7 복사4 복사<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/2\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/2\" target=\"_self\">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/55\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/55\" target=\"_self\">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/57\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/57\" target=\"_self\">한국정보올림피아드시․도지역본선</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/74\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/74\" target=\"_self\">지역본선 2004</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/379\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/379\" target=\"_self\">초등부</a>&nbsp;3번\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/chansol\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/chansol\" target=\"_self\">chansol</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/znxkqkfpdyalgnfl\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/znxkqkfpdyalgnfl\" target=\"_self\">znxkqkfpdyalgnfl</a>\n<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jsa3824\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jsa3824\" target=\"_self\">jsa3824</a> 우왕 그래프다…\n그래프 공부….\n복사import sys def get_input(num): matrix = [[0] * num for _ in range(num)] N = int(sys.stdin.readline().rstrip()) for _ in range(N): i,j = map(int, sys.stdin.readline().split()) matrix[i-1][j-1] = 1 matrix[j-1][i-1] = 1 return matrix def check_virus(G, num): for i in range(len(G[num])): if G[num][i] == 1: if computer[i] != 1: computer[i] = 1 check_virus(G, i) return None num = int(sys.stdin.readline().rstrip())\ncomputer = [0]*num\ncomputer[0] = 1\ncheck_virus(get_input(num),0)\nprint(sum(computer)-1)\n복사복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"바이러스","level":1,"id":"바이러스"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/바이러스.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247477,"modifiedTime":1709035530431,"sourceSize":3717,"sourcePath":"1. Study/Coding Test/PS/바이러스.md","exportPath":"1.-study/coding-test/ps/바이러스.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/보물.html":{"title":"보물","icon":"","description":"ID: 1026\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1026\" target=\"_self\">https://www.acmicpc.net/problem/1026</a>\n난이도: 실버 4\n다시풀기: No\n분류: 그리디 알고리즘, 수학, 정렬\n생성 일시: 2023년 4월 20일 오전 11:53옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.S = A[0] × B[0] + ... + A[N-1] × B[N-1]S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.S의 최솟값을 출력하는 프로그램을 작성하시오.첫째 줄에 N이 주어진다. 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.첫째 줄에 S의 최솟값을 출력한다.5\n1 1 1 6 0\n2 7 8 3 1 복사18 복사3\n1 1 3\n10 30 20 복사80 복사9\n5 15 100 31 39 0 0 3 26\n11 12 13 2 3 4 5 9 1 복사528 복사예제 1의 경우 A를 {1, 1, 0, 1, 6}과 같이 재배열하면 된다.\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/124\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/124\" target=\"_self\">수학</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/33\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/33\" target=\"_self\">그리디 알고리즘</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/97\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/97\" target=\"_self\">정렬</a> B를 {val: [index]}해서 내림차순 정렬. 오름차순 정렬된 a와 매칭 A[0]가지고 B한바퀴 돌려서, 제일 큰수 index에 넣고. 그 다음으로 큰수 넣고 다시다시 받아서, a값 정렬해서 a값 하나 잡고, 가장 큰 수장 곱해서 더하고, 다음 a값과 그다음 큰 수를 곱해서 더하고 반복. import sys def solution(): N = int(sys.stdin.readline().rstrip()) A = list(map(int, sys.stdin.readline().rstrip().split(\" \"))) B = list(map(int, sys.stdin.readline().rstrip().split(\" \"))) A.sort() result = 0 for i in A: max = 0 idx = -1 for j in range(len(B)): if B[j] &gt; 100: continue if B[j] &gt;= max: max = B[j] idx = j result += (max*i) B[idx] = 101 print(result) if __name__ == \"__main__\": solution()\n복사\n예제는 다 되는데,,, 반례를 찾아야함.\n참조값이 없거나 부적적한 값…일때.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"보물","level":1,"id":"보물"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"예제 입력 3","level":2,"id":"예제_입력_3"},{"heading":"예제 출력 3","level":2,"id":"예제_출력_3"},{"heading":"힌트","level":2,"id":"힌트"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"1차 → 성공공","level":3,"id":"1차_→_성공공"},{"heading":"After","level":2,"id":"After"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/보물.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247431,"modifiedTime":1709035530435,"sourceSize":3031,"sourcePath":"1. Study/Coding Test/PS/보물.md","exportPath":"1.-study/coding-test/ps/보물.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/본.html":{"title":"본","icon":"","description":"ID: 1676\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1676\" target=\"_self\">https://www.acmicpc.net/problem/1676</a>\n난이도: 실버 5\n다시풀기: No\n분류: 수학\n생성 일시: 2023년 7월 21일 오후 8:44N!에서 뒤에서부터 처음 0이 아닌 숫자가 나올 때까지 0의 개수를 구하는 프로그램을 작성하시오.첫째 줄에 N이 주어진다. (0 ≤ N ≤ 500)첫째 줄에 구한 0의 개수를 출력한다.10 복사2 복사3 복사0 복사\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/111111111111\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/111111111111\" target=\"_self\">111111111111</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/his130\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/his130\" target=\"_self\">his130</a>\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/author6\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/author6\" target=\"_self\">author6</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/124\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/124\" target=\"_self\">수학</a> 팩토리얼.. 0이 나오려면, 2와5 2는 항상 5전에 몇번 나올것같음 2의 배수가 훨씬 많으니까, 5의 배수의 개수로 판단. 앗,,! 5의 제곱,,,, 5, 25,125 0은 0임…\nimport sys num = int(sys.stdin.readline()) if num == 0: result = 1\nelse: result = 0 while num &gt; 0: num = num // 5 result += num if __name__ == \"__main__\": print(result)\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"본","level":1,"id":"본"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/본.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247348,"modifiedTime":1709035530447,"sourceSize":1725,"sourcePath":"1. Study/Coding Test/PS/본.md","exportPath":"1.-study/coding-test/ps/본.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/비밀번호-만들기.html":{"title":"비밀번호 만들기","icon":"","description":"ID: 17218\n난이도: 골드2\n다시풀기: Yes\n생성 일시: 2023년 8월 12일 오후 7:08\n💡 Lcs 알고리즘최근 들어 개인정보 유출에 대한 뉴스를 많이 본&nbsp;수형이는 한 사이트의 비밀번호가 유출&nbsp;되더라도 다른 사이트에서 똑같은 비밀번호로&nbsp;접속할 수 없도록&nbsp;사이트마다 비밀번호를 다르게 설정하기로 다짐했다. 많이 고민한 결과 수형이는 눈을 감고 키보드를 막 쳐서 나온 두 문자열에서 공통으로 존재하는 가장 긴 부분 문자열을 비밀번호로 하기로 하였다. 수형이가 눈을 감고 만든 두 문자열이 주어졌을 때 비밀번호를 만드는 프로그램을 만들어보자.첫째 줄과 둘째 줄에 수형이가 눈을 감고 만든 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 길이는 최대&nbsp;40자이다. 빈 문자열은 주어지지 않는다.&nbsp;가장 긴 부분 문자열은 반드시 하나만 존재한다.첫 번째 줄에 입력으로 주어진 두 문자열로 만든&nbsp;비밀번호를 출력한다.AUTABBEHNSA\nBCUAMEFKAJNA\n복사UAENA 복사AUTABBEHNSABCUAMEFKAJNASETAPPLE\nEATMANY 복사ETA 복사SETAPPLEEATMANY<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/5\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/5\" target=\"_self\">University</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/418\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/418\" target=\"_self\">한양대학교 ERICA 캠퍼스</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/791\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/791\" target=\"_self\">2019 HEPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/2032\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/2032\" target=\"_self\">MAVEN League</a>&nbsp;E번\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/TheKinGoD\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/TheKinGoD\" target=\"_self\">TheKinGoD</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/25\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/25\" target=\"_self\">다이나믹 프로그래밍</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/158\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/158\" target=\"_self\">문자열</a> f(x, start(, end)) ⇒ start~end 사이에 가장 앞에 있는 x의 위치 result = 변수 재사용. flag → start나 end 그리고 flag로 한번 사용되었던 애로부터 시작하는 건 안써도 됨. 뒤에서부터 한다고 생각해볼까. result = “” word1의 첫 알파벳을 word2[0:]에서 찾음 여러개일 수 있으니까, 찾을 때마다 옆으로 넘김 word1의 두번째 알파벳을 word2[flag:]에서 찾음 반복 뒤에서 부터 해보면 f(word[-1], 0) = word1의 마지막 알파벳을 word2 (뒤에서부터)찾음 word1의 -2 위치 알파벳을 word2[:flag]찾음 f(word[-2]) = 복사복사복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"비밀번호 만들기","level":1,"id":"비밀번호 만들기"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/비밀번호-만들기.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247329,"modifiedTime":1709035530452,"sourceSize":2893,"sourcePath":"1. Study/Coding Test/PS/비밀번호 만들기.md","exportPath":"1.-study/coding-test/ps/비밀번호-만들기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/색종이.html":{"title":"색종이","icon":"","description":"ID: 2563\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/2563\" target=\"_self\">https://www.acmicpc.net/problem/2563</a>\n난이도: 실버 5\n다시풀기: No\n분류: 구현\n생성 일시: 2023년 4월 20일 오전 10:38가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 색종이가 붙은 검은 영역의 넓이를 구하는 프로그램을 작성하시오.<br><a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://upload.acmicpc.net/6000c956-1b07-4913-83c3-72eda18fa1d1/-/preview/\" target=\"_self\">https://upload.acmicpc.net/6000c956-1b07-4913-83c3-72eda18fa1d1/-/preview/</a>예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 그림과 같은 모양으로 붙였다면 검은색 영역의 넓이는 260이 된다.첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100 이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다첫째 줄에 색종이가 붙은 검은 영역의 넓이를 출력한다.3\n3 7\n15 7\n5 2 복사260\n복사 그냥 2d list만들어서 색칠하면 안되나ㅋㅋㅋㅋ 아니면, N*100 - (겹치는 부분.) 복사\nlist 곱하기 곱하기 연산은 리스트를 곱한 숫자만큼 반복시켜서 새로운 리스트를 생성합니다.\n곱하기 연산자는 특정 값으로 전체를 채우고 싶을 때 사용할 수 있습니다. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"색종이","level":1,"id":"색종이"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/색종이.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247314,"modifiedTime":1709035530456,"sourceSize":2212,"sourcePath":"1. Study/Coding Test/PS/색종이.md","exportPath":"1.-study/coding-test/ps/색종이.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/설탕-배달.html":{"title":"설탕 배달","icon":"","description":"ID: 2839\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/2839\" target=\"_self\">https://www.acmicpc.net/problem/2839</a>\n난이도: 실버 4\n다시풀기: No\n분류: 그리디 알고리즘, 다이나믹 프로그래밍, 수학\n생성 일시: 2023년 4월 16일 오후 11:12상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.18 복사4 복사4 복사-1 복사6 복사2 복사9 복사3 복사11 복사3 복사<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/45\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/45\" target=\"_self\">Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/17\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/17\" target=\"_self\">Croatian Open Competition in Informatics</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/20\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/20\" target=\"_self\">COCI 2010/2011</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/81\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/81\" target=\"_self\">Contest #7</a>&nbsp;1번\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/hyunynim\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/hyunynim\" target=\"_self\">hyunynim</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/124\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/124\" target=\"_self\">수학</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/25\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/25\" target=\"_self\">다이나믹 프로그래밍</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/33\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/33\" target=\"_self\">그리디 알고리즘</a> N = 3a+5b\nimport sys def solution(): N = int(sys.stdin.readline().rstrip()) result = 0 flag = 0 while True: if N % 3 == 0: flag = N if N &gt;= 5: N -= 5 result += 1 else: if flag == 0: result = -1 else: result -= (flag - N)//5 result += flag//3 break print(result) if __name__ == \"__main__\": solution()\n복사 5로만 계속 빼면서 그 순간 순간 마다 3으로 나눠 떨어지는 시점을 flag에 저장해 놓음(제일 작은 수로) 만약에 5로 계속 빼다가 딱 맞게 떨어지지 않으면, flag로 돌아가서 (result에서 그만큼 뺌) 3kg짜리 배달하는 만큼 더해서 print. 틀림: 5로만 구성된 경우에 문제가 생김… import sys def solution(): # 첫줄 input값 받기 N = int(sys.stdin.readline().rstrip()) result = 0 flag = 0 while True: if N % 3 == 0: flag = N if N &gt;= 5: N -= 5 result += 1 elif N == 0: break else: if flag == 0: result = -1 else: result -= (flag - N)//5 result += flag//3 break print(result) if __name__ == \"__main__\": solution()\n복사\n아, 5로 나누어떨어질 때까지 3씩 빼주면, flag를 세울 필요가 없구나.\n훨씬 간단하네.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"설탕 배달","level":1,"id":"설탕 배달"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"예제 입력 3","level":2,"id":"예제_입력_3"},{"heading":"예제 출력 3","level":2,"id":"예제_출력_3"},{"heading":"예제 입력 4","level":2,"id":"예제_입력_4"},{"heading":"예제 출력 4","level":2,"id":"예제_출력_4"},{"heading":"예제 입력 5","level":2,"id":"예제_입력_5"},{"heading":"예제 출력 5","level":2,"id":"예제_출력_5"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"1차 제출","level":3,"id":"1차_제출"},{"heading":"다른 사람 코드","level":3,"id":"다른_사람_코드"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/설탕-배달.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247298,"modifiedTime":1709035530469,"sourceSize":4138,"sourcePath":"1. Study/Coding Test/PS/설탕 배달.md","exportPath":"1.-study/coding-test/ps/설탕-배달.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/소수-구하기.html":{"title":"소수 구하기","icon":"","description":"ID: 1929\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1929\" target=\"_self\">https://www.acmicpc.net/problem/1929</a>\n난이도: 실버 3\n다시풀기: Yes\n분류: 소수 판정, 수학, 에라토스테네스의 체, 정수론\n생성 일시: 2023년 4월 27일 오후 12:31\n홀수리스트는 문제가 생김. → 왜 생기는가.\n시간을 줄이는 방법. 지금 입력에 따라 리스트 최대 길이 제한을 두는 것까지함\nM이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000)&nbsp;M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.3 16 복사3\n5\n7\n11\n13 복사\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jinjean0123\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jinjean0123\" target=\"_self\">jinjean0123</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/yongjun042\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/yongjun042\" target=\"_self\">yongjun042</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/124\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/124\" target=\"_self\">수학</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/95\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/95\" target=\"_self\">정수론</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/9\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/9\" target=\"_self\">소수 판정</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/67\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/67\" target=\"_self\">에라토스테네스의 체</a> 이 문제의 채점 우선 순위는 2이다. 그냥 소수 다 구해 놓고 범위에 맞는 것만 출력… 다 구하기에는 좀 많음… 줄일 수 있을 듯.. 범위의 수가, 10이면, 2,3,4,5의 배수는 무조건 있을 듯.(범위의 반까지.) 큰수의 절반이 제일 큰, 소수 후보겠지. import sys def solution(): M, N = map(int,sys.stdin.readline().rstrip().split()) lst = [True] * (1000000 + 1) lst[0] = 0 lst[1] = 0 for i in range(2, int(1000000**(0.5)) +1): if lst[i]: for j in range(i*2,len(lst),i): lst[j] = False for n in range(M,N+1): if lst[n]: print(n) if __name__ == \"__main__\": solution()\n복사 앞에는 1이 true라 소수 취급 되어서 틀림. 홀수만 포함된 list를 만들 수는 없나? 2의 배수는 미리 빠지는 list로 만들기 import sys def solution(): M, N = map(int,sys.stdin.readline().rstrip().split()) lst = ([False]+[True]) * (((N+1)//2)+1) lst[1] = False for i in range(3, int(N**(0.5)) +1): if lst[i]: for j in range(i*3,N+1,i*2): lst[j] = False for n in range(M,N+1): if lst[n]: print(n) if __name__ == \"__main__\": solution()ㅇ\n복사\nㅇ\n으악 2를 false로 처리해버렸네…. <br>에라토스테네스의 체 <a data-tooltip-position=\"top\" aria-label=\"https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4\" target=\"_self\">에라토스테네스의 체</a> 0,1 보다 True False가 빠르네?\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"소수 구하기","level":1,"id":"소수 구하기"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"채점 및 기타 정보","level":2,"id":"채점_및_기타_정보"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"3차 → 성공","level":3,"id":"3차_→_성공"},{"heading":"-차 → 틀림.","level":3,"id":"-차_→_틀림."},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/소수-구하기.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247241,"modifiedTime":1709035530474,"sourceSize":3151,"sourcePath":"1. Study/Coding Test/PS/소수 구하기.md","exportPath":"1.-study/coding-test/ps/소수-구하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/수-찾기.html":{"title":"수 찾기","icon":"","description":"ID: 1920\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1920\" target=\"_self\">https://www.acmicpc.net/problem/1920</a>\n난이도: 실버 4\n다시풀기: Yes\n분류: 이분탐색, 자료구조, 정렬\n생성 일시: 2023년 4월 17일 오후 7:36binary search 제대로 구현해보N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231&nbsp;보다 크거나 같고 231보다 작다.M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.5\n4 1 5 2 3\n5\n1 3 7 9 5 복사1\n1\n0\n0\n1 복사\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/BaaaaaaaaaaarkingDog\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/BaaaaaaaaaaarkingDog\" target=\"_self\">BaaaaaaaaaaarkingDog</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/bupjae\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/bupjae\" target=\"_self\">bupjae</a>\n<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/tncks0121\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/tncks0121\" target=\"_self\">tncks0121</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/175\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/175\" target=\"_self\">자료 구조</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/97\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/97\" target=\"_self\">정렬</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/12\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/12\" target=\"_self\">이분 탐색</a> 입력받으면서 정렬. 정수의 범위(-2^31≤ n &lt;2^31)가 정수의 개수(100000)보다 많이 크기때문에, indexing방식으로 list에 삽입 하는 것은 비효율 적이다.\n다 받아서 병합정렬하자. M도 입력 받으면서 정렬\n다음 탐색에서는 현재 M보다 큰 N에서부터 탐색시작하면 됨.\nimport sys def merge_sort(lst): if len(lst) == 1: return lst else: mid = (len(lst) // 2) a_lst = merge_sort(lst[:mid]) b_lst = merge_sort(lst[mid:]) merge_lst = [] while True: if len(a_lst) == 0: merge_lst += b_lst break elif len(b_lst) ==0: merge_lst += a_lst break else: if a_lst[0] &lt; b_lst[0]: merge_lst.append(a_lst.pop(0)) else: merge_lst.append(b_lst.pop(0)) return merge_lst def searching(base, check, M): i = 0 while i != M: for j in range(len(base)): if check[i] == base[j]: base = base[j+1:] print(1) break elif check[i] &lt; base[j]: base = base[j-1:] print(0) break if len(base) == 0: for i in range(M-i-1): print(0) break i+=1 def solution(): N = int(sys.stdin.readline().rstrip()) N_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split()))) M = int(sys.stdin.readline().rstrip()) M_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split()))) searching(N_lst, M_lst, M) if __name__ == \"__main__\": solution()\n복사\n바보다… 출력하는 순서가… 이게 아니잖아…ㅠ\n출력 순서를 정렬해 버림. 그럼 후자를 정렬안하고 하는 방법을 찾아야하는데, 그런 바이너리 서치가 최선이네.\nimport sys def merge_sort(lst): if len(lst) == 1: return lst else: mid = (len(lst) // 2) a_lst = merge_sort(lst[:mid]) b_lst = merge_sort(lst[mid:]) merge_lst = [] while True: if len(a_lst) == 0: merge_lst += b_lst break elif len(b_lst) ==0: merge_lst += a_lst break else: if a_lst[0] &lt; b_lst[0]: merge_lst.append(a_lst.pop(0)) else: merge_lst.append(b_lst.pop(0)) return merge_lst def searching(base, check): start = 0 end = len(base)-1 while True: mid = start + (end-start)//2 if end &lt; start: print(0) break if check == base[mid]: print(1) break elif check &lt; base[mid]: end = mid else: start = mid+1 def solution(): N = int(sys.stdin.readline().rstrip()) N_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split()))) M = int(sys.stdin.readline().rstrip()) M_lst = list(map(int, sys.stdin.readline().rstrip().split())) for i in M_lst: searching(N_lst, i) if __name__ == \"__main__\": solution()\n복사\nbreak point가 잘못된듯 합니다…\nimport sys def merge_sort(lst): if len(lst) == 1: return lst else: mid = (len(lst) // 2) a_lst = merge_sort(lst[:mid]) b_lst = merge_sort(lst[mid:]) merge_lst = [] while True: if len(a_lst) == 0: merge_lst += b_lst break elif len(b_lst) ==0: merge_lst += a_lst break else: if a_lst[0] &lt; b_lst[0]: merge_lst.append(a_lst.pop(0)) else: merge_lst.append(b_lst.pop(0)) return merge_lst def searching(base, check): start = 0 end = len(base)-1 while True: mid = start + (end-start)//2 if check == base[mid]: print(1) break if end &lt;= start: print(0) break if check &lt; base[mid]: end = mid else: start = mid+1 def solution(): N = int(sys.stdin.readline().rstrip()) N_lst = merge_sort(list(map(int, sys.stdin.readline().rstrip().split()))) M = int(sys.stdin.readline().rstrip()) M_lst = list(map(int, sys.stdin.readline().rstrip().split())) for i in M_lst: searching(N_lst, i) if __name__ == \"__main__\": solution()\n복사input()\na = set(input().split())\ninput()\nanswer = '\\n'.join('1' if x in a else '0' for x in input().split())\nprint(answer, end='')\n복사\n그냥 in 써도 돼는거 실화냐?\n하….\n앞으로는 다 구현\n파이썬 기능이용해서 간단하게 구현 둘 다 해보자. 입력받는 string list를 바로 int list로 바꾸는 방법\nN_lst = list(map(int, sys.stdin.readline().rstrip().split()))\n복사 // : 몫 → 내림 binary search 할 때 base list를 바꾸는 게 아니라, start, end index로 다뤄줘야해.\nend index는 그 끝까지 도달할 경우를 고려해서 len(list)“-1”로 해야함\nmid 값은 그냥 나누면 끝이 아니라 그값은 start에 더해줘야해. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"수 찾기","level":1,"id":"수 찾기"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"1차 틀림","level":3,"id":"1차_틀림"},{"heading":"2차 시간초과","level":3,"id":"2차_시간초과"},{"heading":"3차 정답","level":3,"id":"3차_정답"},{"heading":"다른사람 코드","level":3,"id":"다른사람_코드"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/수-찾기.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247205,"modifiedTime":1709035530515,"sourceSize":7445,"sourcePath":"1. Study/Coding Test/PS/수 찾기.md","exportPath":"1.-study/coding-test/ps/수-찾기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/수들의-합2.html":{"title":"수들의 합2","icon":"","description":"ID: 2003\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/2003\" target=\"_self\">https://www.acmicpc.net/problem/2003</a>\n난이도: 실버 4\n다시풀기: Yes\n분류: 누적 합, 두 포인터, 브루트포스 알고리즘\n생성 일시: 2023년 8월 5일 오전 3:09N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i] + A[i+1] + … + A[j-1] + A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.첫째 줄에 N(1 ≤ N ≤ 10,000), M(1 ≤ M ≤ 300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.첫째 줄에 경우의 수를 출력한다.4 2\n1 1 1 1 복사3 복사10 5\n1 2 3 4 2 5 3 1 1 2 복사3 복사\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/isku\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/isku\" target=\"_self\">isku</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/vvipconcert\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/vvipconcert\" target=\"_self\">vvipconcert</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/125\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/125\" target=\"_self\">브루트포스 알고리즘</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/139\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/139\" target=\"_self\">누적 합</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/80\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/80\" target=\"_self\">두 포인터</a> test_cast list를 두고 adding case를 다 저장하면서 진행\n새 숫자가 나오면 그 숫자가 i가 되는 case를 list에 추가(현재 합 0)\n존재하는 case에 새 숫자를 다 더함.\nM과의 비교를 통해 test case list 처리\nimport sys def sum_of_num(): N, M = map(int, sys.stdin.readline().split()) sequence = sys.stdin.readline().rstrip().split() test_case = [] result_case = 0 for num in sequence: num = int(num) if num &gt; M: test_case.clear() continue test_case.append(0) cut = 0 for idx in reversed(range(len(test_case))): test_case[idx] += num if test_case[idx] == M: result_case += 1 cut = idx + 1 elif test_case[idx] &gt; M: cut = idx + 1 test_case = test_case[cut:] print(result_case) if __name__ == \"__main__\": sum_of_num()\n복사 근데 시간 초과… 그려면 한 숫자에 고정하고서(그러니까 start point를 고정하고서) 찾고, 다음 start point로 넘어가는 식으로.. 복사복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"수들의 합2","level":1,"id":"수들의 합2"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/수들의-합2.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247190,"modifiedTime":1709035530522,"sourceSize":2688,"sourcePath":"1. Study/Coding Test/PS/수들의 합2.md","exportPath":"1.-study/coding-test/ps/수들의-합2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/숫자-카드-2.html":{"title":"숫자 카드 2","icon":"","description":"ID: 10816\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/10816\" target=\"_self\">https://www.acmicpc.net/problem/10816</a>\n난이도: 실버 4\n다시풀기: No\n분류: 이분탐색, 자료구조, 정렬, 해시를 사용한 집합과 맵\n생성 일시: 2023년 4월 20일 오후 9:23숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이&nbsp;주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.10\n6 3 2 10 10 10 -10 -10 7 3\n8\n10 9 -5 2 3 4 5 -10 복사3 0 0 1 2 0 0 2 복사\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/cko301\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/cko301\" target=\"_self\">cko301</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/mwy3055\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/mwy3055\" target=\"_self\">mwy3055</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/wkd48632\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/wkd48632\" target=\"_self\">wkd48632</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/emppu\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/emppu\" target=\"_self\">emppu</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/175\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/175\" target=\"_self\">자료 구조</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/97\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/97\" target=\"_self\">정렬</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/12\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/12\" target=\"_self\">이분 탐색</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/136\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/136\" target=\"_self\">해시를 사용한 집합과 맵</a> max 값을 찾아서, 나머지를 index로 하면, list 크기 줄일 수 있어서 좋은데,,,\n이게, 음수가 있어서 헷갈리네.\n그러면 나머지 구하고 양수에는 +max 한 index에 저장하기로 하자.\n그런데 결과 담긴 list를 한바퀴 돌리는게 아니라, 그냥 접근하는 거니까. 굳이 크기를 줄일 필요 없지 않나? import sys def solution(): lst = [0]*20000000 N = int(sys.stdin.readline().rstrip()) N_lst = list(map(int, sys.stdin.readline().rstrip().split())) M = int(sys.stdin.readline().rstrip()) M_lst = list(map(int, sys.stdin.readline().rstrip().split())) i,j = 0,0 result = [] while i &lt; N: num = N_lst[i] lst[num+10000000-1] += 1 i+=1 while j &lt; M: num = M_lst[j] result.append(str(lst[num+10000000-1])) j+=1 print(\" \".join(result)) if __name__ == \"__main__\": solution()\n복사\n시간 너무 많이 걸리는듯 합니다…\n한번에 받겠다, max min 찾아서 하지 뭐.\nimport sys def solution(): N = int(sys.stdin.readline().rstrip()) N_lst = list(map(int, sys.stdin.readline().rstrip().split())) M = int(sys.stdin.readline().rstrip()) M_lst = list(map(int, sys.stdin.readline().rstrip().split())) i,j = 0,0 result = [] maximum = max(N_lst) minimum = min(N_lst) length = maximum - minimum lst = [0]*length plus = length//2 while i &lt; N: num = N_lst[i] lst[num+plus-1] += 1 i+=1 while j &lt; M: num = M_lst[j] result.append(str(lst[num+plus-1])) j+=1 print(\" \".join(result)) if __name__ == \"__main__\": solution()\n복사ㅇ\n신기하게 이러니까 양끝 값이 이상해졌어…! 짱신기… 왜지?\n생각해보니까, 반으로 하면, index가 음수인 경우가 생겨서 이상해지겠다…\nrㅡ리고 length는 항상 +1 해주기\nimport sys def solution(): N = int(sys.stdin.readline().rstrip()) N_lst = list(map(int, sys.stdin.readline().rstrip().split())) M = int(sys.stdin.readline().rstrip()) M_lst = list(map(int, sys.stdin.readline().rstrip().split())) i,j = 0,0 result = [] maximum = max(N_lst)**2 minimum = min(N_lst)**2 half = int(max(maximum,minimum)**1/2) length = half * 2 + 1 lst = [0]*length while i &lt; N: num = N_lst[i] lst[num+half-1] += 1 i+=1 while j &lt; M: num = M_lst[j] result.append(str(lst[num+half-1])) j+=1 print(\" \".join(result)) if __name__ == \"__main__\": solution()뮤ㅇ 복사\nㅇ\nabs로 안하려고 제곱했더니, 메모리 초과ㅋㅋㅋㅋㅋ join 할거면 str으로 저장해줘야된다고!!!!!!\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"숫자 카드 2","level":1,"id":"숫자 카드 2"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After","level":2,"id":"After"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/숫자-카드-2.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247171,"modifiedTime":1709035530533,"sourceSize":5172,"sourcePath":"1. Study/Coding Test/PS/숫자 카드 2.md","exportPath":"1.-study/coding-test/ps/숫자-카드-2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/스위치-켜고-끄기.html":{"title":"스위치 켜고 끄기","icon":"","description":"ID: 1244\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1244\" target=\"_self\">https://www.acmicpc.net/problem/1244</a>\n난이도: 실버 4\n다시풀기: No\n생성 일시: 2023년 5월 3일 오전 9:161부터 연속적으로 번호가 붙어있는 스위치들이 있다. 스위치는 켜져 있거나 꺼져있는 상태이다. &lt;그림 1&gt;에 스위치 8개의 상태가 표시되어 있다. ‘1’은 스위치가 켜져 있음을, ‘0’은 꺼져 있음을 나타낸다. 그리고 학생 몇 명을 뽑아서, 학생들에게 1 이상이고 스위치 개수 이하인 자연수를 하나씩 나누어주었다. 학생들은 자신의 성별과 받은 수에 따라 아래와 같은 방식으로 스위치를 조작하게 된다.남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다. &lt;그림 1&gt;과 같은 상태에서 남학생이 3을 받았다면, 이 학생은 &lt;그림 2&gt;와 같이 3번, 6번 스위치의 상태를 바꾼다.여학생은 자기가 받은 수와 같은 번호가 붙은 스위치를 중심으로 좌우가 대칭이면서 가장 많은 스위치를 포함하는 구간을 찾아서, 그 구간에 속한 스위치의 상태를 모두 바꾼다. 이때 구간에 속한 스위치 개수는 항상 홀수가 된다.&lt;그림 1&gt;예를 들어 &lt;그림 2&gt;에서 여학생이 3을 받았다면, 3번 스위치를 중심으로 2번, 4번 스위치의 상태가 같고 1번, 5번 스위치의 상태가 같으므로, &lt;그림 3&gt;과 같이 1번부터 5번까지 스위치의 상태를 모두 바꾼다. 만약 &lt;그림 2&gt;에서 여학생이 4를 받았다면, 3번, 5번 스위치의 상태가 서로 다르므로 4번 스위치의 상태만 바꾼다.&lt;그림 2&gt;&lt;그림 3&gt;입력으로 스위치들의 처음 상태가 주어지고, 각 학생의 성별과 받은 수가 주어진다. 학생들은 입력되는 순서대로 자기의 성별과 받은 수에 따라 스위치의 상태를 바꾸었을 때, 스위치들의 마지막 상태를 출력하는 프로그램을 작성하시오.첫째 줄에는 스위치 개수가 주어진다. 스위치 개수는 100 이하인 양의 정수이다. 둘째 줄에는 각 스위치의 상태가 주어진다. 켜져 있으면 1, 꺼져있으면 0이라고 표시하고 사이에 빈칸이 하나씩 있다. 셋째 줄에는 학생수가 주어진다. 학생수는 100 이하인 양의 정수이다. 넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수가 주어진다. 남학생은 1로, 여학생은 2로 표시하고, 학생이 받은 수는 스위치 개수 이하인 양의 정수이다. 학생의 성별과 받은 수 사이에 빈칸이 하나씩 있다.스위치의 상태를 1번 스위치에서 시작하여 마지막 스위치까지 한 줄에 20개씩 출력한다. 예를 들어 21번 스위치가 있다면 이 스위치의 상태는 둘째 줄 맨 앞에 출력한다. 켜진 스위치는 1, 꺼진 스위치는 0으로 표시하고, 스위치 상태 사이에 빈칸을 하나씩 둔다.8\n0 1 0 1 0 0 0 1\n2\n1 3\n2 3 복사1 0 0 0 1 1 0 1\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 복사<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/2\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/2\" target=\"_self\">Olympiad</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/55\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/55\" target=\"_self\">한국정보올림피아드</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/78\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/78\" target=\"_self\">KOI 2000</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/391\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/391\" target=\"_self\">초등부</a>&nbsp;2번\n출력 형식 때문에 6번째에 맞췄다…\nimport sys def solution(): # 입력 N = int(sys.stdin.readline().rstrip()) switches = [*map(int, sys.stdin.readline().rstrip().split())] people = int(sys.stdin.readline().rstrip()) cnt = 0 #연산 while cnt &lt; people: sex, num = map(int, sys.stdin.readline().rstrip().split()) # 남 if sex == 1: idx = num-1 while idx &lt; len(switches): switches[idx] = switches[idx]*(-1) + 1 idx += num # 여 elif sex == 2: full_length = min(num, N-(num-1)) idx = num-1 switches[idx] = switches[idx]*(-1) + 1 for i in range(1, full_length): if switches[idx+i] != switches[idx-i]: break switches[idx+i] = switches[idx+i]*(-1) + 1 switches[idx-i] = switches[idx-i]*(-1) + 1 cnt +=1 # 출력 for j in range(0, N, 20): print(*switches[j:j+20*(j+1)]) if __name__ == \"__main__\": solution()\n복사 2) 한 줄의 여러 정수 입력받기 - 리스트로\nli = [*map(int,input().split())]\n복사 input().split()은 사용자로부터 받은 입력을 공백을 구분자로 나누어 리스트로 바꾸는 기능입니다. 여기에 map함수를 통해, 각 원소를 int형으로 바꿔주게 됩니다. 즉, input().split()이 반환하는 건 리스트이고,&nbsp;map(int, 리스트)를 통해 리스트의 각 원소를 정수로 바꿔주는 것입니다. 앞에&nbsp;*(에스터리크)는&nbsp;unpacking기능으로,&nbsp;[*map객체]를 하면 map객체가 unpacking 되고, []에 의해 리스트화 됩니다. 즉, map에 의해 각 원소가 정수로 바뀐 것을 다시 리스트로 바꿔주는 것입니다\n<br>출처: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://bio-info.tistory.com/157\" target=\"_self\">https://bio-info.tistory.com/157</a> bitwise 연산\n# 비트 연산자(Bitwise Operators)\na = 0b10101010\nb = 0b01110011 print('a = ', a, \":\", bin(a))\nprint('b = ', b, \":\", bin(b))\nprint('a &amp; b = ', a &amp; b, \":\", bin(a &amp; b))\nprint('a | b = ', a | b, \":\", bin(a | b))\nprint('a ^ b = ', a ^ b, \":\", bin(a ^ b))\nprint('~a = ', ~a, \":\", bin(~a)) a = 0b1\nprint('a = ', a)\na = a &lt;&lt; 1 # * 2\nprint('a = ', a)\na = a &lt;&lt; 1 # * 2\nprint('a = ', a)\na = a &lt;&lt; 3 # * 2**3\nprint('a = ', a) a = a &gt;&gt; 1 # / 2\nprint('a = ', a)\na = a &gt;&gt; 1 # / 2\nprint('a = ', a)\na = a &gt;&gt; 2 # / 2**2\nprint('a = ', a) 복사 실행 결과\na = 170 : 0b10101010\nb = 115 : 0b1110011\na &amp; b = 34 : 0b100010\na | b = 251 : 0b11111011\na ^ b = 217 : 0b11011001\n~a = -171 : -0b10101011 a = 1\na = 2\na = 4\na = 32 a = 16\na = 8\na = 2\n복사 int()는 버림 연산 biswise 안 쓰고, 0,1 변환\nlst[i]*(-1) + 1\n복사 input으로 int list만들때,\nswitches = list(map(int, sys.stdin.readline().rstrip().split()))\nswitches = [*map(int, sys.stdin.readline().rstrip().split())]\n복사 둘 중 후자가 더 빠름 깔끔하게 출력하기 문자열 만들어서 띄어쓰기 넣고 하는 것보다, 그냥 띄어쓰기면 이게 훨씬 깔끔.\n특정구간마다 줄바꿈이 필요하면 range step으로 설정해주기. for j in range(0, len(switches), 20): print(*switches[j:j+20*(j+1)])\n복사 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"스위치 켜고 끄기","level":1,"id":"스위치 켜고 끄기"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/스위치-켜고-끄기.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247092,"modifiedTime":1709035530537,"sourceSize":8067,"sourcePath":"1. Study/Coding Test/PS/스위치 켜고 끄기.md","exportPath":"1.-study/coding-test/ps/스위치-켜고-끄기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/영화감독-숌.html":{"title":"영화감독 숌","icon":"","description":"ID: 1436\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1436\" target=\"_self\">https://www.acmicpc.net/problem/1436</a>\n난이도: 실버 5\n다시풀기: Yes\n분류: 브루트포스 알고리즘\n생성 일시: 2023년 4월 11일 오후 2:21“brute-force말고 최적화 해서 풀어보기”666은 종말을 나타내는 수라고 한다. 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다. 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다. 조지 루카스는 스타워즈를 만들 때, 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고, 피터 잭슨은 반지의 제왕을 만들 때, 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다. 하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서 영화 제목을 좀 다르게 만들기로 했다.종말의 수란 어떤 수에 6이 적어도 3개 이상 연속으로 들어가는 수를 말한다. 제일 작은 종말의 수는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 이다. 따라서, 숌은 첫 번째 영화의 제목은 \"세상의 종말 666\", 두 번째 영화의 제목은 \"세상의 종말 1666\"와 같이 이름을 지을 것이다. 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 수) 와 같다.숌이 만든 N번째 영화의 제목에 들어간 수를 출력하는 프로그램을 작성하시오. 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.첫째 줄에 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.2\n복사1666\n복사3\n복사2666\n복사6 복사5666 복사187 복사66666 복사500 복사166699 복사\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/mwy3055\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/mwy3055\" target=\"_self\">mwy3055</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/125\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/125\" target=\"_self\">브루트포스 알고리즘</a> 666을 숫자 6으로 치환해서,,,?\n그러면 진짜 그냥 6인데 그것도 666으로 변환시킬 우려가 생김.\n써보자 0,1,2,3,4,5 (+) 666\n666 (+) 0,1,2,3,4,5\n6666\n7,8,9 (+) 666 special 6 6` == 666\n16` == 1000 +666 = 666+(n-1)*1000\n26` == 2000 + 666 = 666+(n-1)*1000\n36` == 3000 + 666 = 666+(n-1)*1000\n46` == 4000 + 666 = 666+(n-1)*1000\n56`== 5000 + 666 = 666+(n-1)*1000 0≤(n-7)≤9 6`0 == 66610 = 66610 + n-7\n6`1 == 66610 +1 = 66610 + n-7\n6`2 == 66610 +2 = 66610 + n-7\n6`3 == 66610+3 = 66610 + n-7\n6`4 == 66610+4 = 66610 + n-7\n6`5 == 66610+5 = 66610 + n-7\n6`6 == 66610+6 = 66610 + n-7\n6`7 == 66610+7 = 66610 + n-7\n6`8 == 66610+8 = 66610 + n-7\n6`9 == 66610+9 = 66610 + n-7\n106` == 10000 + 666\n116` == 11000 + 666\n126` == 12000 + 666\n136` == 13000 + 666\n146` == 14000 + 666\n156` == 15000 + 666\n16`0 == 666*10 + 10000\n16`1 == 666*10 + 10001\n16`2 == 666*10 + 10002\n16`3 == 666*10 + 10003 6을 하나만 6으로 부풀리는 식으로 해보자. 6` == 6\n16` == 10+6\n26` == 10\n36` == 3000 + 666 = 666+(n-1)*1000\n46` == 4000 + 666 = 666+(n-1)*1000\n56`== 5000 + 666 = 666+(n-1)*1000 0≤(n-7)≤9 6`0 == 66610 = 66610 + n-7\n6`1 == 66610 +1 = 66610 + n-7\n6`2 == 66610 +2 = 66610 + n-7\n6`3 == 66610+3 = 66610 + n-7\n6`4 == 66610+4 = 66610 + n-7\n6`5 == 66610+5 = 66610 + n-7\n6`6 == 66610+6 = 66610 + n-7\n6`7 == 66610+7 = 66610 + n-7\n6`8 == 66610+8 = 66610 + n-7\n6`9 == 66610+9 = 66610 + n-7\n106` == 10000 + 666\n116` == 11000 + 666\n126` == 12000 + 666\n136` == 13000 + 666\n146` == 14000 + 666\n156` == 15000 + 666\n16`0 == 666*10 + 10000\n16`1 == 666*10 + 10001\n16`2 == 666*10 + 10002\n16`3 == 666*10 + 10003 6빼고 생각해보자 666 1- + 666\n2- + 666\n3- + 666\n4- + 666\n5- + 666 666*10 -1 + 666*10\n-2 + 666*10\n-3 + 666*10\n-4 + 666*10\n-5 + 666*10\n-6 + 666*10\n-7 + 666*10\n-8 + 666*10\n-9 + 666*10\n7-\n8-\n9- 10-\n11-\n12-\n13-\n14-\n15-\n1-0\n1-1\n1-2\n1-3\n1-4\n1-5\n1-6\n1-7\n1-8\n1-9\n17-\n18-\n19-\n20-\n→ 16 진수 식으로\n아님 재귀함수… 앞의 값 뒤의값?\n6을만나면 퍼진다…? 01,2,3,4,5,(6→ 0123456789, 7,8,9\n10,11,12,13,14,15,1(6→0,1,2,3,4,5,6,7,8,9) 7,8,9\n20\n30\n40\n50\n60,61,62,63,64,65,(→00, 01,02,03,04,05,06,07,08,09) import sys def solution(): N = int(sys.stdin.readline().rstrip()) num = 0 cnt = 0 while True: num += 1 if '666' in str(num): cnt += 1 if cnt == N: break print(num) if __name__ == \"__main__\": solution()\n복사\n결국 brute-force로 품…\n근데 최적화를 해야한다면?\n공식을 찾고 싶었는데 그러지 못해서 질문계시판의 도움을 받기로 했다.\n1. 1이상 10^18미만의 정수 중에 문자열에 12가 포함된 수의 개수를 구하시오. 2. 1이상 10^18미만의 정수 중에 '종말의 수'의 개수를 구하시오. -------------------------------------- 먼저 위 두 문제를 풀어보시기 바랍니다. *** 앞에 6이 추가되기 전에는 종말의 수가 아니었는데 추가돼서 새롭게 종말의 수가 된 종말의 수를 생각해보죠.\n복사\n(1≤N&lt;10**18) k자리수에서 12포함 1 자리수일때 0개\n2의 자리수일때 1개\n3의 자리수일때 9+10개\n4의 자리수일때 910(# __12)+910(# 12) + 10*10(# 12__)개\n5의 자리수일때 91010 + 91010 + 91010 ⇒ 12의 자리를 구하는 경우의 수 → k_C_2\n⇒ 나머지 빈 자리를 채우는 경우의 수 → 9*10(k-3) or 10(k-2) ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"영화감독 숌","level":1,"id":"영화감독 숌"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제 입력 1","level":3,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":3,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":3,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":3,"id":"예제_출력_2"},{"heading":"예제 입력 3","level":3,"id":"예제_입력_3"},{"heading":"예제 출력 3","level":3,"id":"예제_출력_3"},{"heading":"예제 입력 4","level":3,"id":"예제_입력_4"},{"heading":"예제 출력 4","level":3,"id":"예제_출력_4"},{"heading":"예제 입력 5","level":3,"id":"예제_입력_5"},{"heading":"예제 출력 5","level":3,"id":"예제_출력_5"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"1차 제출 → 성공","level":3,"id":"1차_제출_→_성공"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/영화감독-숌.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247079,"modifiedTime":1709035530542,"sourceSize":6712,"sourcePath":"1. Study/Coding Test/PS/영화감독 숌.md","exportPath":"1.-study/coding-test/ps/영화감독-숌.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/요세푸스-문제.html":{"title":"요세푸스 문제","icon":"","description":"ID: 1158\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1158\" target=\"_self\">https://www.acmicpc.net/problem/1158</a>\n난이도: 실버 4\n다시풀기: Yes\n분류: 구현, 자료구조, 큐\n생성 일시: 2023년 5월 2일 오후 9:26요세푸스 문제는 다음과 같다.1번부터 N번까지 N명의 사람이 원을 이루면서&nbsp;앉아있고, 양의 정수 K(≤ N)가&nbsp;주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &lt;3, 6, 2, 7, 5, 1, 4&gt;이다.N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)예제와 같이 요세푸스 순열을 출력한다.7 3 복사&lt;3, 6, 2, 7, 5, 1, 4&gt; 복사\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/author5\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/author5\" target=\"_self\">author5</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/102\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/102\" target=\"_self\">구현</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/175\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/175\" target=\"_self\">자료 구조</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/72\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/72\" target=\"_self\">큐</a> 비슷한 문제 푼 기억이 있는데,,,\ndeque를 쓸지 그냥 list로 구현할지…\n둘다 한번 해보자 list로 구현 엥. 잠시만 list를 쓸 필요도 없는데?\nimport sys, collections def solution(): N, K = map(int, sys.stdin.readline().rstrip().split()) i = K que = collections.deque([x for x in range(1, N+1)]) result_que = collections.deque([]) while len(que) &gt; 0: que.append(que.popleft()) que.append(que.popleft()) result_que.append(str(que.popleft())) print(\"&lt;\" + \", \".join(result_que) + \"&gt;\") if __name__ == \"__main__\": solution()\n복사\n예제만 적용가능하게 만들어 놨음. K입력값에 따라 변하게 만들어야함.\nimport sys, collections def solution(): N, K = map(int, sys.stdin.readline().rstrip().split()) que = collections.deque([x for x in range(1, N+1)]) result_que = collections.deque([]) while len(que) &gt; 0: for _ in range(K-1): que.append(que.popleft()) result_que.append(str(que.popleft())) print(\"&lt;\" + \", \".join(result_que) + \"&gt;\") if __name__ == \"__main__\": solution()\n복사 만약 N=K면, 시간 복잡도는 O(N^2) marge sort를 가져다 써볼까? 나누고 합치고 나누고 합치고의 반복\n7 3일 경우 12(3) 45(6) 7로 나누고\n71245이됨 import sys def marge_pop(lst, i, cnt, r): result = [] for _ in range(cnt): result += lst[:i-1] r.append(str(lst[i-1])) lst = lst[i:] if len(lst)&gt;0: result = lst + result return result,r def solution(): N, K = map(int, sys.stdin.readline().rstrip().split()) lst = [x for x in range(1,N+1)] result = [] while len(lst) &gt; 0: cnt = len(lst) // K lst, result = marge_pop(lst, K, cnt, result) print(\"&lt;\"+\", \".join(result)+\"&gt;\") if __name__ == \"__main__\": solution()\n복사 마지막에 남겨지는 애들을 print할 방도가 없 import sys def marge_pop(lst, i, cnt, r): result = [] if cnt == 0: i = i%len(lst) cnt = 1 for _ in range(cnt): result += lst[:i-1] r.append(str(lst[i-1])) lst = lst[i:] if len(lst)&gt;0: result = lst + result return result,r def solution(): N, K = map(int, sys.stdin.readline().rstrip().split()) lst = [x for x in range(1,N+1)] result = [] while len(lst) &gt; 0: cnt = len(lst) // K lst, result = marge_pop(lst, K, cnt, result) print(\"&lt;\"+\", \".join(result)+\"&gt;\") if __name__ == \"__main__\": solution()\n복사 해보긴 했는데 2개 남았을때 까지는 어케 됐는데, 이제는 안됨.\n예제 몇개 더 생성\n10 9\n&lt;9, 8, 10, 2, 5, 3, 4, 1, 6, 7&gt; 10 1\n&lt;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&gt; 15 7\n&lt;7, 14, 6, 15, 9, 3, 13, 11, 10, 12, 2, 8, 1, 4, 5&gt; 15 4\n&lt;4, 8, 12, 1, 6, 11, 2, 9, 15, 10, 5, 3, 7, 14, 13&gt; 15 3\n&lt;3, 6, 9, 12, 15, 4, 8, 13, 2, 10, 1, 11, 7, 14, 5&gt;\n복사 ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"요세푸스 문제","level":1,"id":"요세푸스 문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"1차 : ❌","level":3,"id":"1차__❌"},{"heading":"2차 : ⭕ |❓ (당황스러울 정도로 시간이 길다…)","level":3,"id":"2차__⭕_|❓_(당황스러울_정도로_시간이_길다…)"},{"heading":"After:","level":2,"id":"After"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/요세푸스-문제.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247049,"modifiedTime":1709035530557,"sourceSize":5251,"sourcePath":"1. Study/Coding Test/PS/요세푸스 문제.md","exportPath":"1.-study/coding-test/ps/요세푸스-문제.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/요세푸스-문제-0.html":{"title":"요세푸스 문제 0","icon":"","description":"ID: 11866\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/11866\" target=\"_self\">https://www.acmicpc.net/problem/11866</a>\n난이도: 실버 5\n다시풀기: No\n분류: 구현, 자료구조, 큐\n생성 일시: 2023년 4월 13일 오후 4:24요세푸스 문제는 다음과 같다.1번부터 N번까지 N명의 사람이 원을 이루면서&nbsp;앉아있고, 양의 정수 K(≤ N)가&nbsp;주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &lt;3, 6, 2, 7, 5, 1, 4&gt;이다.N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.첫째 줄에 N과 K가&nbsp;빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 1,000)예제와 같이 요세푸스 순열을 출력한다.\n## 예제 출력 1 복사&lt;3, 6, 2, 7, 5, 1, 4&gt;\n## 출처 - 문제를 만든 사람:&nbsp;[baekjoon](https://www.acmicpc.net/user/baekjoon) ## 알고리즘 분류 - [구현](https://www.acmicpc.net/problem/tag/102)\n- [자료 구조](https://www.acmicpc.net/problem/tag/175)\n- [큐](https://www.acmicpc.net/problem/tag/72) ## Before: 생각 - 이게 대체 왜 큐인가… 하는 생각에 linked list에 더 집중해버림… - linking을 interval간격으로 하려니 너무 복잡하더라… - 뺐다 넣고를 반복하면(print하는 건 삭제한채로 계속 새로 집어넣음.) 그러며는 따로 index 계산할 필요 없이 그냥 interval만큼 더해주면 됨. ```python\nimport sys def solution(): N, flag = map(int, sys.stdin.readline().rstrip().split()) lst = [x for x in range(1, N+1)] length = N cnt = 0 result =\"&lt;\" while length &gt;0: if cnt == flag-1: result += str(lst.pop(0)) + \", \" cnt = 0 length -= 1 else: x = lst.pop(0) lst.append(x) cnt += 1 print(result[:-2] +\"&gt;\") if __name__ == \"__main__\": solution()\n복사\n나는 120초인데,,,, 32초까지 줄일 수 있음… 여기는 계속 추가하는 방식이 아님.\nindex는 interval - 1만큼씩 커짐. 왜냐면 pop으로 항상 지워주니까\nindex가 길이보다 클 때, 현재 길이로 나눈 나머지로 바꿔줌 import sys def solution(): N, gap = map(int, sys.stdin.readline().rstrip().split()) lst = [x for x in range(1, N+1)] idx = gap-1 result =\"&lt;\" while lst: if idx &gt;= len(lst): idx %= len(lst) result += str(lst.pop(idx))+\", \" idx += gap-1 print(result[:-2] +\"&gt;\") if __name__ == \"__main__\": solution()\n복사 que FIFO\nstack과 반\n<br>환형 큐[<a data-tooltip-position=\"top\" aria-label=\"https://ko.wikipedia.org/w/index.php?title=%ED%81%90_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)&amp;action=edit&amp;section=4\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ko.wikipedia.org/w/index.php?title=%ED%81%90_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)&amp;action=edit&amp;section=4\" target=\"_self\">편집</a>] 선형 큐의 문제점(배열로 큐를 선언할시 큐의 삭제와 생성이 계속 일어났을때, 마지막 배열에 도달후 실제로는 데이터공간이 남아있지만 오버플로우가 발생)을 보완한 것이 환형 큐이다. front가 큐의 끝에 닿으면 큐의 맨 앞으로 자료를 보내어 원형으로 연결 하는 방식이다.원형 큐라고도 한다. while [list] → list가 다 빌 때 까지 loop 돌림. pop이나 remove 잊지말기. 왜 값을 0으로 만드는 것밖에 생각을 못했을까? print(a,b,c, sep = ”;”) → abc를 공백으로 나누는 대신, ;로 나눠줌. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"요세푸스 문제 0","level":1,"id":"요세푸스 문제 0"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/요세푸스-문제-0.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247064,"modifiedTime":1709039714803,"sourceSize":3983,"sourcePath":"1. Study/Coding Test/PS/요세푸스 문제 0.md","exportPath":"1.-study/coding-test/ps/요세푸스-문제-0.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/제목-없음.html":{"title":"제목 없음","icon":"","description":"다시풀기: No\n생성 일시: 2023년 3월 10일 오후 4:36### 실패\ndef converting(cap, list): sum = 0 flag = 0 flaglist = [] for i in range(len(list)-1, -1, -1): sum += list[i] if sum &gt; flag: flag += cap flaglist.append(i+1) return flaglist def compare(list1, list2, len): result_list = [] for i in range(len): result_list.append(max(list1[i], list2[i])) return result_list def solution(cap, n, deliveries, pickups): d_flag = converting(cap, deliveries) p_flag = converting(cap, pickups) flag = [] print(d_flag, p_flag) d_len = len(d_flag) p_len = len(p_flag) if d_len == p_len: flag = compare(d_flag, p_flag, d_len) elif d_len &gt; p_len: alone = d_len - p_len d_alone = d_flag[:-alone] flag = compare(d_alone, p_flag, p_len) + d_flag[:alone] else: alone = p_len - d_len p_alone = -p_flag[:-alone] flag = compare(p_alone, d_flag, d_len) + p_flag[:alone] answer = sum(flag)*2 return answer\n복사\nflag를 2번 이상 씩 뛰어넘는 경우가 있으니까…\n### 성\ndef truck(lst, cap, home): result = [] box_sum = 0 pin = 0 turn = 0 while home &gt; 0: if box_sum &lt; pin + 1 &lt;= box_sum + lst[home-1]: result.append(home) pin += cap # print('pin', pin) else: box_sum += lst[home-1] home -= 1 turn += 1 # print('home', home) return result def compare(max_list, min_list): result = 0 max_len = len(max_list) min_len = len(min_list) for i in range(max_len): if i == min_len -1: result += sum(max_list[min_len-1:]) break result += max(max_list[i], min_list[i]) return result def solution(cap, n, deliveries, pickups): d_list = truck(deliveries, cap, n) p_list = truck(pickups, cap, n) if len(d_list) &gt;= len(p_list): answer = compare(d_list, p_list) else: answer = compare(p_list, d_list) return answer*2\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"제목 없음","level":1,"id":"제목 없음"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/제목-없음.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247035,"modifiedTime":1709035530573,"sourceSize":2286,"sourcePath":"1. Study/Coding Test/PS/제목 없음.md","exportPath":"1.-study/coding-test/ps/제목-없음.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/좌표-정렬.html":{"title":"좌표 정렬","icon":"","description":"ID: 11650\nSite: 백준\n난이도: 실버 5\n다시풀기: No\n분류: 정렬\n생성 일시: 2023년 4월 12일 오후 8:34import sys def solution(): N = int(sys.stdin.readline().rstrip()) lst = [] while N&gt;0: N-=1 x, y = map(int, sys.stdin.readline().split()) lst.append((x,y)) lst.sort() for i in range(len(lst)): lst[i] = str(lst[i][0])+\" \"+str(lst[i][1]) print(\"\\n\".join(lst)) if __name__ == \"__main__\": solution()\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"좌표 정렬","level":1,"id":"좌표 정렬"},{"heading":"문제","level":2,"id":"문제"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/좌표-정렬.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247017,"modifiedTime":1709035530583,"sourceSize":578,"sourcePath":"1. Study/Coding Test/PS/좌표 정렬.md","exportPath":"1.-study/coding-test/ps/좌표-정렬.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/집합.html":{"title":"집합","icon":"","description":"ID: 11723\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/11723\" target=\"_self\">https://www.acmicpc.net/problem/11723</a>\n난이도: 실버 5\n다시풀기: Yes\n분류: 구현, 비트마스킹\n생성 일시: 2023년 4월 20일 오전 11:06비트마스킹으로 다시 풀어보기.비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.\nadd x: S에 x를 추가한다. (1&nbsp;≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.\nremove&nbsp;x: S에서 x를 제거한다. (1&nbsp;≤ x ≤ 20)&nbsp;S에 x가 없는 경우에는 연산을 무시한다.\ncheck x: S에 x가 있으면 1을, 없으면 0을 출력한다.&nbsp;(1 ≤ x ≤ 20)\ntoggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1&nbsp;≤ x ≤ 20)\nall: S를 {1, 2, ..., 20} 으로 바꾼다.\nempty: S를 공집합으로 바꾼다.\n첫째 줄에 수행해야 하는 연산의 수 M (1 ≤ M ≤ 3,000,000)이 주어진다.둘째 줄부터 M개의 줄에 수행해야 하는 연산이 한 줄에 하나씩 주어진다.check&nbsp;연산이 주어질때마다, 결과를 출력한다.26\nadd 1\nadd 2\ncheck 1\ncheck 2\ncheck 3\nremove 2\ncheck 1\ncheck 2\ntoggle 3\ncheck 1\ncheck 2\ncheck 3\ncheck 4\nall\ncheck 10\ncheck 20\ntoggle 10\nremove 20\ncheck 10\ncheck 20\nempty\ncheck 1\ntoggle 1\ncheck 1\ntoggle 1\ncheck 1 복사1\n1\n0\n1\n0\n1\n0\n1\n0\n1\n1\n0\n0\n0\n1\n0 복사\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/houma757\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/houma757\" target=\"_self\">houma757</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/pichulia\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/pichulia\" target=\"_self\">pichulia</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/102\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/102\" target=\"_self\">구현</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/14\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/14\" target=\"_self\">비트마스킹</a> Java 8: 448 MB\nJava 8 (OpenJDK): 448 MB\nJava 11: 448 MB\nKotlin (JVM): 448 MB\nC#: 64 MB\nJava 15: 448 MB\nF#: 64 MB\nVisual Basic: 64 MB\n복사\n<br>비트마스킹 <a data-tooltip-position=\"top\" aria-label=\"https://travelbeeee.tistory.com/451\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://travelbeeee.tistory.com/451\" target=\"_self\">[알고리즘] 비트마스킹(bitmasking) 이란</a> not 0, not 1하면 true false나 <br>파이썬은 왜 느릴까. <a data-tooltip-position=\"top\" aria-label=\"https://y-joo.tistory.com/12\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://y-joo.tistory.com/12\" target=\"_self\">파이썬은 왜 느릴까? ( + 시간초과를 해결할 수 있는 몇몇 기술들)</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"집합","level":1,"id":"집합"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"메모리 제한","level":2,"id":"메모리_제한"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/집합.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885246956,"modifiedTime":1709035530589,"sourceSize":2708,"sourcePath":"1. Study/Coding Test/PS/집합.md","exportPath":"1.-study/coding-test/ps/집합.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/체스판-다시-칠하기.html":{"title":"체스판 다시 칠하기","icon":"","description":"ID: 1018\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1018\" target=\"_self\">https://www.acmicpc.net/problem/1018</a>\n난이도: 실버 4\n다시풀기: Yes\n분류: 브루트포스 알고리즘\n생성 일시: 2023년 4월 14일 오후 9:25<br>다시 풀 때 참고: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/source/54384536\" target=\"_self\">https://www.acmicpc.net/source/54384536</a> (시간 줄이기)지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M×N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8×8 크기의 체스판으로 만들려고 한다.체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8×8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.8 8\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBBBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW 복사1 복사10 13\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nBBBBBBBBWBWBW\nBBBBBBBBBWBWB\nWWWWWWWWWWBWB\nWWWWWWWWWWBWB 복사12 복사8 8\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB 복사0 복사9 23\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBB\nBBBBBBBBBBBBBBBBBBBBBBW 복사31 복사10 10\nBBBBBBBBBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBWBWBWBWB\nBWBWBWBWBB\nBBBBBBBBBB 복사0 복사8 8\nWBWBWBWB\nBWBWBWBW\nWBWBWBWB\nBWBBBWBW\nWBWBWBWB\nBWBWBWBW\nWBWBWWWB\nBWBWBWBW 복사2 복사11 12\nBWWBWWBWWBWW\nBWWBWBBWWBWW\nWBWWBWBBWWBW\nBWWBWBBWWBWW\nWBWWBWBBWWBW\nBWWBWBBWWBWW\nWBWWBWBBWWBW\nBWWBWBWWWBWW\nWBWWBWBBWWBW\nBWWBWBBWWBWW\nWBWWBWBBWWBW 복사15 복사\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a>\n<br>문제를 다시 작성한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/125\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/125\" target=\"_self\">브루트포스 알고리즘</a> 짝수줄 홀수줄 나눠서 생각 가능… 같은 수가 작은 홀수번 나오는 게 좋음…? 2,2,4,4인 경우도 있잖아… 홀수번 검사 짝수번 검사… 검사 반복 횟수는, m-8, n-8 2번 b시작 w시작 새 행렬 2개 하나만 들어서, 여기서 무슨 색으로 시작했을때, 얼마 칠해야하는 지 저장. input받아서 list 생성\nN-7, M-7 의 2중 반복문 생성\n0(M-7) 반복문에서, 0~7(N-7)까지\n1(M-7) 반복문에서 0~7(N-7)까지…?\n<br>앞부분 도움: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://ittrue.tistory.com/60\" target=\"_self\">https://ittrue.tistory.com/60</a>\nrow index + col index를 합친값을 %2 하면, 번갈아가면서 나오는 체스판 식의 값을 얻을 수 있음…\nW로 시작과 B로 시작은 저로 정반대이기 때문에, 하나만 검색하고, 칠해야할 min, max값만 저장해두고, 64-max 해서 둘 중에 min값을 구하면 됨.\nimport sys def solution(): N,M = map(int, sys.stdin.readline().rstrip().split(\" \")) lst = [] minimum = 64 maximum = 0 for i in range(N): row = sys.stdin.readline().rstrip() lst.append(row) for row in range(N-7): for col in range(M-7): now = 0 for i in range(row,row+8): for j in range(col,col+8): if (i+j)%2: label = \"W\" else: label = \"B\" if lst[i][j] != label: now += 1 if now &lt; minimum: minimum = now if now &gt; maximum: maximum = now print(min(minimum, (64-maximum))) if __name__ == \"__main__\": solution()\n복사\n정 안 되면, for문은 4개씩이나 겹쳐도 됨…. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"체스판 다시 칠하기","level":1,"id":"체스판 다시 칠하기"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"예제 입력 3","level":2,"id":"예제_입력_3"},{"heading":"예제 출력 3","level":2,"id":"예제_출력_3"},{"heading":"예제 입력 4","level":2,"id":"예제_입력_4"},{"heading":"예제 출력 4","level":2,"id":"예제_출력_4"},{"heading":"예제 입력 5","level":2,"id":"예제_입력_5"},{"heading":"예제 출력 5","level":2,"id":"예제_출력_5"},{"heading":"예제 입력 6","level":2,"id":"예제_입력_6"},{"heading":"예제 출력 6","level":2,"id":"예제_출력_6"},{"heading":"예제 입력 7","level":2,"id":"예제_입력_7"},{"heading":"예제 출력 7","level":2,"id":"예제_출력_7"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/체스판-다시-칠하기.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885246987,"modifiedTime":1709035530601,"sourceSize":5555,"sourcePath":"1. Study/Coding Test/PS/체스판 다시 칠하기.md","exportPath":"1.-study/coding-test/ps/체스판-다시-칠하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/카드2.html":{"title":"카드2","icon":"","description":"ID: 2164\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/2164\" target=\"_self\">https://www.acmicpc.net/problem/2164</a>\n난이도: 실버 4\n다시풀기: Yes\n분류: 자료구조, 큐\n생성 일시: 2023년 4월 20일 오후 4:58n,m = int(input()), 1\nwhile m&lt;n: # O(logn) m *= 2\nprint(2*n-m)\n복사내가 못하다 만 거 같은데, 제대로 이해해보기.N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.첫째 줄에 남게 되는 카드의 번호를 출력한다.6 복사4 복사\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/175\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/175\" target=\"_self\">자료 구조</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/72\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/72\" target=\"_self\">큐</a> 그냥 queue 써서 문제에 나온대로 쭉 쓰면 쉽게 풀려서 왜이렇게 쉽지? 했는데…\nimport sys def solution(): N = int(sys.stdin.readline().rstrip()) queue = [i+1 for i in range(N)] while len(queue) &gt; 1: queue.pop(0) card = queue.pop(0) queue.append(card) N -= 1 print(queue[0]) if __name__ == \"__main__\": solution()\n복사 pop이 많이 걸리나? 연산을 합칠 방법을 찾아봐야겠다… 첫 턴에 홀수만 빠지고 마지막이 짝수였으면 또다시 이전 start 바로 다음 수, 마지막이 홀수였으면 또다시 이전 start 다음다음다음 수...? 그러면 돌때마다 1/2씩 줄어드니까. logn import sys def solution(): N = int(sys.stdin.readline().rstrip()) end = N start = 1 spare = 0 # 첫 turn 끝난 카드 list queue = [2*i for i in range(N//2)] while len(queue) &gt; 0: if end % 2 == 0: start += else: spare = start+1 start += 2 end = start + len(queue) - 1 queue = [for i in range(start, end+1)] if __name__ == \"__main__\": solution()ㅇ\n복사 어려워서 pass pop 시간복잡도가 많이 걸린다고 해서. pop을 쓰지 않기로 함. 메모리는 많이 쓰겠지만, 그냥 계솔 추가하고 pointer를 옮겨가는 방식으로 import sys def solution(): N = int(sys.stdin.readline().rstrip()) queue = [i+1 for i in range(N)] point = 0 while N &gt; 1: queue[point] = 0 card = queue[point + 1] queue.append(card) N -= 1 point += 2 print(queue[point]) if __name__ == \"__main__\": solution()\n복사\n근데 생각해보면 첫턴에 홀수 빼고 시작하는 것 정도는 추가할 수 있을 것같아서. 시도.\n어려웠던건, N이 짝수냐 홀수냐에 따라서 시작 숫자가 달라지는데 그거 생각하는 게 어려웠음. 5랑 4로 예시들어가면서 했다ㅋㅋㅋ\nN 값 조정해주는 걸 생각했어야했는데, 잊고 있어서 시행착오 몇번\nimport sys def solution(): N = int(sys.stdin.readline().rstrip()) queue = [2*(i+1) for i in range(N//2)] point = 0 if N%2 == 1: card = queue[point] queue.append(card) point = 1 N //= 2 while N &gt; 1: card = queue[point + 1] queue.append(card) N -= 1 point += 2 print(queue[point]) if __name__ == \"__main__\": solution\n복사\nㅇ\n인덱스 에러가, if N%2부분에서 나더라\n생각해보니 N이 1이면, N//2는 0이되는데 그러면 []가 만들어지고, queue[0(=point)]의 값은 없음…\n그래서 이부분만 뗴어내서 print(1)해주는 걸로 처리함.\nimport sys def solution(): N = int(sys.stdin.readline().rstrip()) queue = [2*(i+1) for i in range(N//2)] point = 0 if N == 1: return 1 if N%2 == 1: card = queue[point] queue.append(card) point = 1 N //= 2 while N &gt; 1: card = queue[point + 1] queue.append(card) N -= 1 point += 2 return queue[point] if __name__ == \"__main__\": print(solution())\n복사\npop은 변수를 빼고 한칸씩 옮기기 때문에 O(n)의 시간복잡도가 걸림. → 대신 collections 모듈의 deque을 사용하여 popleft()메소드를 사용하는 걸 추천함\n앞으로는 증명법 이용해서 풀어보는 것도 좋을것 같다… 이산구조 열심히 해야지.\n입력으로 1 이상 1,000,000 이하의 정수 N이 주어진다면 N=1, N=2 등의 최소 케이스가 잘 나오는지 확인하는 것이 좋습니다.\nN=1,000,000 같은 최대 케이스를 넣었을 때 주어진 시간 제한 안에 답이 나오는지도 확인해 볼 수 있습니다.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"카드2","level":1,"id":"카드2"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before","level":2,"id":"Before"},{"heading":"1차 → 시간 초과","level":3,"id":"1차_→_시간_초과"},{"heading":"2차 → runtime error(index)","level":3,"id":"2차_→_runtime_error(index)"},{"heading":"3차","level":3,"id":"3차"},{"heading":"After","level":2,"id":"After"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/카드2.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247001,"modifiedTime":1709035530607,"sourceSize":5923,"sourcePath":"1. Study/Coding Test/PS/카드2.md","exportPath":"1.-study/coding-test/ps/카드2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/코테-질문-모음.html":{"title":"코테 질문 모음","icon":"","description":"<a href=\".?query=tag:코딩테스트\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#코딩테스트\">#코딩테스트</a> 동전문제 싹 풀어보자…\n","aliases":[],"inlineTags":["#코딩테스트"],"frontmatterTags":["#정리"],"headers":[{"heading":"코테 질문 모음","level":1,"id":"코테 질문 모음"}],"links":["?query=tag:%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/코테-질문-모음.html","pathToRoot":"../../..","attachments":[],"createdTime":1709789469826,"modifiedTime":1715664546550,"sourceSize":143,"sourcePath":"1. Study/Coding Test/PS/코테 질문 모음.md","exportPath":"1.-study/coding-test/ps/코테-질문-모음.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/큐.html":{"title":"큐","icon":"","description":"ID: 10845\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/10845\" target=\"_self\">https://www.acmicpc.net/problem/10845</a>\n난이도: 실버 4\n다시풀기: No\n분류: 자료구조, 큐\n생성 일시: 2023년 4월 27일 오전 9:22정수를 저장하는 큐를&nbsp;구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 여섯 가지이다.\npush X: 정수 X를 큐에 넣는 연산이다.\npop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.\nsize: 큐에 들어있는 정수의 개수를 출력한다.\nempty: 큐가&nbsp;비어있으면 1, 아니면 0을 출력한다.\nfront: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.\nback:&nbsp;큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.\n첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.15\npush 1\npush 2\nfront\nback\nsize\nempty\npop\npop\npop\nsize\nempty\npop\npush 3\nempty\nfront 복사1\n2\n2\n0\n1\n2\n-1\n0\n1\n-1\n0\n3 복사\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/compro0317\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/compro0317\" target=\"_self\">compro0317</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/deunlee\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/deunlee\" target=\"_self\">deunlee</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/175\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/175\" target=\"_self\">자료 구조</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/72\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/72\" target=\"_self\">큐</a> collection.deque 사용해보기\nimport sys\nfrom collections import deque def solution(): N = int(sys.stdin.readline().rstrip()) que = deque([]) while N&gt;0: N-=1 temp = sys.stdin.readline().rstrip() if temp[:4] == \"push\": x = int(temp[5:]) temp = \"push\" try: match temp: case \"push\": que.append(x) case \"pop\": print(que.popleft()) case \"size\": print(len(que)) case \"empty\": if len(que) == 0: print(1) else: print(0) case \"front\": print(que[0]) case \"back\": print(que[-1]) except IndexError: print(-1) if __name__ == \"__main__\": solution()\n복사\nㅇ collemctions.deque 생성 a = collections.deque([]) <br>이터레이션, 피클링,&nbsp;len(d),&nbsp;reversed(d),&nbsp;copy.copy(d)&nbsp;,copy.deepcopy(d),&nbsp;[in](https://docs.python.org/ko/3/reference/expressions.html#in)&nbsp;연산자를 사용한 멤버십 검사 및 첫 번째 요소를 액세스하는&nbsp;d[0]과 같은 서브 스크립트 참조를 지원합니다. 인덱스를 사용하는 액세스는 양쪽 끝에서는 O(1) 이지만 중간에서는 O(n) 으로 느려집니다. 빠른 무작위 액세스를 위해서는 대신 리스트를 사용하십시오. <a data-tooltip-position=\"top\" aria-label=\"https://docs.python.org/ko/3/library/collections.html#collections.deque\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://docs.python.org/ko/3/library/collections.html#collections.deque\" target=\"_self\">collections — 컨테이너 데이터형</a> <br>python에 switch-case문이 없는 이유 <a data-tooltip-position=\"top\" aria-label=\"https://okeybox.tistory.com/395\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://okeybox.tistory.com/395\" target=\"_self\">[Python] 파이썬에 switch-case 문이 없는 이유. 그리고 with Python 3.10 match-case</a> <br>lambda → 매개변수 : 표현식 다음은 두 수를 더하는 함수입니다.\n&gt;&gt;&gt;defhap(x, y):\n...return x + y\n...\n&gt;&gt;&gt; hap(10, 20)\n30 복사 이것을 람다 형식으로는 어떻게 표현할까요?\n&gt;&gt;&gt; (lambda x,y: x + y)(10, 20)\n30\n복사 <a data-tooltip-position=\"top\" aria-label=\"https://wikidocs.net/64\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://wikidocs.net/64\" target=\"_self\">3.5 람다(lambda)</a>\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"큐","level":1,"id":"큐"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"1차 → 성공","level":3,"id":"1차_→_성공"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/큐.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885246941,"modifiedTime":1709035530619,"sourceSize":4511,"sourcePath":"1. Study/Coding Test/PS/큐.md","exportPath":"1.-study/coding-test/ps/큐.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/터렛.html":{"title":"터렛","icon":"","description":"<a href=\".?query=tag:코딩테스트\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#코딩테스트\">#코딩테스트</a><br>\n<a href=\".?query=tag:실버/3\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#실버/3\">#실버/3</a>조규현과 백승환은 터렛에 근무하는 직원이다. 하지만 워낙 존재감이 없어서 인구수는 차지하지 않는다. 다음은 조규현과 백승환의 사진이다.<br><img src=\"https://www.acmicpc.net/upload/201003/dfcmhrjj_142c3w76qg8_b.jpg\" referrerpolicy=\"no-referrer\" target=\"_self\" class=\"is-unresolved\">이석원은 조규현과 백승환에게 상대편 마린(류재명)의 위치를 계산하라는 명령을 내렸다. 조규현과 백승환은 각각 자신의 터렛 위치에서 현재 적까지의 거리를 계산했다.조규현의 좌표&nbsp;(�1,�1)와 백승환의 좌표&nbsp;(�2,�2)가 주어지고, 조규현이 계산한 류재명과의 거리&nbsp;�1과 백승환이 계산한 류재명과의 거리&nbsp;�2가 주어졌을 때, 류재명이 있을 수 있는 좌표의 수를 출력하는 프로그램을 작성하시오.첫째 줄에 테스트 케이스의 개수&nbsp;�가 주어진다. 각 테스트 케이스는 다음과 같이 이루어져 있다.한 줄에 공백으로 구분 된 여섯 정수&nbsp;�1,&nbsp;�1,&nbsp;�1,&nbsp;�2,&nbsp;�2,&nbsp;�2가 주어진다.각 테스트 케이스마다 류재명이 있을 수 있는 위치의 수를 출력한다. 만약 류재명이 있을 수 있는 위치의 개수가 무한대일 경우에는&nbsp;−1&nbsp;출력한다. −10000≤�1,�1,�2,�2≤10000 1≤�1,�2≤10000 3\n0 0 13 40 0 37\n0 0 3 0 7 4\n1 1 1 1 1 52\n1\n0\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baemin0103\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baemin0103\" target=\"_self\">baemin0103</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/koyh1200\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/koyh1200\" target=\"_self\">koyh1200</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/dksdks3737\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/dksdks3737\" target=\"_self\">dksdks3737</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/doju\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/doju\" target=\"_self\">doju</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/124\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/124\" target=\"_self\">수학</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/100\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/100\" target=\"_self\">기하학</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/137\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/137\" target=\"_self\">많은 조건 분기</a>\n","aliases":[],"inlineTags":["#코딩테스트","#실버/3"],"frontmatterTags":[],"headers":[{"heading":"터렛","level":1,"id":"터렛"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"제한","level":3,"id":"제한"},{"heading":"예제 입력 1 복사","level":3,"id":"예제_입력_1 복사"},{"heading":"예제 출력 1 복사","level":3,"id":"예제_출력_1 복사"},{"heading":"출처","level":3,"id":"출처"},{"heading":"알고리즘 분류","level":3,"id":"알고리즘_분류"}],"links":["?query=tag:%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8","?query=tag:%EC%8B%A4%EB%B2%84/3"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/터렛.html","pathToRoot":"../../..","attachments":[],"createdTime":1709346745935,"modifiedTime":1709347250412,"sourceSize":2358,"sourcePath":"1. Study/Coding Test/PS/터렛.md","exportPath":"1.-study/coding-test/ps/터렛.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/통계학.html":{"title":"통계학","icon":"","description":"ID: 2108\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/2108\" target=\"_self\">https://www.acmicpc.net/problem/2108</a>\n난이도: 실버 3\n다시풀기: No\n생성 일시: 2023년 7월 26일 오후 11:48수를 처리하는 것은 통계학에서 상당히 중요한 일이다. 통계학에서 N개의 수를 대표하는 기본 통계값에는 다음과 같은 것들이 있다. 단, N은 홀수라고 가정하자.\n산술평균 : N개의 수들의 합을 N으로 나눈 값\n중앙값 : N개의 수들을 증가하는 순서로 나열했을 경우 그 중앙에 위치하는 값\n최빈값 : N개의 수들 중 가장 많이 나타나는 값\n범위 : N개의 수들 중 최댓값과 최솟값의 차이\nN개의 수가 주어졌을 때, 네 가지 기본 통계값을 구하는 프로그램을 작성하시오.첫째 줄에 수의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 단, N은 홀수이다. 그 다음 N개의 줄에는 정수들이 주어진다. 입력되는 정수의 절댓값은 4,000을 넘지 않는다.첫째 줄에는 산술평균을 출력한다. 소수점 이하 첫째 자리에서 반올림한 값을 출력한다.둘째 줄에는 중앙값을 출력한다.셋째 줄에는 최빈값을 출력한다. 여러 개 있을 때에는 최빈값 중 두 번째로 작은 값을 출력한다.넷째 줄에는 범위를 출력한다.5\n1\n3\n8\n-2\n2 복사2\n2\n1\n10 복사1\n4000 복사4000\n4000\n4000\n0 복사5\n-1\n-2\n-3\n-1\n-2 복사-2\n-2\n-1\n2 복사3\n0\n0\n-1 복사0\n0\n0\n1 복사(0 + 0 + (-1)) / 3 =&nbsp;-0.333333... 이고 이를 첫째 자리에서 반올림하면 0이다. -0으로 출력하면 안된다.\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/bjh3502\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/bjh3502\" target=\"_self\">bjh3502</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/bsyun0571\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/bsyun0571\" target=\"_self\">bsyun0571</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jungyh1509\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jungyh1509\" target=\"_self\">jungyh1509</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/kongum\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/kongum\" target=\"_self\">kongum</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/palilo\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/palilo\" target=\"_self\">palilo</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/YunGoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/YunGoon\" target=\"_self\">YunGoon</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/skynet\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/skynet\" target=\"_self\">skynet</a> 아 음수 받는 걸 생각못함.. idxf로 최빈값 찾기불가\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"통계학","level":1,"id":"통계학"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"예제 입력 3","level":2,"id":"예제_입력_3"},{"heading":"예제 출력 3","level":2,"id":"예제_출력_3"},{"heading":"예제 입력 4","level":2,"id":"예제_입력_4"},{"heading":"예제 출력 4","level":2,"id":"예제_출력_4"},{"heading":"출처","level":2,"id":"출처"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/통계학.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885246927,"modifiedTime":1709035530624,"sourceSize":2676,"sourcePath":"1. Study/Coding Test/PS/통계학.md","exportPath":"1.-study/coding-test/ps/통계학.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/트리.html":{"title":"트리","icon":"","description":"ID: 0\nSite: 알고리즘\n다시풀기: No\n분류: 너비 우선 탐색, 트리\n생성 일시: 2023년 8월 19일 오후 4:51\nTree: set of node → node have a parent-child relationship In order for a tree to form, It needs root. Root node is the essential component.\nhas no parent Understanding to use the tree when we write recursive code tree can be of only one node(root) with empyt subtree\nor even empty Use to store the information that have inherent relationships.\nordered tree means hierarchical and linear relationships among the children of each node nodes(vertax), edges\nroot\nchild, parent, sibiling(same level)\ndescendant, ancestor → 판단 기준: reachable\nexteranal nodes(leave), internal nodes → 판단 기준: have child\nsub tree\ndegree of a node: number of its children\npath: set of edges that connect two node\ntyer exists a unique path between any pair of nodes level: length of unique path from the root to node\nheight of a tree: maximum level of a node ordered tree\nevery node has at most two children (left child, right child)\ntype proper: all nodes have exactly zero of two children ←→ improper example dicision tree\narithmetic expression n = # of nodes\nn_e = # of external nodes\nn_i = # of intermal nodes\nh = height of tree general tree → linked structure node haves element\nparent\nsequence of children node haves element\nparent\nleft child\nright child time complexity add, delete (except find): O(1)\nheight: O(n) → check all node to find maximum depth. position assign an index to each node based on level: level numbering\nindex(root) = 0\nindex(left child) = 2(index(parant node)) + 1\nindex(right child) = 2(index(parant node)) + 2 advantage position p can be expressed by single integer\nparent,left, and right of p can all be arithmetically computed disadvantage size of array depend on max f(p) → can have a lot of empty node (ex) right-child-only tree)\nUpdating(add, delete) a node is cannot be done efficiently. O(n) → 중간에 빼거나 넣는 경우 자리를 다 옮겨줘야함. depth-first\nvisit node before its descendants. → 조상부터 방문\n(recusive) visit → move to next node(child, sibiling) visit → child chcek → visit → child child check → x → child sibiling order: root → left → right depth-first\nvisit node before its ancestor. → 후손부터 방문\n(recusive) move to next node(child, sibiling) → visit child chcek → child child check → x → child visit → child sibiling child check → x → visit → child sibiling sibiling x → parent visit. order : left → right → root non-recursive\nvisit all the nodes in each level before checking the nodes at the next level\nimplement to use queue → when the node is popped, the children of the node is appended.\n노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택\n<a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html\" target=\"_self\">https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html</a> left chect → visit → root → right\nif left → if left → if left → visit → root visit → right visit → left visit → rot visit\norder: left → root → right\ndef inorder(v) if left(v) != null: print(\"(\") inorder(left(v)) print(v.element) if right(v) != null: inorder(right(v)) 복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"트리","level":1,"id":"트리"},{"heading":"Definition","level":1,"id":"Definition"},{"heading":"terminology","level":2,"id":"terminology"},{"heading":"Binary Trees","level":1,"id":"Binary_Trees"},{"heading":"Property","level":2,"id":"Property"},{"heading":"Implement","level":1,"id":"Implement"},{"heading":"binary tree","level":2,"id":"binary_tree"},{"heading":"linked structure","level":3,"id":"linked_structure"},{"heading":"Array-Based","level":3,"id":"Array-Based"},{"heading":"Tree Traversal","level":1,"id":"Tree_Traversal"},{"heading":"preorder","level":2,"id":"preorder"},{"heading":"postorder","level":2,"id":"postorder"},{"heading":"breadth-First","level":2,"id":"breadth-First"},{"heading":"inorder","level":2,"id":"inorder"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/트리.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885246887,"modifiedTime":1709035530634,"sourceSize":3925,"sourcePath":"1. Study/Coding Test/PS/트리.md","exportPath":"1.-study/coding-test/ps/트리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/프린터-큐.html":{"title":"프린터 큐","icon":"","description":"ID: 1966\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1966\" target=\"_self\">https://www.acmicpc.net/problem/1966</a>\n난이도: 실버 3\n다시풀기: No\n분류: 구현, 시뮬레이션, 자료구조, 큐\n생성 일시: 2023년 9월 14일 오후 12:04여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다. 여러 개의 문서가 쌓인다면 Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄가 되게 된다. 하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.\n현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.\n나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.\n예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다. 예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과, 몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M &lt; N)이 주어진다. 이때 맨 왼쪽은 0번째라고 하자. 두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다. 중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.각 테스트 케이스에 대해 문서가 몇 번째로 인쇄되는지 출력한다.3\n1 0\n5\n4 2\n1 2 3 4\n6 0\n1 1 9 1 1 1 복사1\n2\n5 복사<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/1\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/1\" target=\"_self\">ICPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/7\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/7\" target=\"_self\">Regionals</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/10\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/10\" target=\"_self\">Europe</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/15\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/15\" target=\"_self\">Northwestern European Regional Contest</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/55\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/55\" target=\"_self\">NWERC 2006</a>&nbsp;F번\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/doju\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/doju\" target=\"_self\">doju</a>\n<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/iiwwnnaa\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/iiwwnnaa\" target=\"_self\">iiwwnnaa</a>,&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a> 원래 진짜 문제에 나온대로 pop하고 append하는 식으로 했는데 너무 과해,,,,\n그냥 화살표를 옮기는 방식으로 하자.\nimport sys def printque(): N = int(sys.stdin.readline().rstrip()) for i in range(N): num, idx = map(int, sys.stdin.readline().split()) que = list(map(int, sys.stdin.readline().split())) result(que, idx) def result(que, target): cnt = 0 flag = 0 M = max(que) while True: if que[flag] == M and que[flag] != -1: cnt += 1 if target == flag: print(cnt) break que[flag] = -1 M = max(que) flag = (flag+1)% len(que) return if __name__ == \"__main__\": printque()\n복사복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"프린터 큐","level":1,"id":"프린터 큐"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/프린터-큐.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885246872,"modifiedTime":1709035530639,"sourceSize":3826,"sourcePath":"1. Study/Coding Test/PS/프린터 큐.md","exportPath":"1.-study/coding-test/ps/프린터-큐.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/한수.html":{"title":"한수","icon":"","description":"<a href=\".?query=tag:코딩테스트\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#코딩테스트\">#코딩테스트</a>ID: 1065\nSite: 백준<br>\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1065\" target=\"_self\">https://www.acmicpc.net/problem/1065</a>\n난이도: 실버 4\n다시풀기: Yes\n분류: 브루트포스 알고리즘\n생성 일시: 2023년 5월 2일 오전 10:24\n💡 다른 풀이 이해하기어떤 양의 정수 X의 각 자리가 등차수열을 이룬다면, 그 수를 한수라고 한다. 등차수열은 연속된 두 개의 수의 차이가 일정한 수열을 말한다. N이 주어졌을 때, 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력하는 프로그램을 작성하시오.첫째 줄에 1,000보다 작거나 같은 자연수 N이 주어진다.첫째 줄에 1보다 크거나 같고, N보다 작거나 같은 한수의 개수를 출력한다.110 복사99 복사1 복사1 복사210 복사105 복사1000 복사144 복사500 복사119 복사\n<br>문제를 번역한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>어색한 표현을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/bdh3313\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/bdh3313\" target=\"_self\">bdh3313</a>\n<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/djm03178\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/djm03178\" target=\"_self\">djm03178</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jh05013\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jh05013\" target=\"_self\">jh05013</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/125\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/125\" target=\"_self\">브루트포스 알고리즘</a> 입력 자릿수가 2보다 같거나 작으면 그대로 출력하면됨\n2보다 크면, 두가지 선택지가 있는데 하나는 다 구해서, 속하는 것까지 잘라내기\n나머지 하나는 규칙성을 가지고 구하기. → 어려우니까 일단 위에걸로. import sys def solution(): x = int(sys.stdin.readline().rstrip()) # x = int(x_str) if x &lt;= 99: return(x) n = 100 result = 99 while n &lt;= x: a_0 = n % 10 a_1 = (n//10) % 10 d = a_1 - a_0 result += 1 n_len = len(str(n)) for i in range(2,n_len): a_0 = a_1 a_1 = (n//(10**i)) % 10 if d != a_1 - a_0: result -= 1 break n += 1 return result if __name__ == \"__main__\": print(solution())\n복사\n훨씬 빠른 풀이가 있었음\n이해해보기\ndef func(a): if(a&lt;100): return a else: x = 99 for i in range(100,a+1): if(int(i/100)+i%10==2*(int(i/10)%10)): x = x+1 return x x = int(input())\nprint(func(x))\n복사\n보다 규칙성과 확장성을 가진 코드로 만들어 보기로함\nimport sys def solution(): x = int(sys.stdin.readline().rstrip()) # x: 두자리 이하의 양의정수 if x &lt;= 99: return(x) # x가 abc(d)일 때 a(b-1)9(9)까지 탐색 n = 10 result = 99 i = 1 while n &lt; x//(10**i): d = ((n%10) - (n//10))*i a_1 = n%10 if a_1+d &gt;= 0 and a_1+d&lt;=9: result+=1 n += 1 # 자릿수 변화 if n == 100: n = 10 i += 1 # ab--일때 탐색 a_1 = n%10 d = ((n%10) - (n//10))*i if a_1+d &gt;= 0 and a_1+d&lt;=9: x_ = n for j in range(1,i+1): d = ((n%10) - (n//10))*j x_ = x_*(10*j) + (d+a_1) if x_ &lt;= x: result += 1 return result if __name__ == \"__main__\": print(solution())\n복사\n원래는 자릿수 변환이 i =2 였는데, 더 많은 자릿수에서 작동할 수 있도록 i+=로 변경\n확실히 위 아래 코드를 비교했을 때, 후자가 빠름 input = 1000000 전자: 5.945936679840088\n후자: 3.5561044216156006 input = 10000000 전자: 23.153870820999146\n후자: 2.911761999130249 시간복잡도 전자: x*x의 자릿수-3\n후자: (while) (n)99*x의자릿수-2 + 자릿수.\nx의 자릿수를 x에 대한 식으로 표현가능하다고 본다면,\n전자는 O(x^2) / 후자는 O(x) python 시간 복잡도를 측정하는 방법\nimport time\nstart = time.time() ... print(\"time :\", time.time() - start)\n복사 ","aliases":[],"inlineTags":["#코딩테스트"],"frontmatterTags":[],"headers":[{"heading":"한수","level":1,"id":"한수"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"예제 입력 3","level":2,"id":"예제_입력_3"},{"heading":"예제 출력 3","level":2,"id":"예제_출력_3"},{"heading":"예제 입력 4","level":2,"id":"예제_입력_4"},{"heading":"예제 출력 4","level":2,"id":"예제_출력_4"},{"heading":"예제 입력 5","level":2,"id":"예제_입력_5"},{"heading":"예제 출력 5","level":2,"id":"예제_출력_5"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Before: 생각","level":2,"id":"Before_생각"},{"heading":"1차","level":3,"id":"1차"},{"heading":"다른 풀이","level":3,"id":"다른_풀이"},{"heading":"마지막","level":3,"id":"마지막"},{"heading":"After: 지식","level":2,"id":"After_지식"}],"links":["?query=tag:%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/한수.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885246857,"modifiedTime":1709035563084,"sourceSize":4748,"sourcePath":"1. Study/Coding Test/PS/한수.md","exportPath":"1.-study/coding-test/ps/한수.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/atm.html":{"title":"ATM","icon":"","description":"ID: 11399\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/11399\" target=\"_self\">https://www.acmicpc.net/problem/11399</a>\n난이도: 실버 4\n다시풀기: No\n분류: 그리디 알고리즘, 정렬\n생성 일시: 2023년 8월 7일 오후 10:21\n💡 **input을 int의 list로 받을 때 깔끔하게 쓰는 법**P = list(map(int,sys.stdin.readline().split()))\n복사인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번&nbsp;사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1&nbsp;= 3, P2&nbsp;= 1, P3&nbsp;= 4, P4&nbsp;= 3, P5&nbsp;= 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi&nbsp;≤ 1,000)첫째 줄에&nbsp;각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.5\n3 1 4 3 2 복사32 복사\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a>\n<br>문제의 오타를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/hakgb11\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/hakgb11\" target=\"_self\">hakgb11</a>\n복사import sys def atm(): N = int(sys.stdin.readline().rstrip()) P = list(map(int,sys.stdin.readline().split())) time = 0 P.sort() for i in range(N): time += P[i]*(N-i) print(time) if __name__ == \"__main__\": atm()\n복사P = list(map(int,sys.stdin.readline().split()))\n복사\ninput을 int의 list로 받을 때 깔끔하게 쓰는 법\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"ATM","level":1,"id":"ATM"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"출처","level":2,"id":"출처"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/atm.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247758,"modifiedTime":1709035530153,"sourceSize":3194,"sourcePath":"1. Study/Coding Test/PS/ATM.md","exportPath":"1.-study/coding-test/ps/atm.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/bufferedreader.html":{"title":"BufferedReader","icon":"","description":"NAV: <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/PS.md\" data-href=\"1. Study/Coding Test/PS/PS.md\" href=\"1.-study/coding-test/ps/ps.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">PS</a><a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90\" target=\"_self\">BufferedReader를 알고 쓰자</a><br>\n<a data-tooltip-position=\"top\" aria-label=\"https://nullnull.tistory.com/23\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://nullnull.tistory.com/23\" target=\"_self\">JAVA 노드 스트림 &amp; 보조 스트림</a>+)\nJava에서 데이터를 읽고 쓰는 방법에는 여러 가지가 있습니다. 그 중에서도&nbsp;Buffer,&nbsp;노드 스트림(Node Stream), 그리고&nbsp;보조 스트림(Auxiliary Stream)에 대해 설명하겠습니다.\n<br><a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\"><strong></strong>: Buffer는 데이터가 전송될 때 일시적으로 저장되는 메모리 영역입니다</a>Buffer<a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">1</a>.&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">Buffer는 속도가 빠른 장치에서 들어오는 모든 데이터를 잠시 저장해놓고 버퍼가 꽉 차거나, 특정 커맨드를 입력받았을 때 일괄적으로 내보내고, 버퍼를 초기화시킵니다</a><a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">1</a>.&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">이렇게 하면 속도가 느린 장치에서 일을 여러번 하지 않도록 속도가 빠른 장치에서 미리미리 처리해두고 \"버퍼\"라는 임시 공간에 보관해두었다가 한번에 넘겨주는 것입니다</a><a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">1</a>.\n<br><a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\"><strong></strong>: 노드 스트림은 스트림의 주축을 이루는 요소입니다</a>노드 스트림(Node Stream)<a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">1</a>.&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">노드 스트림은 데이터 타입 (Char 또는 Byte), 방향 (Input 또는 Output), 노드 타입 (File 또는 키보드 등등)에 따라 결정됩니다</a><a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">1</a>.\n<br><a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\"><strong></strong>: 보조 스트림은 노드 스트림을 통해 들어오거나, 나가는 데이터를 처리하는 것을 도와주는 일종의 플러그인입니다</a>보조 스트림(Auxiliary Stream)<a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">1</a>.&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">보조 스트림은 노드 스트림에 연결되어 기능을 추가하거나 향상시킵니다</a><a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">1</a>.&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">예를 들어,&nbsp;<code></code>와&nbsp;<code></code>은 보조 스트림의 예로, 이들은 노드 스트림에 버퍼링 기능을 추가하여 입출력 효율을 높입니다</a>BufferedReaderBufferedInputStream<a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@kkimbj18/%EB%B2%84%ED%8D%BC%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-Feat.-BufferedReader-vs-Scanner-cache\" target=\"_self\">1</a><a data-tooltip-position=\"top\" aria-label=\"https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://velog.io/@roycewon/BufferedReader%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90\" target=\"_self\">2</a>.\n이 세 가지 개념은 Java의 입출력 시스템을 이해하는 데 중요한 역할을 합니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊Scanner&nbsp;클래스는 Java에서 제공하는&nbsp;보조 스트림(Auxiliary Stream)&nbsp;중 하나입니다.&nbsp;Scanner는 기본적으로 입력 스트림을 받아서 다양한 타입의 데이터를 읽을 수 있는 메소드를 제공합니다. 이는&nbsp;InputStream,&nbsp;File,&nbsp;String&nbsp;등 다양한 소스로부터 데이터를 읽을 수 있게 해주는 기능을 추가하는 역할을 하므로, 보조 스트림에 속합니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊InputStreamReader는 Java에서 제공하는&nbsp;노드 스트림(Node Stream)&nbsp;중 하나입니다.&nbsp;InputStreamReader는 바이트 스트림을 문자 스트림으로 변환하는 데 사용됩니다. 이 클래스는&nbsp;System.in과 같은&nbsp;InputStream을&nbsp;Reader로 변환하여, 문자 단위로 읽을 수 있게 해줍니다. 따라서,&nbsp;InputStreamReader는 데이터의 원본(노드)에서 직접 데이터를 읽어오는 역할을 하므로 노드 스트림에 속합니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊System.in과 같은&nbsp;InputStream은 Java에서 제공하는&nbsp;노드 스트림(Node Stream)&nbsp;중 하나입니다.&nbsp;InputStream은 바이트 단위로 데이터를 읽어오는 스트림입니다. 이는 데이터의 원본(노드)에서 직접 데이터를 읽어오는 역할을 하므로 노드 스트림에 속합니다.&nbsp;System.in은 표준 입력 스트림으로, 주로 키보드 입력을 받기 위해 사용됩니다. 이해가 되셨나요? 추가적인 질문이 있으시면 언제든지 물어보세요! 😊+) <a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/board/view/9744\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/board/view/9744\" target=\"_self\">글 읽기 - BufferedReader를 어떻게 사용해야 할지 모르겠습니다.</a>\n일반적으로 BufferedReader 를 통해 입력받을때 유의하셔야 할 점이 몇가지 있습니다.&nbsp;1. 기본적으로 BufferedReader는 한 줄을 통째로 입력받는 방법으로 주로 쓰입니다.2. readLine() 메서드는 값을 읽어올 때, String값으로 개행문자(엔터값)를 포함해&nbsp;한줄을 전부 읽어오는 방식입니다.&nbsp;- 비슷한 예로 Scanner메서드 중 nextLine()도 스트링 값과 개행문자(엔터값)을 같이 읽어옵니다.(반면 next()는 개행문자는 제외하고 스트링 값만 읽어옵니다.)&nbsp;- 예제의 입력 예제를 보면 각 문장이 모두 개행문자(엔터)로 구별되있는것을 확인하실 수 있습니다. 따라서 이 문제에서&nbsp;개행문자를 입력받는것은 필수입니다!3. read() 메서드는 값을 읽어올 때, int값으로 변형하여 읽어오는 방식입니다.&nbsp;&nbsp;- 예를들어 input.txt에 저장된&nbsp;1이라는 숫자를 read()를 통해 읽어오면&nbsp;&nbsp;int형 숫자 1을 읽어오는 것이 아닌, txt형식으로 저장된 ASCII 형식의 문자값 '1'을 읽어오는 것이므로 결국 int값으론 49를 읽어오는 것이 됩니다.&nbsp;&nbsp;- 이를 해결하려면&nbsp;int a = br.read() - 48; br.readLine();&nbsp;을 하여 ASCII 값에서 뻴셈을 이용한 뒤&nbsp;엔터 값을 읽어오거나,&nbsp;int a = Integer.parseInt(br.readLine());&nbsp;를 통해 엔터값을 포함해 한줄을 통째로 입력받은 뒤 해당 스트링값을 int로 형변환 해주는 방법이 있습니다. (저같은 경우에는 주로 후자의 방법을 사용합니다)","aliases":[],"inlineTags":[],"frontmatterTags":["#정리"],"headers":[{"heading":"BufferedReader","level":1,"id":"BufferedReader"}],"links":["1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/bufferedreader.html","pathToRoot":"../../..","attachments":[],"createdTime":1715668282782,"modifiedTime":1716651176315,"sourceSize":8172,"sourcePath":"1. Study/Coding Test/PS/BufferedReader.md","exportPath":"1.-study/coding-test/ps/bufferedreader.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/dna.html":{"title":"DNA","icon":"","description":"ID: 1969\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/1969\" target=\"_self\">https://www.acmicpc.net/problem/1969</a>\n난이도: 실버 4\n다시풀기: No\n분류: 구현, 그리디 알고리즘, 문자열, 브루트포스 알고리즘\n생성 일시: 2023년 8월 4일 오전 12:41\n💡 ******************Deep Copy******************count = [{'A':0, 'T':0, 'G':0, 'C':0}]*M\n# Deep Copy count = [{'A':0, 'T':0, 'G':0, 'C':0} for _ in range(M)]\n# Shallow Copy\n복사**lambda reverse**ch_list = sorted(ch.items(), key=lambda x:x[1])\n# 오름차순 ch_list = sorted(ch.items(), key=lambda x:-x[1])\n# 내림차순\n복사DNA란 어떤 유전물질을 구성하는 분자이다. 이 DNA는 서로 다른 4가지의 뉴클레오티드로 이루어져 있다(Adenine, Thymine, Guanine, Cytosine). 우리는 어떤 DNA의 물질을 표현할 때, 이 DNA를 이루는 뉴클레오티드의 첫글자를 따서 표현한다. 만약에 Thymine-Adenine-Adenine-Cytosine-Thymine-Guanine-Cytosine-Cytosine-Guanine-Adenine-Thymine로 이루어진 DNA가 있다고 하면, “TAACTGCCGAT”로 표현할 수 있다. 그리고 Hamming Distance란 길이가 같은 두 DNA가 있을 때, 각 위치의 뉴클오티드 문자가 다른 것의 개수이다. 만약에 “AGCAT\"와 ”GGAAT\"는 첫 번째 글자와 세 번째 글자가 다르므로 Hamming Distance는 2이다.우리가 할 일은 다음과 같다. N개의 길이 M인 DNA s1, s2, ..., sn가 주어져 있을 때 Hamming Distance의 합이 가장 작은 DNA s를 구하는 것이다. 즉, s와 s1의 Hamming Distance + s와 s2의 Hamming Distance + s와 s3의 Hamming Distance ... 의 합이 최소가 된다는 의미이다.첫 줄에 DNA의 수 N과 문자열의 길이 M이 주어진다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 DNA가 주어진다. N은 1,000보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다.첫째 줄에 Hamming Distance의 합이 가장 작은 DNA 를 출력하고, 둘째 줄에는 그 Hamming Distance의 합을 출력하시오. 그러한 DNA가 여러 개 있을 때에는 사전순으로 가장 앞서는 것을 출력한다.5 8\nTATGATAC\nTAAGCTAC\nAAAGATCC\nTGAGATAC\nTAAGATGT 복사TAAGATAC\n7 복사4 10\nACGTACGTAC\nCCGTACGTAG\nGCGTACGTAT\nTCGTACGTAA 복사ACGTACGTAA\n6 복사6 10\nATGTTACCAT\nAAGTTACGAT\nAACAAAGCAA\nAAGTTACCTT\nAAGTTACCAA\nTACTTACCAA 복사AAGTTACCAA\n12 복사<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/1\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/1\" target=\"_self\">ICPC</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/7\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/7\" target=\"_self\">Regionals</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/42\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/42\" target=\"_self\">Asia Pacific</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/211\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/211\" target=\"_self\">Korea</a>&nbsp;&gt;&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/category/detail/1066\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/category/detail/1066\" target=\"_self\">Asia Regional - Seoul 2006</a>&nbsp;B번\n<br>빠진 조건을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/jsa3824\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/jsa3824\" target=\"_self\">jsa3824</a>\n<br>잘못된 번역을 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/previc1\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/previc1\" target=\"_self\">previc1</a>\n<br>데이터를 추가한 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/sohnjunior\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/sohnjunior\" target=\"_self\">sohnjunior</a>\n<br>잘못된 데이터를 찾은 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/tncks0121\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/tncks0121\" target=\"_self\">tncks0121</a> <br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/102\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/102\" target=\"_self\">구현</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/158\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/158\" target=\"_self\">문자열</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/33\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/33\" target=\"_self\">그리디 알고리즘</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/problem/tag/125\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/tag/125\" target=\"_self\">브루트포스 알고리즘</a> 그 자리의 것들만 비교 4가지 종류 반복 그냥 최빈값들로다가… dict 써서, deep copy count = [{'A':0, 'T':0, 'G':0, 'C':0}]*M\n# Deep Copy count = [{'A':0, 'T':0, 'G':0, 'C':0} for _ in range(M)]\n# Shallow Copy\n복사\nlambda reverse(오름 → 내림)\nch_list = sorted(ch.items(), key=lambda x:x[1])\n# 오름차순 ch_list = sorted(ch.items(), key=lambda x:-x[1])\n# 내림차순\n복사import sys def solution(): N,M = map(int, sys.stdin.readline().rstrip().split()) count = [{'A':0, 'C':0, 'G':0, 'T':0} for _ in range(M)] result = \"\" sum = 0 for i in range(N): line = sys.stdin.readline().rstrip() for j in range(M): if count[j].get(line[j]) == None: count[j][line[j]] = 1 else: count[j][line[j]] += 1 for ch in count: ch_list = sorted(ch.items(), key=lambda x:-x[1]) result += ch_list[0][0] sum += (ch_list[1][1] + ch_list[2][1] + ch_list[3][1]) print(ch_list) print(result) print(sum) if __name__ ==\"__main__\": solution()\n복사@pubhan35 def find_min_dna(): neucleotide, haming_distance, final_dna = 'ACGT', 0, '' element = {alp: 0 for alp in neucleotide} for j in range(M): each_cnt, each_key = 0, '' for i in range(N): element[dna_list[i][j]] += 1 for key in neucleotide: if element[key] &gt; each_cnt: each_cnt, each_key = element[key], key element[key] = 0 final_dna += each_key haming_distance += (N - each_cnt) print(final_dna, haming_distance, sep='\\n') import sys\nnew_input = sys.stdin.readline\nN, M = map(int, new_input().split())\ndna_list = [new_input().rstrip() for _ in range(N)]\nfind_min_dna()\n복사\n변수명 깔끔. 알파벳은 alp로… 2차원 data 접근 나는 row → colum순으로 접근만 가능하다고 착각하고 있었는데,\n위에 코드 처럼 col을 고정하고 row를 돌리는 것도 간단하게 가능. 그렇게 해서 한 col 끝나면 바로 그 줄에 대한 결과 뽑아내고.. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"DNA","level":1,"id":"DNA"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"예제 입력 3","level":2,"id":"예제_입력_3"},{"heading":"예제 출력 3","level":2,"id":"예제_출력_3"},{"heading":"출처","level":2,"id":"출처"},{"heading":"알고리즘 분류","level":2,"id":"알고리즘_분류"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"},{"heading":"공부할만한 코드","level":3,"id":"공부할만한_코드"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/dna.html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247776,"modifiedTime":1709035530179,"sourceSize":5983,"sourcePath":"1. Study/Coding Test/PS/DNA.md","exportPath":"1.-study/coding-test/ps/dna.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/n과-m(1).html":{"title":"N과 M(1)","icon":"","description":"ID: 15649\nSite: 백준\nURL: <a rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/problem/15649\" target=\"_self\">https://www.acmicpc.net/problem/15649</a>\n난이도: 실버 3\n다시풀기: No\n생성 일시: 2023년 9월 3일 오후 6:19자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.\n1부터 N까지&nbsp;자연수 중에서 중복 없이 M개를 고른 수열\n첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.3 1 복사1\n2\n3 복사4 2 복사1 2\n1 3\n1 4\n2 1\n2 3\n2 4\n3 1\n3 2\n3 4\n4 1\n4 2\n4 3 복사4 4 복사1 2 3 4\n1 2 4 3\n1 3 2 4\n1 3 4 2\n1 4 2 3\n1 4 3 2\n2 1 3 4\n2 1 4 3\n2 3 1 4\n2 3 4 1\n2 4 1 3\n2 4 3 1\n3 1 2 4\n3 1 4 2\n3 2 1 4\n3 2 4 1\n3 4 1 2\n3 4 2 1\n4 1 2 3\n4 1 3 2\n4 2 1 3\n4 2 3 1\n4 3 1 2\n4 3 2 1 복사\n<br>문제를 만든 사람:&nbsp;<a data-tooltip-position=\"top\" aria-label=\"https://www.acmicpc.net/user/baekjoon\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://www.acmicpc.net/user/baekjoon\" target=\"_self\">baekjoon</a> 모든 경우의 수 구하기는 BFS → level 1, 2, 3,…\n다른말로 backtracking (사용한 node 만나면 뒤로가기) → pop으로 구\n복사import sys def n_m(): def recursive(result): for i in range(n): if len(result) == m: print(\" \".join(result)) break if str(i+1) not in result: result.append(str(i+1)) recursive(result) if len(result) != 0: result.pop() return \"\" n, m = map(int, sys.stdin.readline().rstrip().split()) recursive([]) if __name__ == \"__main__\": n_m()\n복사from itertools import permutations\nN,M = map(int, input().split(' '))\nprint('\\n'.join(list(map(' '.join, permutations(map(str, range(1, N+1)), M)))))\n복사 그냥 조합을 구해주는 함수를 사용해도됨ㅋㅋㅋㅋ itertools permutations, combinations 등 그리고 아, 굳이 result를 안넘겨 줘도 되는 구나… 같은 list 중복해서 쓰는 줄 알았는데, 차피 pop을 하게 되니까 괜찬은 건가? 아 그리고 잠시만,,, bfs → stack으로 구현가능ㅋㅋㅋㅋㅋ → 아니다 이건 트리라서 좀 다른 거 같음. n, m = list(map(int, input().split()))\ns = []\nli=[]\ndef dfs(): if len(s) == m: li.append(s) return for i in range(1,n+1): if i not in s: s.append(i) dfs() s.pop()\ndfs()\nprint(li)\n복사\n나는 for문 밖에서 pop을 하니까, 길이가 0일때 생기는 문제가 있었는데, 그냥 (전단계, 레벨로) 돌아와서 바로 pop하면 되는구나..\n그리고 프린트 한번에 하기.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"N과 M(1)","level":1,"id":"N과 M(1)"},{"heading":"문제","level":2,"id":"문제"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":2,"id":"입력"},{"heading":"출력","level":2,"id":"출력"},{"heading":"예제 입력 1","level":2,"id":"예제_입력_1"},{"heading":"예제 출력 1","level":2,"id":"예제_출력_1"},{"heading":"예제 입력 2","level":2,"id":"예제_입력_2"},{"heading":"예제 출력 2","level":2,"id":"예제_출력_2"},{"heading":"예제 입력 3","level":2,"id":"예제_입력_3"},{"heading":"예제 출력 3","level":2,"id":"예제_출력_3"},{"heading":"출처","level":2,"id":"출처"},{"heading":"Idea","level":2,"id":"Idea"},{"heading":"Submit code","level":2,"id":"Submit_code"},{"heading":"After submit","level":2,"id":"After_submit"}],"links":[],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/n과-m(1).html","pathToRoot":"../../..","attachments":[],"createdTime":1695885247688,"modifiedTime":1709035530304,"sourceSize":3232,"sourcePath":"1. Study/Coding Test/PS/N과 M(1).md","exportPath":"1.-study/coding-test/ps/n과-m(1).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/ps.html":{"title":"PS","icon":"","description":"<a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/new file.md\" data-href=\"1. Study/Coding Test/PS/new file.md\" href=\"1. Study/Coding Test/PS/new file\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new file</a> | <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/PS/new folder/new folder.md\" data-href=\"1. Study/Coding Test/PS/new folder/new folder.md\" href=\"1. Study/Coding Test/PS/new folder/new folder\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new folder</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"PS","level":1,"id":"PS"},{"heading":"Note","level":3,"id":"Note"},{"heading":"File","level":3,"id":"File"}],"links":["1. Study/Coding Test/PS/new file.md","1. Study/Coding Test/PS/new folder/new folder.md","1.-study/coding-test/ps/입국심사.html","1.-study/coding-test/algorithm/이분탐색.html","1.-study/coding-test/ps/11561.-징검다리.html","1.-study/coding-test/algorithm/이분탐색.html","1.-study/coding-test/ps/1072.-게임.html","1.-study/coding-test/algorithm/이분탐색.html","1.-study/coding-test/etc/숫자-자료형과-계산-오차.html","1.-study/coding-test/ps/1249.-보급로.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1.-study/coding-test/ps/1074.-z.html","1.-study/coding-test/ps/10025.-게으른-백곰.html","1.-study/coding-test/ps/30804.-과일-탕후루.html","1.-study/coding-test/ps/1406.-에디터.html","1.-study/coding-test/ps/11724.-연결-요소의-개수.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1.-study/coding-test/ps/2805.-나무-자르기.html","1.-study/coding-test/ps/1541.-잃어버린-괄호.html","1.-study/coding-test/ps/24228.-젓가락.html","1.-study/coding-test/ps/1260.-dfs와-bfs.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1.-study/coding-test/ps/1476.-subrectangle-queries.html","1.-study/coding-test/ps/99-club-2기-코테-문제-정리.html","1.-study/coding-test/ps/49191.-순위.html","1.-study/coding-test/algorithm/graph/graph.html","1.-study/coding-test/ps/1011.-capacity-to-ship-packages-within-d-days.html","Search","1.-study/coding-test/ps/894.-all-possible-full-binary-trees.html","Dynamic Programming","Tree","1.-study/coding-test/ps/42885.-구명보트.html","1.-study/coding-test/ps/42860.-조이스틱.html","1.-study/coding-test/ps/1302.-deepest-leaves-sum.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1.-study/coding-test/ps/1844.-게임-맵-최단거리.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1.-study/coding-test/ps/43165.-타겟넘버.html","1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1.-study/coding-test/ps/42839.-소수-찾기.html","Search","1.-study/coding-test/ps/42842.-카펫.html","1.-study/coding-test/ps/84512.-모음사전.html","Search","1.-study/coding-test/ps/42747.-h-index.html","Sort","1.-study/coding-test/ps/42746.-가장-큰-수.html","Sort","1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html","heap (Priority Queue)","1.-study/coding-test/ps/42626.-더맵게.html","1.-study/coding-test/ps/1309.동물원.html","1.-study/coding-test/ps/15969.-행복.html","1.-study/coding-test/ps/bufferedreader.html","1.-study/coding-test/ps/1157.-단어-공부.html","1.-study/coding-test/ps/1012.-유기농-배추.html","1.-study/coding-test/ps/1107.-리모컨.html","1.-study/coding-test/ps/1003.-피보나치-함수.html","1.-study/coding-test/ps/코테-질문-모음.html","1.-study/coding-test/ps/11047.-동전-0.html","1.-study/coding-test/ps/12865.-평범한-배낭.html","1.-study/coding-test/ps/11279.-최대-힙.html","1.-study/coding-test/ps/괄호.html","1.-study/coding-test/ps/터렛.html","1.-study/coding-test/ps/01타일.html","1.-study/coding-test/ps/1로-만들기.html","1.-study/coding-test/ps/dna.html","1.-study/coding-test/ps/atm.html","1.-study/coding-test/ps/n과-m(1).html","1.-study/coding-test/ps/개인정보-수집-유효기간.html","1.-study/coding-test/ps/계단-오르기.html","1.-study/coding-test/ps/기본.html","1.-study/coding-test/ps/나는야-포켓몬-마스터-이다솜.html","1.-study/coding-test/ps/나이순-정렬.html","1.-study/coding-test/ps/다이나믹프로그래밍(dp).html","1.-study/coding-test/ps/단어정렬.html","1.-study/coding-test/ps/덩치.html","1.-study/coding-test/ps/듣보잡.html","1.-study/coding-test/ps/1654.-랜선-자르기.html","1.-study/coding-test/ps/로프.html","1.-study/coding-test/ps/마인크래프트.html","1.-study/coding-test/ps/바이러스.html","1.-study/coding-test/ps/보물.html","1.-study/coding-test/ps/본.html","1.-study/coding-test/ps/비밀번호-만들기.html","1.-study/coding-test/ps/색종이.html","1.-study/coding-test/ps/설탕-배달.html","1.-study/coding-test/ps/소수-구하기.html","1.-study/coding-test/ps/수-찾기.html","1.-study/coding-test/ps/수들의-합2.html","1.-study/coding-test/ps/숫자-카드-2.html","1.-study/coding-test/ps/스위치-켜고-끄기.html","1.-study/coding-test/ps/영화감독-숌.html","1.-study/coding-test/ps/요세푸스-문제-0.html","1.-study/coding-test/ps/요세푸스-문제.html","1.-study/coding-test/ps/제목-없음.html","1.-study/coding-test/ps/좌표-정렬.html","1.-study/coding-test/ps/카드2.html","1.-study/coding-test/ps/체스판-다시-칠하기.html","1.-study/coding-test/ps/집합.html","1.-study/coding-test/ps/큐.html","1.-study/coding-test/ps/통계학.html","1.-study/coding-test/ps/트리.html","1.-study/coding-test/ps/프린터-큐.html","1.-study/coding-test/ps/한수.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/ps.html","pathToRoot":"../../..","attachments":[],"createdTime":1716520727132,"modifiedTime":1730330786586,"sourceSize":6908,"sourcePath":"1. Study/Coding Test/PS/PS.md","exportPath":"1.-study/coding-test/ps/ps.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/coding-test.html":{"title":"Coding Test","icon":"","description":"<a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/new file.md\" data-href=\"1. Study/Coding Test/new file.md\" href=\"1. Study/Coding Test/new file\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new file</a> | <a data-tooltip-position=\"top\" aria-label=\"1. Study/Coding Test/new folder/new folder.md\" data-href=\"1. Study/Coding Test/new folder/new folder.md\" href=\"1. Study/Coding Test/new folder/new folder\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new folder</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Coding Test","level":1,"id":"Coding Test"},{"heading":"Note","level":3,"id":"Note"},{"heading":"File","level":3,"id":"File"}],"links":["1. Study/Coding Test/new file.md","1. Study/Coding Test/new folder/new folder.md","1.-study/coding-test/algorithm/algorithm.html","1.-study/coding-test/etc/etc.html","1.-study/coding-test/ps/ps.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/coding-test.html","pathToRoot":"../..","attachments":[],"createdTime":1729745134040,"modifiedTime":1730244462485,"sourceSize":486,"sourcePath":"1. Study/Coding Test/Coding Test.md","exportPath":"1.-study/coding-test/coding-test.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"99-club/99-club.html":{"title":"99 club","icon":"","description":"<a data-tooltip-position=\"top\" aria-label=\"99 club/new file.md\" data-href=\"99 club/new file.md\" href=\"99 club/new file\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new file</a> | <a data-tooltip-position=\"top\" aria-label=\"99 club/new folder/new folder.md\" data-href=\"99 club/new folder/new folder.md\" href=\"99 club/new folder/new folder\" class=\"internal-link is-unresolved\" target=\"_self\" rel=\"noopener nofollow\">new folder</a>","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"99 club","level":1,"id":"99 club"},{"heading":"Note","level":3,"id":"Note"},{"heading":"File","level":3,"id":"File"}],"links":["99 club/new file.md","99 club/new folder/new folder.md","99-club/99클럽-코테-스터디-3일차-til-이분탐색.html","1.-study/coding-test/algorithm/이분탐색.html","99-club/99클럽-코테-스터디-2일차-til-이분탐색.html","1.-study/coding-test/algorithm/이분탐색.html","99-club/99클럽-코테-스터디-1일차-til-이분탐색.html","1.-study/coding-test/algorithm/이분탐색.html","1.-study/coding-test/etc/숫자-자료형과-계산-오차.html"],"author":"","coverImageURL":"","fullURL":"99-club/99-club.html","pathToRoot":"..","attachments":[],"createdTime":1730245834846,"modifiedTime":1730330825912,"sourceSize":895,"sourcePath":"99 club/99 club.md","exportPath":"99-club/99-club.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"99-club/99클럽-코테-스터디-1일차-til-이분탐색.html":{"title":"99클럽 코테 스터디 1일차 TIL 이분탐색","icon":"","description":"<a href=\".?query=tag:99클럽\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#99클럽\">#99클럽</a> <a href=\".?query=tag:코딩테스트준비\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#코딩테스트준비\">#코딩테스트준비</a> <a href=\".?query=tag:개발자취업\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#개발자취업\">#개발자취업</a> <a href=\".?query=tag:항해99\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#항해99\">#항해99</a> <a href=\".?query=tag:TIL\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#TIL\">#TIL</a>김형택은 지금 몰래 Spider Solitaire(스파이더 카드놀이)를 하고 있다. 형택이는 이 게임을 이길 때도 있었지만, 질 때도 있었다. 누군가의 시선이 느껴진 형택이는 게임을 중단하고 코딩을 하기 시작했다. 의심을 피했다고 생각한 형택이는 다시 게임을 켰다. 그 때 형택이는 잠시 코딩을 하는 사이에 자신의 게임 실력이 눈에 띄게 향상된 것을 알았다.\n이제 형택이는 앞으로의 모든 게임에서 지지 않는다. 하지만, 형택이는 게임 기록을 삭제 할 수 없기 때문에, 자신의 못하던 예전 기록이 현재 자신의 엄청난 실력을 증명하지 못한다고 생각했다.\n게임 기록은 다음과 같이 생겼다.\n게임 횟수 : X\n이긴 게임 : Y (Z%)\nZ는 형택이의 승률이고, 소수점은 버린다. 예를 들어, X=53, Y=47이라면, Z=88이다.\nX와 Y가 주어졌을 때, 형택이가 게임을 최소 몇 번 더 해야 Z가 변하는지 구하는 프로그램을 작성하시오.\n각 줄에 정수 X와 Y가 주어진다.첫째 줄에 형택이가 게임을 최소 몇 판 더 해야하는지 출력한다. 만약 Z가 절대 변하지 않는다면 -1을 출력한다.\n1 ≤ X ≤ 1,000,000,000\n0 ≤ Y ≤ X\n<br>승률이 변하는 지점을 ‘찾는’ 문제 → 배열 탐색 중 <a data-href=\"이분탐색\" href=\"1.-study/coding-test/algorithm/이분탐색.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">이분탐색</a> 사용기본 문제처럼 굳이 실제 배열을 만들어서 인덱스로 접근하는 등의 방법을 사용하진 않아도 된다.\nhi lo mid 값을 추가 실행 횟수로 설정하여 승률 계산에 사용하는 방법으로 해결함.비교적 큰수를 다루는 문제이면서 나눗셈이 들어가는 문제이다 보니, 컴퓨터 시스템적 제약으로 인한 오류들이 많이 발생했음(overflow나 정밀도 손상과 같은 문제들)\n부동소수점 문제 나눈 값이 소수점 아래로 긴 값이라 저장 가능 범위를 넘어선다면, 소수점 데이터에 오차가 발생\n거기에 100을 곱한다면 오차가 더 커지게 됨.\n→ 100을 먼저 곱하고 나누어서 오차를 줄이는 방법을 사용 정수 오버플로우 위의 문제 해결을 위해 100을 먼저 곱하게 되면, int 형이 수용할 수 없는 값이 생성 될 수 있음.\nint 형이 저장할 수 있는 최댓값이 2,147,483,647인데, y 최댓값 1,000,000,000에 100을 곱하면 overflow가 발생\n→ 자료형을 long으로 변경: 메모리 많이 사용.\n→ double로 계산하고 int로 type casting // 수정 전\nint x = 100;\nint y = 80;\n// ...\nint now = (double) (y+i) / (x+i) * 100; // double로 계산하지 않으면 소숫점 아래는 다 잘려서 잘못된 값이 나옴 // 곱하기 연산을 먼저하는 것으로 수정\nint x = 100;\nint y = 80;\n// ...\nint now = (y+i) * 100 / (x+i) ; // 100을 먼저 곱하면 필요한 부분 만큼(0~100)은 제대로 계산되기 때문에 double로 계산하지 않아도 된다고 생각. // double 형으로 계산\nint x = 100;\nint y = 80;\n// ...\nint now = (int) ((double) (y+i)/(x+i) *100); // 곱하기 연산을 먼저하는 것으로 수정\ndouble x = 100.0;\ndouble y = 80.0;\n// ...\nint now =(int) ((y+i) * 100/(x+i)); 복사<br>해당 주제에 대한 자세한 내용은 <a data-tooltip-position=\"top\" aria-label=\"숫자 자료형과 계산 오차\" data-href=\"숫자 자료형과 계산 오차\" href=\"1.-study/coding-test/etc/숫자-자료형과-계산-오차.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">다음 링크</a> 참고+)\n승률이 Z보다 작은 경우는 고려하지 않아도됨.\nimport java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] temp = br.readLine().split(\" \"); int X = Integer.parseInt(temp[0]); int Y = Integer.parseInt(temp[1]); int Z = (int) ((double) Y * 100 / X); if (Z == 100) { System.out.println(-1); return; } int lo = 0; int hi = 1000000000; int mid, now; while (lo&lt;hi) { mid = (lo+hi)/2; now = getWinRate(X, Y, mid); if (now == Z) { lo = mid + 1; continue; } if (now &gt; Z) { hi = mid; } } if (getWinRate(X, Y, hi) == Z) System.out.println(-1); else System.out.println(hi); } private static int getWinRate(int x, int y, int i) { return (int) ((double) (y+i) * 100/(x+i)); } }\n복사","aliases":[],"inlineTags":["#99클럽","#코딩테스트준비","#개발자취업","#항해99","#TIL"],"frontmatterTags":[],"headers":[{"heading":"99클럽 코테 스터디 1일차 TIL 이분탐색","level":1,"id":"99클럽 코테 스터디 1일차 TIL 이분탐색"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"제한","level":3,"id":"제한"},{"heading":"입출력","level":3,"id":"입출력"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"정답","level":2,"id":"정답"}],"links":["?query=tag:99%ED%81%B4%EB%9F%BD","?query=tag:%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A4%80%EB%B9%84","?query=tag:%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%B7%A8%EC%97%85","?query=tag:%ED%95%AD%ED%95%B499","?query=tag:TIL","1.-study/coding-test/algorithm/이분탐색.html","1.-study/coding-test/etc/숫자-자료형과-계산-오차.html"],"author":"","coverImageURL":"","fullURL":"99-club/99클럽-코테-스터디-1일차-til-이분탐색.html","pathToRoot":"..","attachments":[],"createdTime":1730184138584,"modifiedTime":1730194883264,"sourceSize":5324,"sourcePath":"99 club/99클럽 코테 스터디 1일차 TIL 이분탐색.md","exportPath":"99-club/99클럽-코테-스터디-1일차-til-이분탐색.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"99-club/99클럽-코테-스터디-2일차-til-이분탐색.html":{"title":"99클럽 코테 스터디 2일차 TIL 이분탐색","icon":"","description":"<a href=\".?query=tag:99클럽\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#99클럽\">#99클럽</a> <a href=\".?query=tag:코딩테스트준비\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#코딩테스트준비\">#코딩테스트준비</a> <a href=\".?query=tag:개발자취업\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#개발자취업\">#개발자취업</a> <a href=\".?query=tag:항해99\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#항해99\">#항해99</a> <a href=\".?query=tag:TIL\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#TIL\">#TIL</a>승택이는 강을 건너려 한다.승택이는 수영을 못하기 때문에, 강에 놓인 징검다리를 밟고 건너갈 것이다.승택이는 수영은 못하지만 제자리뛰기는 정말 잘한다. 원하는 어느 곳으로든지 점프해서 바로 갈 수가 있다.승택이는 이제 강의 한쪽 변 앞에 서 있다.강엔 1번부터 시작해 2번, 3번, ... , N번 징검다리가 차례대로 놓여 있다.강의 폭이 넓은 탓에 징검다리의 수는 엄청나게 많다.이 징검다리를 모두 밟고 싶지는 않았던 승택이는 제자리뛰기 실력을 발휘해 적절한 개수의 징검다리만을 밟고 가기로 했다.물론 강 건너편으로 바로 점프하는 것도 가능하지만, 더 재미있게 강을 건너기 위해 승택이는 다음과 같은 규칙을 정했다.\n첫 징검다리는 점프해서 아무 것이나 밟을 수 있다. 이 점프가 첫 점프이다.\n두 번째 점프부터는 이전에 점프한 거리보다 1 이상 더 긴 거리를 뛰어야만 한다.\nN번 징검다리는 반드시 밟아야 한다.\nN번 징검다리를 밟은 후 강 건너로 이동할 땐 점프를 하지 않으므로 위의 규칙이 적용되지 않는다.\n승택이가 위의 규칙을 지키며 강을 건널 때, 밟을 수 있는 징검다리의 최대 수는 몇 개일까?첫째 줄에 테스트 케이스의 수 T가 주어진다.각 테스트 케이스는 정수 한 개로 이루어져 있으며, 징검다리의 총 수 N을 의미한다. (1 ≤ N ≤ )각 테스트 케이스마다 한 줄에 승택이가 밟을 수 있는 최대 징검다리 수를 출력한다.입력 값이 까지 갈 수 있다는 뜻은 int에서는 overflow 발생한다는 뜻이다. int는 10자리 숫자자까지(대략 2,000,000,000) 반 수용 가능하다. 따라서 long 자료형을 사용해 입력값을 받아야한다.문제에서는 제약조건을 만족하면서 밟을 수 있는 최대 징검다리의 개수를 물어보고 있으므로 승택이 뛰어넘는 징검다리 간격을 매 회 1씩 증가한다는 것으로 고정할 수 있다.이에 따라 징검다리 개수를 으로 두고, 승철이 총 번 징검다리를 건넌다고 했을 때, 남아있는 징검다리의 숫자를 이라고 하자.라는 식이 도출된다.남아있는 징검다리의 숫자인 은 다음 그림에서 표현한 것과 같다. 즉 이 13인 경우, 총 4번을 뛰어넘으면 3칸()이 남아 5칸을 뛰어넘을 수 없다. 대신 4번째로 딛는 곳을 4가 아닌 깃발로 변경하면 된다.<br>\n<img alt=\"Pasted image 20241030171506.png\" src=\"5.-file/image/pasted-image-20241030171506.png\" target=\"_self\">\n따라서 은 0보다 크거나 같아야하고, 이를 수식으로 표현하면 다음과 같다. 해당 방정식을 만족하는 값 중 최대값은이고, 이때, 값이 음수가 될 수는 없으므로\n이것이 문제의 조건을 만족하는 값이다.따라서 코드에서는 이 식을 사용해주면 된다.import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(br.readLine()); for (int i=0; i &lt; T; i++) { long N = Long.parseLong(br.readLine()); System.out.println(getNumOfJump(N)); } } private static int getNumOfJump(long n){ int k = (int) ((double) ((-1 + Math.sqrt(8*n+1)))/2); return k; } }\n복사기본적인 lower bound와 다르게, target값 이상이 처음 등장하는 위치를 반환하는 게 아니라, 아래 그림과 같이 target값을 초과하는 값 바로 전 위치를 반환해야한다. (105가 아니라 91을 선택해야하는 이유에 대해선 위에 이미 설명해두었다.)<br><img alt=\"Pasted image 20241030173905.png\" src=\"5.-file/image/pasted-image-20241030173905.png\" target=\"_self\">\nwhile 조건문 : lo &lt; hi → lo + 1 &lt; hi\ncase 1: N 값과 일치하는 값이 있는 경우. → now == n break하고 mid값 반환 case 2: N 값을 초과하는 경우 → now &gt; n hi에 mid 값 할당. case 3: N 값 미만인 경우 → now &lt; n lo에 mid값 할당 → 해당 mid(= k)가 반환되어야할 값일 수도 있기 때문에. mid + 1을 할당 할 수 없음\n<br>다만 그렇게 되면 무한 루프에 걸릴 수 있기 때문에 (<a data-href=\"이분탐색\" href=\"1.-study/coding-test/algorithm/이분탐색.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">이분탐색</a> 참고) 애당초 lo &lt; hi로 상정해 두었던 조건문을 lo + 1 &lt; hi로 수정 import java.io.*; public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(br.readLine()); for (int i=0; i &lt; T; i++) { long N = Long.parseLong(br.readLine()); System.out.println(getNumOfJump(N)); } } private static long getNumOfJump(long n){ long hi = 1000000000; long lo = 1; long mid, now; while (lo + 1 &lt; hi) { mid = (hi+lo)/2; now = mid*(mid+1) / 2; if (now == n) { lo = mid; break; } if (now &lt; n) { lo = mid; continue; } if (now &gt;= n) { hi = mid; } } return lo; }\n} ```\n→ 이 로직은 (쫌 짜잘하긴 하지만) 처음 hi값을 탐색하지 못하기 때문에 문제가 생길 수 있다. n과 now가 일치하는 케이스(case1)에 해당하면서 처음`hi` 값이 정답인 경우 오답을 반환하게 되는 것이다.\n예를 들어 `lo = 0; hi = 4;`으로 초기화하고, `N = 10`일때, 답이 4가 나와야 하지만 3이 나온다. `hi` 값을 탐색할 기회가 없는 것이다. (이걸 알게된 이유는, 탐색범위를 줄여보겠다고 위에서 썼던 수식을 가져다가 hi에 대입했더니(지금 생각해보면 이 경우 그냥 hi가 정답이다….) 문제가 생겨서이다.) 단순히 범위를 넓게 잡거나(위의 코드처럼 `1000000000` || `Long.MAX_VALUE`처럼) 아니면 다른 사람들이 푼 대로, `while` 조건문을 (`lo&lt;=hi)`로 하고(`lo`, `hi` 갱신 값도 맞게 바꿔야함.) `lo`를 초기화하는 경우에 그 때 `mid`값을 다른 변수에 저장해 두는 것이다. ```java\nprivate static long getNumOfJump2(long n) { long hi = (long) Math.sqrt(2 * n); long lo = 1; long mid, now, ans=0; while (lo &lt;= hi) { mid = (hi + lo) / 2; now = mid * (mid + 1) / 2; if (now == n) { ans = mid; break; } if (now &lt; n) { lo = mid+1; ans = mid; continue; } if (now &gt;= n) { hi = mid-1; } } return ans;\n복사","aliases":[],"inlineTags":["#99클럽","#코딩테스트준비","#개발자취업","#항해99","#TIL"],"frontmatterTags":[],"headers":[{"heading":"99클럽 코테 스터디 2일차 TIL 이분탐색","level":1,"id":"99클럽 코테 스터디 2일차 TIL 이분탐색"},{"heading":"문제","level":2,"id":"문제"},{"heading":"입력","level":3,"id":"입력"},{"heading":"출력","level":3,"id":"출력"},{"heading":"예제","level":3,"id":"예제"},{"heading":"풀이","level":2,"id":"풀이"},{"heading":"이분탐색 풀이","level":3,"id":"이분탐색_풀이"}],"links":["?query=tag:99%ED%81%B4%EB%9F%BD","?query=tag:%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A4%80%EB%B9%84","?query=tag:%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%B7%A8%EC%97%85","?query=tag:%ED%95%AD%ED%95%B499","?query=tag:TIL","1.-study/coding-test/algorithm/이분탐색.html"],"author":"","coverImageURL":"","fullURL":"99-club/99클럽-코테-스터디-2일차-til-이분탐색.html","pathToRoot":"..","attachments":["5.-file/image/pasted-image-20241030171506.png","5.-file/image/pasted-image-20241030173905.png"],"createdTime":1730244449698,"modifiedTime":1730334089112,"sourceSize":7946,"sourcePath":"99 club/99클럽 코테 스터디 2일차 TIL 이분탐색.md","exportPath":"99-club/99클럽-코테-스터디-2일차-til-이분탐색.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"index.html":{"title":"index","icon":"","description":"","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"index","level":1,"id":"index"}],"links":["1.-study/coding-test/algorithm/algorithm.html","1.-study/coding-test/ps/ps.html","99-club/99-club.html"],"author":"","coverImageURL":"","fullURL":"index.html","pathToRoot":".","attachments":[],"createdTime":1716513305154,"modifiedTime":1730246070641,"sourceSize":125,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"1.-study/coding-test/ps/입국심사.html":{"title":"입국심사","icon":"","description":"n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.\n입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.\n각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.\n심사관은 1명 이상 100,000명 이하입니다.\n가장 첫 두 사람은 바로 심사를 받으러 갑니다.7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.‘특성 시간'동안 담당할 수 있는 최대 사람수를 기준으로 이분탐색을 돌렸다.\nlo는 0으로, hi는 (long) (n/times.length)*1000000000 + 1으로 초기화하고 사용해주었는데, hi값의 의미는 관리자의 심사시간이 모두 최댓값(1,000,000,000)인 경우에 가질 수 있는 값 + 1이다. +1은 굳이 안해도 되지만, 앞서서 풀었던 <a data-href=\"11561. 징검다리\" href=\"1.-study/coding-test/ps/11561.-징검다리.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">11561. 징검다리</a> 문제에서 오류를 겪으며, 구간을 널널하게 설정하는 것이 안전하다는 걸 깨달았기 때문이다.<br>이후에는 일반적인 <a data-href=\"이분탐색\" href=\"1.-study/coding-test/algorithm/이분탐색.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">이분탐색</a>을 통한 lower bond 찾기를 사용하면 된다.class Solution { public long solution(int n, int[] times) { long lo = 0; long hi = (n/times.length) * 1000000000L; long mid, now; // lower bound while (lo &lt; hi) { mid = (lo+hi)/2; now = 0; for (int i=0; i&lt;times.length; i++) { now += mid/times[i]; } if (now &lt; n) { lo = mid+1; continue; } if (now &gt;= n){ hi = mid; } } return lo; }\n}\n복사","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"입국심사","level":1,"id":"입국심사"},{"heading":"문제","level":2,"id":"문제"},{"heading":"제한사항","level":3,"id":"제한사항"},{"heading":"입출력 예","level":3,"id":"입출력_예"},{"heading":"입출력 예 설명","level":4,"id":"입출력_예_설명"},{"heading":"풀이","level":2,"id":"풀이"}],"links":["1.-study/coding-test/ps/11561.-징검다리.html","1.-study/coding-test/algorithm/이분탐색.html"],"author":"","coverImageURL":"","fullURL":"1.-study/coding-test/ps/입국심사.html","pathToRoot":"../../..","attachments":[],"createdTime":1730327819330,"modifiedTime":1730330748411,"sourceSize":3301,"sourcePath":"1. Study/Coding Test/PS/입국심사.md","exportPath":"1.-study/coding-test/ps/입국심사.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"},"99-club/99클럽-코테-스터디-3일차-til-이분탐색.html":{"title":"99클럽 코테 스터디 3일차 TIL 이분탐색","icon":"","description":"<a href=\".?query=tag:99클럽\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#99클럽\">#99클럽</a> <a href=\".?query=tag:코딩테스트준비\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#코딩테스트준비\">#코딩테스트준비</a> <a href=\".?query=tag:개발자취업\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#개발자취업\">#개발자취업</a> <a href=\".?query=tag:항해99\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#항해99\">#항해99</a> <a href=\".?query=tag:TIL\" class=\"tag is-unresolved\" target=\"_self\" rel=\"noopener nofollow\" data-href=\"#TIL\">#TIL</a>n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.\n입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.\n각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.\n심사관은 1명 이상 100,000명 이하입니다.\n가장 첫 두 사람은 바로 심사를 받으러 갑니다.7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.‘특성 시간'동안 담당할 수 있는 최대 사람수를 기준으로 이분탐색을 돌렸다.<br>\nlo는 0으로, hi는 (long) (n/times.length)*1000000000 + 1으로 초기화하고 사용해주었는데, hi값의 의미는 관리자의 심사시간이 모두 최댓값(1,000,000,000)인 경우에 가질 수 있는 값 + 1이다. +1은 굳이 안해도 되지만, 앞서서 풀었던 <a data-href=\"11561. 징검다리\" href=\"1.-study/coding-test/ps/11561.-징검다리.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">11561. 징검다리</a> 문제에서 오류를 겪으며, 구간을 널널하게 설정하는 것이 안전하다는 걸 깨달았기 때문이다.<br>이후에는 일반적인 <a data-href=\"이분탐색\" href=\"1.-study/coding-test/algorithm/이분탐색.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">이분탐색</a>을 통한 lower bond 찾기를 사용하면 된다.class Solution { public long solution(int n, int[] times) { long lo = 0; long hi = (n/times.length) * 1000000000L; long mid, now; // lower bound while (lo &lt; hi) { mid = (lo+hi)/2; now = 0; for (int i=0; i&lt;times.length; i++) { now += mid/times[i]; } if (now &lt; n) { lo = mid+1; continue; } if (now &gt;= n){ hi = mid; } } return lo; }\n}\n복사","aliases":[],"inlineTags":["#99클럽","#코딩테스트준비","#개발자취업","#항해99","#TIL"],"frontmatterTags":[],"headers":[{"heading":"99클럽 코테 스터디 3일차 TIL 이분탐색","level":1,"id":"99클럽 코테 스터디 3일차 TIL 이분탐색"},{"heading":"문제","level":2,"id":"문제"},{"heading":"제한사항","level":3,"id":"제한사항"},{"heading":"입출력 예","level":3,"id":"입출력_예"},{"heading":"입출력 예 설명","level":4,"id":"입출력_예_설명"},{"heading":"풀이","level":2,"id":"풀이"}],"links":["?query=tag:99%ED%81%B4%EB%9F%BD","?query=tag:%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A4%80%EB%B9%84","?query=tag:%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%B7%A8%EC%97%85","?query=tag:%ED%95%AD%ED%95%B499","?query=tag:TIL","1.-study/coding-test/ps/11561.-징검다리.html","1.-study/coding-test/algorithm/이분탐색.html"],"author":"","coverImageURL":"","fullURL":"99-club/99클럽-코테-스터디-3일차-til-이분탐색.html","pathToRoot":"..","attachments":[],"createdTime":1730330777656,"modifiedTime":1730330837232,"sourceSize":3366,"sourcePath":"99 club/99클럽 코테 스터디 3일차 TIL 이분탐색.md","exportPath":"99-club/99클럽-코테-스터디-3일차-til-이분탐색.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown"}},"fileInfo":{"1.-study/coding-test/algorithm/graph/0.-graph.html":{"createdTime":1729746324891,"modifiedTime":1730155389024,"sourceSize":2364,"sourcePath":"1. Study/Coding Test/Algorithm/Graph/0. Graph.md","exportPath":"1.-study/coding-test/algorithm/graph/0.-graph.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/algorithm/graph/bfs,-dfs.html":{"createdTime":1729746324891,"modifiedTime":1730155389049,"sourceSize":245,"sourcePath":"1. Study/Coding Test/Algorithm/Graph/BFS, DFS.md","exportPath":"1.-study/coding-test/algorithm/graph/bfs,-dfs.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/algorithm/graph/graph.html":{"createdTime":1729746315529,"modifiedTime":1730155389062,"sourceSize":420,"sourcePath":"1. Study/Coding Test/Algorithm/Graph/Graph.md","exportPath":"1.-study/coding-test/algorithm/graph/graph.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/algorithm/이분탐색.html":{"createdTime":1730105702010,"modifiedTime":1730330897261,"sourceSize":5381,"sourcePath":"1. Study/Coding Test/Algorithm/이분탐색.md","exportPath":"1.-study/coding-test/algorithm/이분탐색.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/algorithm/algorithm.html":{"createdTime":1729745161109,"modifiedTime":1730178905256,"sourceSize":629,"sourcePath":"1. Study/Coding Test/Algorithm/Algorithm.md","exportPath":"1.-study/coding-test/algorithm/algorithm.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/algorithm/help-반례-찾기.html":{"createdTime":1695885247727,"modifiedTime":1715664523820,"sourceSize":2512,"sourcePath":"1. Study/Coding Test/Algorithm/HELP 반례 찾기.md","exportPath":"1.-study/coding-test/algorithm/help-반례-찾기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/algorithm/help-알고리즘.html":{"createdTime":1695885247707,"modifiedTime":1715664498891,"sourceSize":1688,"sourcePath":"1. Study/Coding Test/Algorithm/HELP 알고리즘.md","exportPath":"1.-study/coding-test/algorithm/help-알고리즘.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/algorithm/help-python과-pypy.html":{"createdTime":1695885247742,"modifiedTime":1715664431457,"sourceSize":2332,"sourcePath":"1. Study/Coding Test/Algorithm/Help Python과 Pypy.md","exportPath":"1.-study/coding-test/algorithm/help-python과-pypy.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/algorithm/java-기본.html":{"createdTime":1715664552612,"modifiedTime":1716651176016,"sourceSize":501,"sourcePath":"1. Study/Coding Test/Algorithm/java 기본.md","exportPath":"1.-study/coding-test/algorithm/java-기본.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/etc/숫자-자료형과-계산-오차.html":{"createdTime":1730178201830,"modifiedTime":1730195975735,"sourceSize":3281,"sourcePath":"1. Study/Coding Test/etc/숫자 자료형과 계산 오차.md","exportPath":"1.-study/coding-test/etc/숫자-자료형과-계산-오차.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/etc/etc.html":{"createdTime":1730178878323,"modifiedTime":1730194883558,"sourceSize":415,"sourcePath":"1. Study/Coding Test/etc/etc.md","exportPath":"1.-study/coding-test/etc/etc.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1로-만들기.html":{"createdTime":1695885247792,"modifiedTime":1722965294942,"sourceSize":4838,"sourcePath":"1. Study/Coding Test/PS/1로 만들기.md","exportPath":"1.-study/coding-test/ps/1로-만들기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/01타일.html":{"createdTime":1695885247809,"modifiedTime":1715664196171,"sourceSize":2217,"sourcePath":"1. Study/Coding Test/PS/01타일.md","exportPath":"1.-study/coding-test/ps/01타일.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/99-club-2기-코테-문제-정리.html":{"createdTime":1718329059971,"modifiedTime":1719286062109,"sourceSize":11994,"sourcePath":"1. Study/Coding Test/PS/99 club 2기 코테 문제 정리.md","exportPath":"1.-study/coding-test/ps/99-club-2기-코테-문제-정리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/894.-all-possible-full-binary-trees.html":{"createdTime":1717655095000,"modifiedTime":1717661151414,"sourceSize":6597,"sourcePath":"1. Study/Coding Test/PS/894. All Possible Full Binary Trees.md","exportPath":"1.-study/coding-test/ps/894.-all-possible-full-binary-trees.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1003.-피보나치-함수.html":{"createdTime":1711451603170,"modifiedTime":1716651174946,"sourceSize":4401,"sourcePath":"1. Study/Coding Test/PS/1003. 피보나치 함수.md","exportPath":"1.-study/coding-test/ps/1003.-피보나치-함수.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1011.-capacity-to-ship-packages-within-d-days.html":{"createdTime":1718091347753,"modifiedTime":1718096887816,"sourceSize":3992,"sourcePath":"1. Study/Coding Test/PS/1011. Capacity To Ship Packages Within D Days.md","exportPath":"1.-study/coding-test/ps/1011.-capacity-to-ship-packages-within-d-days.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1012.-유기농-배추.html":{"createdTime":1713097672602,"modifiedTime":1719470788760,"sourceSize":5406,"sourcePath":"1. Study/Coding Test/PS/1012. 유기농 배추.md","exportPath":"1.-study/coding-test/ps/1012.-유기농-배추.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1072.-게임.html":{"createdTime":1730155421558,"modifiedTime":1730194883194,"sourceSize":5222,"sourcePath":"1. Study/Coding Test/PS/1072. 게임.md","exportPath":"1.-study/coding-test/ps/1072.-게임.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1074.-z.html":{"createdTime":1729150187223,"modifiedTime":1729745129072,"sourceSize":2000,"sourcePath":"1. Study/Coding Test/PS/1074. Z.md","exportPath":"1.-study/coding-test/ps/1074.-z.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1107.-리모컨.html":{"createdTime":1712043893584,"modifiedTime":1720419832044,"sourceSize":13494,"sourcePath":"1. Study/Coding Test/PS/1107. 리모컨.md","exportPath":"1.-study/coding-test/ps/1107.-리모컨.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1157.-단어-공부.html":{"createdTime":1715663233721,"modifiedTime":1716651412093,"sourceSize":4267,"sourcePath":"1. Study/Coding Test/PS/1157. 단어 공부.md","exportPath":"1.-study/coding-test/ps/1157.-단어-공부.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1249.-보급로.html":{"createdTime":1729743804958,"modifiedTime":1729745060659,"sourceSize":3842,"sourcePath":"1. Study/Coding Test/PS/1249. 보급로.md","exportPath":"1.-study/coding-test/ps/1249.-보급로.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1260.-dfs와-bfs.html":{"createdTime":1719479659408,"modifiedTime":1719483928777,"sourceSize":4661,"sourcePath":"1. Study/Coding Test/PS/1260. DFS와 BFS.md","exportPath":"1.-study/coding-test/ps/1260.-dfs와-bfs.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1302.-deepest-leaves-sum.html":{"createdTime":1717242562233,"modifiedTime":1717242720230,"sourceSize":861,"sourcePath":"1. Study/Coding Test/PS/1302. Deepest Leaves Sum.md","exportPath":"1.-study/coding-test/ps/1302.-deepest-leaves-sum.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1309.동물원.html":{"createdTime":1715734399261,"modifiedTime":1716651413330,"sourceSize":2329,"sourcePath":"1. Study/Coding Test/PS/1309.동물원.md","exportPath":"1.-study/coding-test/ps/1309.동물원.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1406.-에디터.html":{"createdTime":1719987848903,"modifiedTime":1720007233567,"sourceSize":12510,"sourcePath":"1. Study/Coding Test/PS/1406. 에디터.md","exportPath":"1.-study/coding-test/ps/1406.-에디터.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1476.-subrectangle-queries.html":{"createdTime":1718329925039,"modifiedTime":1719287207557,"sourceSize":3839,"sourcePath":"1. Study/Coding Test/PS/1476. Subrectangle Queries.md","exportPath":"1.-study/coding-test/ps/1476.-subrectangle-queries.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1541.-잃어버린-괄호.html":{"createdTime":1719556054159,"modifiedTime":1719557288483,"sourceSize":2964,"sourcePath":"1. Study/Coding Test/PS/1541. 잃어버린 괄호.md","exportPath":"1.-study/coding-test/ps/1541.-잃어버린-괄호.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1654.-랜선-자르기.html":{"createdTime":1695885247523,"modifiedTime":1719816795564,"sourceSize":5348,"sourcePath":"1. Study/Coding Test/PS/1654. 랜선 자르기.md","exportPath":"1.-study/coding-test/ps/1654.-랜선-자르기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/1844.-게임-맵-최단거리.html":{"createdTime":1717120476373,"modifiedTime":1717146877398,"sourceSize":8233,"sourcePath":"1. Study/Coding Test/PS/1844. 게임 맵 최단거리.md","exportPath":"1.-study/coding-test/ps/1844.-게임-맵-최단거리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html":{"createdTime":1716644611253,"modifiedTime":1717120412817,"sourceSize":6611,"sourcePath":"1. Study/Coding Test/PS/2336. Smallest Number in Infinite Set.md","exportPath":"1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/2805.-나무-자르기.html":{"createdTime":1719660408892,"modifiedTime":1719987897919,"sourceSize":6162,"sourcePath":"1. Study/Coding Test/PS/2805. 나무 자르기.md","exportPath":"1.-study/coding-test/ps/2805.-나무-자르기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/10025.-게으른-백곰.html":{"createdTime":1720420099601,"modifiedTime":1720424580500,"sourceSize":7490,"sourcePath":"1. Study/Coding Test/PS/10025. 게으른 백곰.md","exportPath":"1.-study/coding-test/ps/10025.-게으른-백곰.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/11047.-동전-0.html":{"createdTime":1709787932535,"modifiedTime":1709789606212,"sourceSize":2649,"sourcePath":"1. Study/Coding Test/PS/11047. 동전 0.md","exportPath":"1.-study/coding-test/ps/11047.-동전-0.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/11279.-최대-힙.html":{"createdTime":1709347419168,"modifiedTime":1709349350796,"sourceSize":3822,"sourcePath":"1. Study/Coding Test/PS/11279. 최대 힙.md","exportPath":"1.-study/coding-test/ps/11279.-최대-힙.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/11561.-징검다리.html":{"createdTime":1730239826270,"modifiedTime":1730334066965,"sourceSize":7881,"sourcePath":"1. Study/Coding Test/PS/11561. 징검다리.md","exportPath":"1.-study/coding-test/ps/11561.-징검다리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/11724.-연결-요소의-개수.html":{"createdTime":1719819070201,"modifiedTime":1719824553068,"sourceSize":3192,"sourcePath":"1. Study/Coding Test/PS/11724. 연결 요소의 개수.md","exportPath":"1.-study/coding-test/ps/11724.-연결-요소의-개수.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/12865.-평범한-배낭.html":{"createdTime":1709616141175,"modifiedTime":1709619282299,"sourceSize":3094,"sourcePath":"1. Study/Coding Test/PS/12865. 평범한 배낭.md","exportPath":"1.-study/coding-test/ps/12865.-평범한-배낭.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/15969.-행복.html":{"createdTime":1715732231782,"modifiedTime":1716651412737,"sourceSize":4706,"sourcePath":"1. Study/Coding Test/PS/15969. 행복.md","exportPath":"1.-study/coding-test/ps/15969.-행복.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/24228.-젓가락.html":{"createdTime":1719554136584,"modifiedTime":1719557281531,"sourceSize":2842,"sourcePath":"1. Study/Coding Test/PS/24228. 젓가락.md","exportPath":"1.-study/coding-test/ps/24228.-젓가락.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/30804.-과일-탕후루.html":{"createdTime":1720007296449,"modifiedTime":1720671742800,"sourceSize":6801,"sourcePath":"1. Study/Coding Test/PS/30804. 과일 탕후루.md","exportPath":"1.-study/coding-test/ps/30804.-과일-탕후루.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/42626.-더맵게.html":{"createdTime":1716551190919,"modifiedTime":1717120436046,"sourceSize":6592,"sourcePath":"1. Study/Coding Test/PS/42626. 더맵게.md","exportPath":"1.-study/coding-test/ps/42626.-더맵게.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/42746.-가장-큰-수.html":{"createdTime":1716720709099,"modifiedTime":1717120388344,"sourceSize":3065,"sourcePath":"1. Study/Coding Test/PS/42746. 가장 큰 수.md","exportPath":"1.-study/coding-test/ps/42746.-가장-큰-수.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/42747.-h-index.html":{"createdTime":1716813153943,"modifiedTime":1717120369198,"sourceSize":2210,"sourcePath":"1. Study/Coding Test/PS/42747. H-Index.md","exportPath":"1.-study/coding-test/ps/42747.-h-index.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/42839.-소수-찾기.html":{"createdTime":1716949533159,"modifiedTime":1717120295200,"sourceSize":2185,"sourcePath":"1. Study/Coding Test/PS/42839. 소수 찾기.md","exportPath":"1.-study/coding-test/ps/42839.-소수-찾기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/42842.-카펫.html":{"createdTime":1716862229737,"modifiedTime":1730155389162,"sourceSize":49,"sourcePath":"1. Study/Coding Test/PS/42842. 카펫.md","exportPath":"1.-study/coding-test/ps/42842.-카펫.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/42860.-조이스틱.html":{"createdTime":1717488213595,"modifiedTime":1717560532355,"sourceSize":6074,"sourcePath":"1. Study/Coding Test/PS/42860. 조이스틱.md","exportPath":"1.-study/coding-test/ps/42860.-조이스틱.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/42885.-구명보트.html":{"createdTime":1717560281740,"modifiedTime":1717655089794,"sourceSize":4867,"sourcePath":"1. Study/Coding Test/PS/42885. 구명보트.md","exportPath":"1.-study/coding-test/ps/42885.-구명보트.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/43165.-타겟넘버.html":{"createdTime":1717117448306,"modifiedTime":1717121517595,"sourceSize":2457,"sourcePath":"1. Study/Coding Test/PS/43165. 타겟넘버.md","exportPath":"1.-study/coding-test/ps/43165.-타겟넘버.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/49191.-순위.html":{"createdTime":1718280612048,"modifiedTime":1718286867387,"sourceSize":3466,"sourcePath":"1. Study/Coding Test/PS/49191. 순위.md","exportPath":"1.-study/coding-test/ps/49191.-순위.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/84512.-모음사전.html":{"createdTime":1716862229737,"modifiedTime":1716864631873,"sourceSize":1839,"sourcePath":"1. Study/Coding Test/PS/84512. 모음사전.md","exportPath":"1.-study/coding-test/ps/84512.-모음사전.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/개인정보-수집-유효기간.html":{"createdTime":1695885247669,"modifiedTime":1709035530317,"sourceSize":3160,"sourcePath":"1. Study/Coding Test/PS/개인정보 수집 유효기간.md","exportPath":"1.-study/coding-test/ps/개인정보-수집-유효기간.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/계단-오르기.html":{"createdTime":1695885247654,"modifiedTime":1709035530323,"sourceSize":5003,"sourcePath":"1. Study/Coding Test/PS/계단 오르기.md","exportPath":"1.-study/coding-test/ps/계단-오르기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/괄호.html":{"createdTime":1709347290016,"modifiedTime":1709347314904,"sourceSize":3925,"sourcePath":"1. Study/Coding Test/PS/괄호.md","exportPath":"1.-study/coding-test/ps/괄호.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/기본.html":{"createdTime":1695885247637,"modifiedTime":1709035530338,"sourceSize":178,"sourcePath":"1. Study/Coding Test/PS/기본.md","exportPath":"1.-study/coding-test/ps/기본.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/나는야-포켓몬-마스터-이다솜.html":{"createdTime":1695885247622,"modifiedTime":1709035530352,"sourceSize":11487,"sourcePath":"1. Study/Coding Test/PS/나는야 포켓몬 마스터 이다솜.md","exportPath":"1.-study/coding-test/ps/나는야-포켓몬-마스터-이다솜.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/나이순-정렬.html":{"createdTime":1695885247593,"modifiedTime":1709035530357,"sourceSize":2155,"sourcePath":"1. Study/Coding Test/PS/나이순 정렬.md","exportPath":"1.-study/coding-test/ps/나이순-정렬.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/다이나믹프로그래밍(dp).html":{"createdTime":1695885247581,"modifiedTime":1715664413637,"sourceSize":3646,"sourcePath":"1. Study/Coding Test/PS/다이나믹프로그래밍(DP).md","exportPath":"1.-study/coding-test/ps/다이나믹프로그래밍(dp).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/단어정렬.html":{"createdTime":1695885247568,"modifiedTime":1709035530372,"sourceSize":2190,"sourcePath":"1. Study/Coding Test/PS/단어정렬.md","exportPath":"1.-study/coding-test/ps/단어정렬.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/덩치.html":{"createdTime":1695885247549,"modifiedTime":1709035530386,"sourceSize":4627,"sourcePath":"1. Study/Coding Test/PS/덩치.md","exportPath":"1.-study/coding-test/ps/덩치.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/듣보잡.html":{"createdTime":1695885247536,"modifiedTime":1709035530400,"sourceSize":2612,"sourcePath":"1. Study/Coding Test/PS/듣보잡.md","exportPath":"1.-study/coding-test/ps/듣보잡.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/로프.html":{"createdTime":1695885247510,"modifiedTime":1709035530415,"sourceSize":2325,"sourcePath":"1. Study/Coding Test/PS/로프.md","exportPath":"1.-study/coding-test/ps/로프.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/마인크래프트.html":{"createdTime":1695885247496,"modifiedTime":1709035530422,"sourceSize":4273,"sourcePath":"1. Study/Coding Test/PS/마인크래프트.md","exportPath":"1.-study/coding-test/ps/마인크래프트.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/바이러스.html":{"createdTime":1695885247477,"modifiedTime":1709035530431,"sourceSize":3717,"sourcePath":"1. Study/Coding Test/PS/바이러스.md","exportPath":"1.-study/coding-test/ps/바이러스.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/보물.html":{"createdTime":1695885247431,"modifiedTime":1709035530435,"sourceSize":3031,"sourcePath":"1. Study/Coding Test/PS/보물.md","exportPath":"1.-study/coding-test/ps/보물.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/본.html":{"createdTime":1695885247348,"modifiedTime":1709035530447,"sourceSize":1725,"sourcePath":"1. Study/Coding Test/PS/본.md","exportPath":"1.-study/coding-test/ps/본.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/비밀번호-만들기.html":{"createdTime":1695885247329,"modifiedTime":1709035530452,"sourceSize":2893,"sourcePath":"1. Study/Coding Test/PS/비밀번호 만들기.md","exportPath":"1.-study/coding-test/ps/비밀번호-만들기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/색종이.html":{"createdTime":1695885247314,"modifiedTime":1709035530456,"sourceSize":2212,"sourcePath":"1. Study/Coding Test/PS/색종이.md","exportPath":"1.-study/coding-test/ps/색종이.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/설탕-배달.html":{"createdTime":1695885247298,"modifiedTime":1709035530469,"sourceSize":4138,"sourcePath":"1. Study/Coding Test/PS/설탕 배달.md","exportPath":"1.-study/coding-test/ps/설탕-배달.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/소수-구하기.html":{"createdTime":1695885247241,"modifiedTime":1709035530474,"sourceSize":3151,"sourcePath":"1. Study/Coding Test/PS/소수 구하기.md","exportPath":"1.-study/coding-test/ps/소수-구하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/수-찾기.html":{"createdTime":1695885247205,"modifiedTime":1709035530515,"sourceSize":7445,"sourcePath":"1. Study/Coding Test/PS/수 찾기.md","exportPath":"1.-study/coding-test/ps/수-찾기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/수들의-합2.html":{"createdTime":1695885247190,"modifiedTime":1709035530522,"sourceSize":2688,"sourcePath":"1. Study/Coding Test/PS/수들의 합2.md","exportPath":"1.-study/coding-test/ps/수들의-합2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/숫자-카드-2.html":{"createdTime":1695885247171,"modifiedTime":1709035530533,"sourceSize":5172,"sourcePath":"1. Study/Coding Test/PS/숫자 카드 2.md","exportPath":"1.-study/coding-test/ps/숫자-카드-2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/스위치-켜고-끄기.html":{"createdTime":1695885247092,"modifiedTime":1709035530537,"sourceSize":8067,"sourcePath":"1. Study/Coding Test/PS/스위치 켜고 끄기.md","exportPath":"1.-study/coding-test/ps/스위치-켜고-끄기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/영화감독-숌.html":{"createdTime":1695885247079,"modifiedTime":1709035530542,"sourceSize":6712,"sourcePath":"1. Study/Coding Test/PS/영화감독 숌.md","exportPath":"1.-study/coding-test/ps/영화감독-숌.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/요세푸스-문제.html":{"createdTime":1695885247049,"modifiedTime":1709035530557,"sourceSize":5251,"sourcePath":"1. Study/Coding Test/PS/요세푸스 문제.md","exportPath":"1.-study/coding-test/ps/요세푸스-문제.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/요세푸스-문제-0.html":{"createdTime":1695885247064,"modifiedTime":1709039714803,"sourceSize":3983,"sourcePath":"1. Study/Coding Test/PS/요세푸스 문제 0.md","exportPath":"1.-study/coding-test/ps/요세푸스-문제-0.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/제목-없음.html":{"createdTime":1695885247035,"modifiedTime":1709035530573,"sourceSize":2286,"sourcePath":"1. Study/Coding Test/PS/제목 없음.md","exportPath":"1.-study/coding-test/ps/제목-없음.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/좌표-정렬.html":{"createdTime":1695885247017,"modifiedTime":1709035530583,"sourceSize":578,"sourcePath":"1. Study/Coding Test/PS/좌표 정렬.md","exportPath":"1.-study/coding-test/ps/좌표-정렬.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/집합.html":{"createdTime":1695885246956,"modifiedTime":1709035530589,"sourceSize":2708,"sourcePath":"1. Study/Coding Test/PS/집합.md","exportPath":"1.-study/coding-test/ps/집합.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/체스판-다시-칠하기.html":{"createdTime":1695885246987,"modifiedTime":1709035530601,"sourceSize":5555,"sourcePath":"1. Study/Coding Test/PS/체스판 다시 칠하기.md","exportPath":"1.-study/coding-test/ps/체스판-다시-칠하기.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/카드2.html":{"createdTime":1695885247001,"modifiedTime":1709035530607,"sourceSize":5923,"sourcePath":"1. Study/Coding Test/PS/카드2.md","exportPath":"1.-study/coding-test/ps/카드2.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/코테-질문-모음.html":{"createdTime":1709789469826,"modifiedTime":1715664546550,"sourceSize":143,"sourcePath":"1. Study/Coding Test/PS/코테 질문 모음.md","exportPath":"1.-study/coding-test/ps/코테-질문-모음.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/큐.html":{"createdTime":1695885246941,"modifiedTime":1709035530619,"sourceSize":4511,"sourcePath":"1. Study/Coding Test/PS/큐.md","exportPath":"1.-study/coding-test/ps/큐.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/터렛.html":{"createdTime":1709346745935,"modifiedTime":1709347250412,"sourceSize":2358,"sourcePath":"1. Study/Coding Test/PS/터렛.md","exportPath":"1.-study/coding-test/ps/터렛.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/통계학.html":{"createdTime":1695885246927,"modifiedTime":1709035530624,"sourceSize":2676,"sourcePath":"1. Study/Coding Test/PS/통계학.md","exportPath":"1.-study/coding-test/ps/통계학.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/트리.html":{"createdTime":1695885246887,"modifiedTime":1709035530634,"sourceSize":3925,"sourcePath":"1. Study/Coding Test/PS/트리.md","exportPath":"1.-study/coding-test/ps/트리.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/프린터-큐.html":{"createdTime":1695885246872,"modifiedTime":1709035530639,"sourceSize":3826,"sourcePath":"1. Study/Coding Test/PS/프린터 큐.md","exportPath":"1.-study/coding-test/ps/프린터-큐.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/한수.html":{"createdTime":1695885246857,"modifiedTime":1709035563084,"sourceSize":4748,"sourcePath":"1. Study/Coding Test/PS/한수.md","exportPath":"1.-study/coding-test/ps/한수.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/atm.html":{"createdTime":1695885247758,"modifiedTime":1709035530153,"sourceSize":3194,"sourcePath":"1. Study/Coding Test/PS/ATM.md","exportPath":"1.-study/coding-test/ps/atm.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/bufferedreader.html":{"createdTime":1715668282782,"modifiedTime":1716651176315,"sourceSize":8172,"sourcePath":"1. Study/Coding Test/PS/BufferedReader.md","exportPath":"1.-study/coding-test/ps/bufferedreader.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/dna.html":{"createdTime":1695885247776,"modifiedTime":1709035530179,"sourceSize":5983,"sourcePath":"1. Study/Coding Test/PS/DNA.md","exportPath":"1.-study/coding-test/ps/dna.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/n과-m(1).html":{"createdTime":1695885247688,"modifiedTime":1709035530304,"sourceSize":3232,"sourcePath":"1. Study/Coding Test/PS/N과 M(1).md","exportPath":"1.-study/coding-test/ps/n과-m(1).html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/ps/ps.html":{"createdTime":1716520727132,"modifiedTime":1730330786586,"sourceSize":6908,"sourcePath":"1. Study/Coding Test/PS/PS.md","exportPath":"1.-study/coding-test/ps/ps.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"1.-study/coding-test/coding-test.html":{"createdTime":1729745134040,"modifiedTime":1730244462485,"sourceSize":486,"sourcePath":"1. Study/Coding Test/Coding Test.md","exportPath":"1.-study/coding-test/coding-test.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"99-club/99-club.html":{"createdTime":1730245834846,"modifiedTime":1730330825912,"sourceSize":895,"sourcePath":"99 club/99 club.md","exportPath":"99-club/99-club.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"99-club/99클럽-코테-스터디-1일차-til-이분탐색.html":{"createdTime":1730184138584,"modifiedTime":1730194883264,"sourceSize":5324,"sourcePath":"99 club/99클럽 코테 스터디 1일차 TIL 이분탐색.md","exportPath":"99-club/99클럽-코테-스터디-1일차-til-이분탐색.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"99-club/99클럽-코테-스터디-2일차-til-이분탐색.html":{"createdTime":1730244449698,"modifiedTime":1730334089112,"sourceSize":7946,"sourcePath":"99 club/99클럽 코테 스터디 2일차 TIL 이분탐색.md","exportPath":"99-club/99클럽-코테-스터디-2일차-til-이분탐색.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"index.html":{"createdTime":1716513305154,"modifiedTime":1730246070641,"sourceSize":125,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"site-lib/scripts/graph-wasm.wasm":{"createdTime":1730261277816,"modifiedTime":1730259936228.6655,"sourceSize":23655,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.wasm","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null},"site-lib/fonts/94f2f163d4b698242fef.otf":{"createdTime":1730261335031,"modifiedTime":1730261335031,"sourceSize":66800,"sourcePath":"","exportPath":"site-lib/fonts/94f2f163d4b698242fef.otf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/72505e6a122c6acd5471.woff2":{"createdTime":1730261335030,"modifiedTime":1730261335030,"sourceSize":104232,"sourcePath":"","exportPath":"site-lib/fonts/72505e6a122c6acd5471.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/2d5198822ab091ce4305.woff2":{"createdTime":1730261335030,"modifiedTime":1730261335030,"sourceSize":104332,"sourcePath":"","exportPath":"site-lib/fonts/2d5198822ab091ce4305.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c8ba52b05a9ef10f4758.woff2":{"createdTime":1730261335031,"modifiedTime":1730261335031,"sourceSize":98868,"sourcePath":"","exportPath":"site-lib/fonts/c8ba52b05a9ef10f4758.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cb10ffd7684cd9836a05.woff2":{"createdTime":1730261335032,"modifiedTime":1730261335032,"sourceSize":106876,"sourcePath":"","exportPath":"site-lib/fonts/cb10ffd7684cd9836a05.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/b5f0f109bc88052d4000.woff2":{"createdTime":1730261335032,"modifiedTime":1730261335032,"sourceSize":105804,"sourcePath":"","exportPath":"site-lib/fonts/b5f0f109bc88052d4000.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cbe0ae49c52c920fd563.woff2":{"createdTime":1730261335033,"modifiedTime":1730261335033,"sourceSize":106108,"sourcePath":"","exportPath":"site-lib/fonts/cbe0ae49c52c920fd563.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/535a6cf662596b3bd6a6.woff2":{"createdTime":1730261335034,"modifiedTime":1730261335034,"sourceSize":111708,"sourcePath":"","exportPath":"site-lib/fonts/535a6cf662596b3bd6a6.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1730261335035,"modifiedTime":1730261335035,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1730261335036,"modifiedTime":1730261335036,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1730261335036,"modifiedTime":1730261335036,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1730261335036,"modifiedTime":1730261335036,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1730261335028,"modifiedTime":1730261335028,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/874d8b8e340f75575caa.svg":{"createdTime":1730261335029,"modifiedTime":1730261335029,"sourceSize":317,"sourcePath":"","exportPath":"site-lib/media/874d8b8e340f75575caa.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/3d6c1bdc4d87cde4de67.svg":{"createdTime":1730261335029,"modifiedTime":1730261335029,"sourceSize":279,"sourcePath":"","exportPath":"site-lib/media/3d6c1bdc4d87cde4de67.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1730330850699,"modifiedTime":1730330850699,"sourceSize":42871,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1730261280457,"modifiedTime":1730261280457,"sourceSize":72357,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-wasm.js":{"createdTime":1730261280457,"modifiedTime":1730261280457,"sourceSize":12831,"sourcePath":"","exportPath":"site-lib/scripts/graph-wasm.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/graph-render-worker.js":{"createdTime":1730261280457,"modifiedTime":1730261280457,"sourceSize":5402,"sourcePath":"","exportPath":"site-lib/scripts/graph-render-worker.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/tinycolor.js":{"createdTime":1730261280457,"modifiedTime":1730261280457,"sourceSize":29834,"sourcePath":"","exportPath":"site-lib/scripts/tinycolor.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/pixi.js":{"createdTime":1730261280458,"modifiedTime":1730261280458,"sourceSize":449502,"sourcePath":"","exportPath":"site-lib/scripts/pixi.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/scripts/minisearch.js":{"createdTime":1730261280458,"modifiedTime":1730261280458,"sourceSize":29440,"sourcePath":"","exportPath":"site-lib/scripts/minisearch.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1730261335004,"modifiedTime":1730261335004,"sourceSize":1105,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/snippets.css":{"createdTime":1730330850344,"modifiedTime":1730330850344,"sourceSize":712,"sourcePath":"","exportPath":"site-lib/styles/snippets.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/obsidian.css":{"createdTime":1730261335101,"modifiedTime":1730261335101,"sourceSize":196039,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/theme.css":{"createdTime":1730261280746,"modifiedTime":1730261280746,"sourceSize":216213,"sourcePath":"","exportPath":"site-lib/styles/theme.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1730330850309,"modifiedTime":1730330850309,"sourceSize":628,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/supported-plugins.css":{"createdTime":1730330850309,"modifiedTime":1730330850309,"sourceSize":42664,"sourcePath":"","exportPath":"site-lib/styles/supported-plugins.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1730261280485,"modifiedTime":1730261280485,"sourceSize":17291,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"5.-file/image/스크린샷-2024-10-29-182303-1.png":{"createdTime":1730195000266,"modifiedTime":1730195000266,"sourceSize":45597,"sourcePath":"5. File/image/스크린샷 2024-10-29 182303 1.png","exportPath":"5.-file/image/스크린샷-2024-10-29-182303-1.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"5.-file/image/pasted-image-20241029183732.png":{"createdTime":1730194652073,"modifiedTime":1730194652076,"sourceSize":162841,"sourcePath":"5. File/image/Pasted image 20241029183732.png","exportPath":"5.-file/image/pasted-image-20241029183732.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/fonts/mathjax_zero.woff":{"createdTime":1730261373271,"modifiedTime":1730261373271,"sourceSize":1368,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_zero.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-regular.woff":{"createdTime":1730261373271,"modifiedTime":1730261373271,"sourceSize":34160,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-bold.woff":{"createdTime":1730261373271,"modifiedTime":1730261373271,"sourceSize":34464,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_math-italic.woff":{"createdTime":1730261373271,"modifiedTime":1730261373271,"sourceSize":19360,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_math-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_main-italic.woff":{"createdTime":1730261373271,"modifiedTime":1730261373271,"sourceSize":20832,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_main-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_math-bolditalic.woff":{"createdTime":1730261373271,"modifiedTime":1730261373271,"sourceSize":19776,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_math-bolditalic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size1-regular.woff":{"createdTime":1730261373271,"modifiedTime":1730261373271,"sourceSize":5792,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size1-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size2-regular.woff":{"createdTime":1730261373271,"modifiedTime":1730261373271,"sourceSize":5464,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size2-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size3-regular.woff":{"createdTime":1730261373272,"modifiedTime":1730261373272,"sourceSize":3244,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size3-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_size4-regular.woff":{"createdTime":1730261373272,"modifiedTime":1730261373272,"sourceSize":5148,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_size4-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_ams-regular.woff":{"createdTime":1730261373272,"modifiedTime":1730261373272,"sourceSize":40808,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_ams-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_calligraphic-regular.woff":{"createdTime":1730261373272,"modifiedTime":1730261373272,"sourceSize":9600,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_calligraphic-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_calligraphic-bold.woff":{"createdTime":1730261373272,"modifiedTime":1730261373272,"sourceSize":9908,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_calligraphic-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_fraktur-regular.woff":{"createdTime":1730261373272,"modifiedTime":1730261373272,"sourceSize":21480,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_fraktur-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_fraktur-bold.woff":{"createdTime":1730261373272,"modifiedTime":1730261373272,"sourceSize":22340,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_fraktur-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-regular.woff":{"createdTime":1730261373272,"modifiedTime":1730261373272,"sourceSize":12660,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-bold.woff":{"createdTime":1730261373272,"modifiedTime":1730261373272,"sourceSize":15944,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_sansserif-italic.woff":{"createdTime":1730261373273,"modifiedTime":1730261373273,"sourceSize":14628,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_sansserif-italic.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_script-regular.woff":{"createdTime":1730261373273,"modifiedTime":1730261373273,"sourceSize":11852,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_script-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_typewriter-regular.woff":{"createdTime":1730261373273,"modifiedTime":1730261373273,"sourceSize":17604,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_typewriter-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_vector-regular.woff":{"createdTime":1730261373273,"modifiedTime":1730261373273,"sourceSize":1136,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_vector-regular.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/mathjax_vector-bold.woff":{"createdTime":1730261373273,"modifiedTime":1730261373273,"sourceSize":1116,"sourcePath":"","exportPath":"site-lib/fonts/mathjax_vector-bold.woff","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"1.-study/coding-test/ps/입국심사.html":{"createdTime":1730327819330,"modifiedTime":1730330748411,"sourceSize":3301,"sourcePath":"1. Study/Coding Test/PS/입국심사.md","exportPath":"1.-study/coding-test/ps/입국심사.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"99-club/99클럽-코테-스터디-3일차-til-이분탐색.html":{"createdTime":1730330777656,"modifiedTime":1730330837232,"sourceSize":3366,"sourcePath":"99 club/99클럽 코테 스터디 3일차 TIL 이분탐색.md","exportPath":"99-club/99클럽-코테-스터디-3일차-til-이분탐색.html","showInTree":true,"treeOrder":0,"backlinks":[],"type":"markdown","data":null},"5.-file/image/pasted-image-20241030171506.png":{"createdTime":1730276106909,"modifiedTime":1730276106911,"sourceSize":10462,"sourcePath":"5. File/image/Pasted image 20241030171506.png","exportPath":"5.-file/image/pasted-image-20241030171506.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"5.-file/image/pasted-image-20241030173905.png":{"createdTime":1730277545832,"modifiedTime":1730277545833,"sourceSize":24285,"sourcePath":"5. File/image/Pasted image 20241030173905.png","exportPath":"5.-file/image/pasted-image-20241030173905.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null}},"sourceToTarget":{"1. Study/Coding Test/Algorithm/Graph/0. Graph.md":"1.-study/coding-test/algorithm/graph/0.-graph.html","1. Study/Coding Test/Algorithm/Graph/BFS, DFS.md":"1.-study/coding-test/algorithm/graph/bfs,-dfs.html","1. Study/Coding Test/Algorithm/Graph/Graph.md":"1.-study/coding-test/algorithm/graph/graph.html","1. Study/Coding Test/Algorithm/이분탐색.md":"1.-study/coding-test/algorithm/이분탐색.html","1. Study/Coding Test/Algorithm/Algorithm.md":"1.-study/coding-test/algorithm/algorithm.html","1. Study/Coding Test/Algorithm/HELP 반례 찾기.md":"1.-study/coding-test/algorithm/help-반례-찾기.html","1. Study/Coding Test/Algorithm/HELP 알고리즘.md":"1.-study/coding-test/algorithm/help-알고리즘.html","1. Study/Coding Test/Algorithm/Help Python과 Pypy.md":"1.-study/coding-test/algorithm/help-python과-pypy.html","1. Study/Coding Test/Algorithm/java 기본.md":"1.-study/coding-test/algorithm/java-기본.html","1. Study/Coding Test/etc/숫자 자료형과 계산 오차.md":"1.-study/coding-test/etc/숫자-자료형과-계산-오차.html","1. Study/Coding Test/etc/etc.md":"1.-study/coding-test/etc/etc.html","1. Study/Coding Test/PS/1로 만들기.md":"1.-study/coding-test/ps/1로-만들기.html","1. Study/Coding Test/PS/01타일.md":"1.-study/coding-test/ps/01타일.html","1. Study/Coding Test/PS/99 club 2기 코테 문제 정리.md":"1.-study/coding-test/ps/99-club-2기-코테-문제-정리.html","1. Study/Coding Test/PS/894. All Possible Full Binary Trees.md":"1.-study/coding-test/ps/894.-all-possible-full-binary-trees.html","1. Study/Coding Test/PS/1003. 피보나치 함수.md":"1.-study/coding-test/ps/1003.-피보나치-함수.html","1. Study/Coding Test/PS/1011. Capacity To Ship Packages Within D Days.md":"1.-study/coding-test/ps/1011.-capacity-to-ship-packages-within-d-days.html","1. Study/Coding Test/PS/1012. 유기농 배추.md":"1.-study/coding-test/ps/1012.-유기농-배추.html","1. Study/Coding Test/PS/1072. 게임.md":"1.-study/coding-test/ps/1072.-게임.html","1. Study/Coding Test/PS/1074. Z.md":"1.-study/coding-test/ps/1074.-z.html","1. Study/Coding Test/PS/1107. 리모컨.md":"1.-study/coding-test/ps/1107.-리모컨.html","1. Study/Coding Test/PS/1157. 단어 공부.md":"1.-study/coding-test/ps/1157.-단어-공부.html","1. Study/Coding Test/PS/1249. 보급로.md":"1.-study/coding-test/ps/1249.-보급로.html","1. Study/Coding Test/PS/1260. DFS와 BFS.md":"1.-study/coding-test/ps/1260.-dfs와-bfs.html","1. Study/Coding Test/PS/1302. Deepest Leaves Sum.md":"1.-study/coding-test/ps/1302.-deepest-leaves-sum.html","1. Study/Coding Test/PS/1309.동물원.md":"1.-study/coding-test/ps/1309.동물원.html","1. Study/Coding Test/PS/1406. 에디터.md":"1.-study/coding-test/ps/1406.-에디터.html","1. Study/Coding Test/PS/1476. Subrectangle Queries.md":"1.-study/coding-test/ps/1476.-subrectangle-queries.html","1. Study/Coding Test/PS/1541. 잃어버린 괄호.md":"1.-study/coding-test/ps/1541.-잃어버린-괄호.html","1. Study/Coding Test/PS/1654. 랜선 자르기.md":"1.-study/coding-test/ps/1654.-랜선-자르기.html","1. Study/Coding Test/PS/1844. 게임 맵 최단거리.md":"1.-study/coding-test/ps/1844.-게임-맵-최단거리.html","1. Study/Coding Test/PS/2336. Smallest Number in Infinite Set.md":"1.-study/coding-test/ps/2336.-smallest-number-in-infinite-set.html","1. Study/Coding Test/PS/2805. 나무 자르기.md":"1.-study/coding-test/ps/2805.-나무-자르기.html","1. Study/Coding Test/PS/10025. 게으른 백곰.md":"1.-study/coding-test/ps/10025.-게으른-백곰.html","1. Study/Coding Test/PS/11047. 동전 0.md":"1.-study/coding-test/ps/11047.-동전-0.html","1. Study/Coding Test/PS/11279. 최대 힙.md":"1.-study/coding-test/ps/11279.-최대-힙.html","1. Study/Coding Test/PS/11561. 징검다리.md":"1.-study/coding-test/ps/11561.-징검다리.html","1. Study/Coding Test/PS/11724. 연결 요소의 개수.md":"1.-study/coding-test/ps/11724.-연결-요소의-개수.html","1. Study/Coding Test/PS/12865. 평범한 배낭.md":"1.-study/coding-test/ps/12865.-평범한-배낭.html","1. Study/Coding Test/PS/15969. 행복.md":"1.-study/coding-test/ps/15969.-행복.html","1. Study/Coding Test/PS/24228. 젓가락.md":"1.-study/coding-test/ps/24228.-젓가락.html","1. Study/Coding Test/PS/30804. 과일 탕후루.md":"1.-study/coding-test/ps/30804.-과일-탕후루.html","1. Study/Coding Test/PS/42626. 더맵게.md":"1.-study/coding-test/ps/42626.-더맵게.html","1. Study/Coding Test/PS/42746. 가장 큰 수.md":"1.-study/coding-test/ps/42746.-가장-큰-수.html","1. Study/Coding Test/PS/42747. H-Index.md":"1.-study/coding-test/ps/42747.-h-index.html","1. Study/Coding Test/PS/42839. 소수 찾기.md":"1.-study/coding-test/ps/42839.-소수-찾기.html","1. Study/Coding Test/PS/42842. 카펫.md":"1.-study/coding-test/ps/42842.-카펫.html","1. Study/Coding Test/PS/42860. 조이스틱.md":"1.-study/coding-test/ps/42860.-조이스틱.html","1. Study/Coding Test/PS/42885. 구명보트.md":"1.-study/coding-test/ps/42885.-구명보트.html","1. Study/Coding Test/PS/43165. 타겟넘버.md":"1.-study/coding-test/ps/43165.-타겟넘버.html","1. Study/Coding Test/PS/49191. 순위.md":"1.-study/coding-test/ps/49191.-순위.html","1. Study/Coding Test/PS/84512. 모음사전.md":"1.-study/coding-test/ps/84512.-모음사전.html","1. Study/Coding Test/PS/개인정보 수집 유효기간.md":"1.-study/coding-test/ps/개인정보-수집-유효기간.html","1. Study/Coding Test/PS/계단 오르기.md":"1.-study/coding-test/ps/계단-오르기.html","1. Study/Coding Test/PS/괄호.md":"1.-study/coding-test/ps/괄호.html","1. Study/Coding Test/PS/기본.md":"1.-study/coding-test/ps/기본.html","1. Study/Coding Test/PS/나는야 포켓몬 마스터 이다솜.md":"1.-study/coding-test/ps/나는야-포켓몬-마스터-이다솜.html","1. Study/Coding Test/PS/나이순 정렬.md":"1.-study/coding-test/ps/나이순-정렬.html","1. Study/Coding Test/PS/다이나믹프로그래밍(DP).md":"1.-study/coding-test/ps/다이나믹프로그래밍(dp).html","1. Study/Coding Test/PS/단어정렬.md":"1.-study/coding-test/ps/단어정렬.html","1. Study/Coding Test/PS/덩치.md":"1.-study/coding-test/ps/덩치.html","1. Study/Coding Test/PS/듣보잡.md":"1.-study/coding-test/ps/듣보잡.html","1. Study/Coding Test/PS/로프.md":"1.-study/coding-test/ps/로프.html","1. Study/Coding Test/PS/마인크래프트.md":"1.-study/coding-test/ps/마인크래프트.html","1. Study/Coding Test/PS/바이러스.md":"1.-study/coding-test/ps/바이러스.html","1. Study/Coding Test/PS/보물.md":"1.-study/coding-test/ps/보물.html","1. Study/Coding Test/PS/본.md":"1.-study/coding-test/ps/본.html","1. Study/Coding Test/PS/비밀번호 만들기.md":"1.-study/coding-test/ps/비밀번호-만들기.html","1. Study/Coding Test/PS/색종이.md":"1.-study/coding-test/ps/색종이.html","1. Study/Coding Test/PS/설탕 배달.md":"1.-study/coding-test/ps/설탕-배달.html","1. Study/Coding Test/PS/소수 구하기.md":"1.-study/coding-test/ps/소수-구하기.html","1. Study/Coding Test/PS/수 찾기.md":"1.-study/coding-test/ps/수-찾기.html","1. Study/Coding Test/PS/수들의 합2.md":"1.-study/coding-test/ps/수들의-합2.html","1. Study/Coding Test/PS/숫자 카드 2.md":"1.-study/coding-test/ps/숫자-카드-2.html","1. Study/Coding Test/PS/스위치 켜고 끄기.md":"1.-study/coding-test/ps/스위치-켜고-끄기.html","1. Study/Coding Test/PS/영화감독 숌.md":"1.-study/coding-test/ps/영화감독-숌.html","1. Study/Coding Test/PS/요세푸스 문제.md":"1.-study/coding-test/ps/요세푸스-문제.html","1. Study/Coding Test/PS/요세푸스 문제 0.md":"1.-study/coding-test/ps/요세푸스-문제-0.html","1. Study/Coding Test/PS/제목 없음.md":"1.-study/coding-test/ps/제목-없음.html","1. Study/Coding Test/PS/좌표 정렬.md":"1.-study/coding-test/ps/좌표-정렬.html","1. Study/Coding Test/PS/집합.md":"1.-study/coding-test/ps/집합.html","1. Study/Coding Test/PS/체스판 다시 칠하기.md":"1.-study/coding-test/ps/체스판-다시-칠하기.html","1. Study/Coding Test/PS/카드2.md":"1.-study/coding-test/ps/카드2.html","1. Study/Coding Test/PS/코테 질문 모음.md":"1.-study/coding-test/ps/코테-질문-모음.html","1. Study/Coding Test/PS/큐.md":"1.-study/coding-test/ps/큐.html","1. Study/Coding Test/PS/터렛.md":"1.-study/coding-test/ps/터렛.html","1. Study/Coding Test/PS/통계학.md":"1.-study/coding-test/ps/통계학.html","1. Study/Coding Test/PS/트리.md":"1.-study/coding-test/ps/트리.html","1. Study/Coding Test/PS/프린터 큐.md":"1.-study/coding-test/ps/프린터-큐.html","1. Study/Coding Test/PS/한수.md":"1.-study/coding-test/ps/한수.html","1. Study/Coding Test/PS/ATM.md":"1.-study/coding-test/ps/atm.html","1. Study/Coding Test/PS/BufferedReader.md":"1.-study/coding-test/ps/bufferedreader.html","1. Study/Coding Test/PS/DNA.md":"1.-study/coding-test/ps/dna.html","1. Study/Coding Test/PS/N과 M(1).md":"1.-study/coding-test/ps/n과-m(1).html","1. Study/Coding Test/PS/PS.md":"1.-study/coding-test/ps/ps.html","1. Study/Coding Test/Coding Test.md":"1.-study/coding-test/coding-test.html","99 club/99 club.md":"99-club/99-club.html","99 club/99클럽 코테 스터디 1일차 TIL 이분탐색.md":"99-club/99클럽-코테-스터디-1일차-til-이분탐색.html","99 club/99클럽 코테 스터디 2일차 TIL 이분탐색.md":"99-club/99클럽-코테-스터디-2일차-til-이분탐색.html","index.md":"index.html","":"site-lib/styles/supported-plugins.css","5. File/image/스크린샷 2024-10-29 182303 1.png":"5.-file/image/스크린샷-2024-10-29-182303-1.png","5. File/image/Pasted image 20241029183732.png":"5.-file/image/pasted-image-20241029183732.png","1. Study/Coding Test/PS/입국심사.md":"1.-study/coding-test/ps/입국심사.html","99 club/99클럽 코테 스터디 3일차 TIL 이분탐색.md":"99-club/99클럽-코테-스터디-3일차-til-이분탐색.html","5. File/image/Pasted image 20241030171506.png":"5.-file/image/pasted-image-20241030171506.png","5. File/image/Pasted image 20241030173905.png":"5.-file/image/pasted-image-20241030173905.png"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"displayTitle":"Backlinks","featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"description":"CSS selector for an element. The feature will be placed relative to this element."},"info_type":{"show":true,"description":"Will this feature be placed before, after, or inside (at the beggining or end).","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"description":"Descriptive title to show above the feature"},"info_featurePlacement":{"show":true,"description":"Where to place this feature on the page. Multiple values will be tried in order until one succeeds. Multiple values will not insert this feature multiple times."}},"tags":{"featureId":"tags","enabled":true,"displayTitle":"","featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"description":"CSS selector for an element. The feature will be placed relative to this element."},"info_type":{"show":true,"description":"Will this feature be placed before, after, or inside (at the beggining or end).","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"description":"Descriptive title to show above the feature"},"info_featurePlacement":{"show":true,"description":"Where to place this feature on the page. Multiple values will be tried in order until one succeeds. Multiple values will not insert this feature multiple times."},"showInlineTags":{"show":true,"description":"Show tags that are inline in the document"},"showFrontmatterTags":{"show":true,"description":"Show tags that are in the frontmatter"}},"alias":{"featureId":"aliases","enabled":true,"displayTitle":"","featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"description":"CSS selector for an element. The feature will be placed relative to this element."},"info_type":{"show":true,"description":"Will this feature be placed before, after, or inside (at the beggining or end).","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"description":"Descriptive title to show above the feature"},"info_featurePlacement":{"show":true,"description":"Where to place this feature on the page. Multiple values will be tried in order until one succeeds. Multiple values will not insert this feature multiple times."}},"properties":{"featureId":"properties","enabled":true,"displayTitle":"Properties","featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"description":"CSS selector for an element. The feature will be placed relative to this element."},"info_type":{"show":true,"description":"Will this feature be placed before, after, or inside (at the beggining or end).","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"description":"Descriptive title to show above the feature"},"info_featurePlacement":{"show":true,"description":"Where to place this feature on the page. Multiple values will be tried in order until one succeeds. Multiple values will not insert this feature multiple times."},"info_hideProperties":{"show":true,"description":"A list of properties to hide from the properties view"}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"displayTitle":"","featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"description":"CSS selector for an element. The feature will be placed relative to this element."},"info_type":{"show":true,"description":"Will this feature be placed before, after, or inside (at the beggining or end).","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"description":"Descriptive title to show above the feature"},"info_featurePlacement":{"show":true,"description":"Where to place this feature on the page. Multiple values will be tried in order until one succeeds. Multiple values will not insert this feature multiple times."},"info_includePath":{"show":false,"description":"The path on the server from which this feature can be loaded"},"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showDefaultFolderIcons":{"show":true,"description":"Show a default icon of a folder for every folder in the tree"},"info_showDefaultFileIcons":{"show":true,"description":"Show a default icon of a file for every file in the tree"},"info_defaultFolderIcon":{"show":true,"description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon"},"info_defaultFileIcon":{"show":true,"description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon"},"info_defaultMediaIcon":{"show":true,"description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon"},"info_exposeStartingPath":{"show":true,"description":"Whether or not to show the current file in the file tree when the page is first loaded"},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"displayTitle":"Search...","featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"description":"CSS selector for an element. The feature will be placed relative to this element."},"info_type":{"show":true,"description":"Will this feature be placed before, after, or inside (at the beggining or end).","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"description":"Descriptive title to show above the feature"},"info_featurePlacement":{"show":true,"description":"Where to place this feature on the page. Multiple values will be tried in order until one succeeds. Multiple values will not insert this feature multiple times."}},"outline":{"featureId":"outline","enabled":true,"displayTitle":"Outline","featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"description":"CSS selector for an element. The feature will be placed relative to this element."},"info_type":{"show":true,"description":"Will this feature be placed before, after, or inside (at the beggining or end).","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"description":"Descriptive title to show above the feature"},"info_featurePlacement":{"show":true,"description":"Where to place this feature on the page. Multiple values will be tried in order until one succeeds. Multiple values will not insert this feature multiple times."},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"description":"Should the outline start collapsed?"},"info_minCollapseDepth":{"show":true,"description":"The minimum depth at which headings should be collapsed"}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"displayTitle":"","featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"description":"CSS selector for an element. The feature will be placed relative to this element."},"info_type":{"show":true,"description":"Will this feature be placed before, after, or inside (at the beggining or end).","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"description":"Descriptive title to show above the feature"},"info_featurePlacement":{"show":true,"description":"Where to place this feature on the page. Multiple values will be tried in order until one succeeds. Multiple values will not insert this feature multiple times."}},"graphView":{"featureId":"graph-view","enabled":true,"displayTitle":"Graph View","featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"description":"CSS selector for an element. The feature will be placed relative to this element."},"info_type":{"show":true,"description":"Will this feature be placed before, after, or inside (at the beggining or end).","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"description":"Descriptive title to show above the feature"},"info_featurePlacement":{"show":true,"description":"Where to place this feature on the page. Multiple values will be tried in order until one succeeds. Multiple values will not insert this feature multiple times."},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"description":"Show nodes that are not connected to any other nodes."},"info_showAttachments":{"show":true,"description":"Show attachments like images and PDFs as nodes in the graph."},"info_allowGlobalGraph":{"show":true,"description":"Allow the user to view the global graph of all nodes."},"info_allowExpand":{"show":true,"description":"Allow the user to pop-out the graph view to take up the whole screen"},"info_attractionForce":{"show":true,"description":"How much should linked nodes attract each other? This will make the graph appear more clustered."},"info_linkLength":{"show":true,"description":"How long should the links between nodes be? The shorter the links the closer connected nodes will cluster together."},"info_repulsionForce":{"show":true,"description":"How much should nodes repel each other? This will make the graph appear more spread out."},"info_centralForce":{"show":true,"description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular."},"info_edgePruning":{"show":true,"description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links."},"info_minNodeRadius":{"show":true,"description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes."},"info_maxNodeRadius":{"show":true,"description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes."}},"sidebar":{"featureId":"sidebar","enabled":true,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"description":"Whether or not to allow the sidebars to be resized"},"info_allowCollapsing":{"show":true,"description":"Whether or not to allow the sidebars to be collapsed"},"info_rightDefaultWidth":{"show":true,"description":"The default width of the right sidebar"},"info_leftDefaultWidth":{"show":true,"description":"The default width of the left sidebar"}},"customHead":{"featureId":"custom-head","enabled":true,"displayTitle":"","featurePlacement":{"selector":"head","type":"start","info_selector":{"show":true,"description":"CSS selector for an element. The feature will be placed relative to this element."},"info_type":{"show":true,"description":"Will this feature be placed before, after, or inside (at the beggining or end).","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_displayTitle":{"show":true,"description":"Descriptive title to show above the feature"},"info_featurePlacement":{"show":true,"description":"Where to place this feature on the page. Multiple values will be tried in order until one succeeds. Multiple values will not insert this feature multiple times."},"info_includePath":{"show":false,"description":"The path on the server from which this feature can be loaded"},"sourcePath":"","info_sourcePath":{"show":true,"description":"The local path to the source .html file which will be included.","fileInputOptions":{"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"description":"Whether or not to allow lists to be folded"},"info_allowFoldingHeadings":{"show":true,"description":"Whether or not to allow headings to be folded"},"info_documentWidth":{"show":true,"description":"The width of the document"}}},"modifiedTime":1730334094214,"siteName":"Obsidian","vaultName":"Obsidian","exportRoot":"/","baseURL":"","pluginVersion":"1.9.0-2b","themeName":"","bodyClasses":"publish css-settings-manager mod-windows is-hidden-frameless theme-light show-inline-title show-ribbon show-view-header minimal-default-light minimal-default-dark minimal-readable minimal-dark-tonal borders-none colorful-active links-int-on links-ext-on full-width-media img-grid contextual-typography trim-cols checkbox-square metadata-heading-off sidebar-tabs-wide tabs-modern minimal-tab-title-visible is-focused","hasFavicon":false}